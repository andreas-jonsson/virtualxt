Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-1


					PAGE	 	59,132
					TITLE		GLaBIOS
				
				;----------------------------------------------------------------------------;
				; GLaBIOS (General Libraries and Basic Input Output System)
				;
				; A scratch-built, open-source 8088 PC/clone BIOS alternative.
				;
				; Copyright (c) 2022-2024, 640KB and contributors
				;
				;----------------------------------------------------------------------------;
				;
				; This program is free software: you can redistribute it and/or modify it under the terms 
				; of the GNU General Public License as published by the Free Software Foundation, either 
				; version 3 of the License, or (at your option) any later version.
				;
				; This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; 
				; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. 
				; See the GNU General Public License for more details.
				;
				; You should have received a copy of the GNU General Public License along with this program. 
				; If not, see <https://www.gnu.org/licenses/>.
				;
				;----------------------------------------------------------------------------;
				; References, Credits and Inspiration:
				;
				;  https://stanislavs.org/helppc/
				;  http://www.minuszerodegrees.net/
				;  https://www.felixcloutier.com/x86/
				;  https://sites.google.com/site/pcdosretro/ (offline)
				;
				;  "Programmer's Guide to the IBM(R) PC", Peter Norton
				;  "System BIOS for IBM(R) PC/XT(TM)/AT(R) Computers and Compatibles",
				;	Phoenix Technologies Ltd.
				;  "Programmer's Guide to PC Video Systems", Second Edition, Wilton
				;  (Many more inline...)
				;
				;  Font bitmaps by "VileR", (CC BY-SA 4.0)
				;  https://int10h.org/oldschool-pc-fonts/readme/#legal_stuff
				;
				;  @Raffzahn, Contributor and Meckerhut.
				;
				;  https://github.com/640-KB/GLaBIOS#further-credits-to
				;
				;  "Every byte is sacred, every byte is great,
				;  when a byte is wasted, God gets quite irate..."
				;  - David W. Plummer
				;----------------------------------------------------------------------------;
				; Build Instructions:
				;
				; Build with MASM 5.0 or MASM 6.
				;
				;  MAKE.BAT
				;
				; or
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-2


				;
				;  MASM GLABIOS;
				;  LINK GLABIOS;
				;  GLA2ROM GLABIOS.EXE GLABIOS.ROM		; Build 8K ROM
				;
				; MASM Build Options:
				;  /DVER_DATE='02/22/22'			; Must be MM/DD/YY format
				;  /DARCH_TYPE='X'				; P, X, Y or T (see ARCH_* below)
				;  /DCPU_TYPE='8'					; 8 or V (see CPU_* below)
				;
				;----------------------------------------------------------------------------;
				; POST Error Beep messages:
				;
				; Short  Long
				;	2	1	CPU register test failure
				;	3	1	CPU instruction test failed
				;	4	1	Build is V20 but not detected
				;	2	2	System BIOS ROM checksum error
				;	3	2	PIT counter 1 test failed
				;	4	2	DMA register test failed
				;	5	2	PIC test register failed
				;	5	3	PIC test interrupt failed
				;	1	3	Base RAM (0-16KB) read/write error
				;	3	3	Error loading video adapter ROM
				;	1	4	Base RAM (0-16KB) parity error
				;
				;----------------------------------------------------------------------------;
				
				;----------------------------------------------------------------------------;
				; Build Target Architecture equates (do not edit these)
				;
 = 0050				ARCH_5150		EQU	'P'			; 5150
 = 0058				ARCH_5160		EQU	'X'			; 5160 v1
 = 0059				ARCH_5160v2		EQU	'Y'			; 5160 v2/3
 = 0054				ARCH_TURBO		EQU	'T'			; Standard Turbo or clone
 = 0053				ARCH_TD3300		EQU	'S'			; TD3300A (ST-xx/UNIQUE/Auva)
 = 0046				ARCH_FE2010		EQU	'F'			; Faraday FE2010A
 = 0048				ARCH_EHB		EQU	'H'			; EMM Computers/Homebrew8088
 = 0045				ARCH_EMU		EQU	'E'			; 86Box/Emulator
 = 004D				ARCH_M88		EQU	'M'			; micro_8088/NuXT
 = 0049				ARCH_MIST		EQU	'I'			; PCXT_MiSTer
 = 0055				ARCH_UM82		EQU	'U'			; UMC UM82C088 / ALi M1101
 = 0043				ARCH_MARTY		EQU	'C'			; MartyPC Emulator
 = 0056				ARCH_VEN888		EQU	'V'			; Vendex 888-XT
 = 004C				ARCH_LASER		EQU	'L'			; VTech Laser Turbo XT
 = 0042				ARCH_BOOK88		EQU	'B'			; Book 8088
 = 0051				ARCH_CPQ		EQU	'Q'			; Compaq Portable XT
 = 0041				ARCH_VIRTUALXT	EQU	'A'			; VirtualXT Emulator
				
				;
				; CPU Instruction Set Target
				;
 = 0038				CPU_8088		EQU	'8'			; 808x compatible
 = 0056				CPU_V20		EQU	'V'			; V20 only
				
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-3


				;
				; Boot to Turbo or Normal Speed
				;
 = 0054				BOOT_TURBO		EQU	'T'
 = 004E				BOOT_NORMAL		EQU	'N'
 = 004D				BOOT_MEDIUM		EQU	'M'			; used by FE2010A
				
				;
				; Turbo Switch Behavior
				;
 = 0000				TURBO_NONE		EQU	0			; fixed clock no turbo switching
 = 0001				TURBO_STD		EQU	1			; standard PPI (1=turbo, 0=normal)
 = 0002				TURBO_REV		EQU	2			; reversed PPI (0=turbo, 1=normal)
				
				;----------------------------------------------------------------------------;
				; BIOS Product Info
				;
 = 'GLaBIOS'			VER_NAME		EQU	'GLaBIOS'
 = '2022-24'			COPY_YEAR		EQU	'2022-24'		; Copyright year range
				
				;----------------------------------------------------------------------------;
				; BEGIN Configurable Build Options
				;----------------------------------------------------------------------------;
				; Very important note on custom configuration:
				;
				; Not all options can be combined due to very limited ROM code space of 8K,
				; and fitting withing fixed compatibility ORGs.
				;
				; For experimenting with build options, it's highly recommended to use
				; MASM 5.0 as it will not build if code space is exceeded. Due to differences
				; in MASM 6, this does not work and can produce a totally broken build.
				;----------------------------------------------------------------------------;
				
				;----------------------------------------------------------------------------;
				; Select Target Architecture Preset
				;
				
				;----------------------------------------------------------------------------;
				; Sub Architecture Types (use with the ARCH_TYPE in parentheses)
				;
				
				;----------------------------------------------------------------------------;
				; Default CPU Instruction Set Target
				;
				
				;----------------------------------------------------------------------------;
				; Turbo Type
				;
				; Some motherboards boot in Normal mode by default and the BIOS may or may not
				; switch to Turbo speed on boot. Others invert this behavior where it appears
				; reversed to the BIOS. Use these options to customize for your motherboard.
				;
				
				;----------------------------------------------------------------------------;
				; CGA Snow Removal Method
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-4


				;
 = 0003				CGA_SNOW_REMOVE	=	3		; 0: Snow, Normal Flashing, Fastest
										; 1: Less Snow, Some Flashing, Medium Fast
										; 2: No Snow, Moderate Flashing, Fast
										; 3: No Snow, More Flashing, Quite Fast
				
				;----------------------------------------------------------------------------;
				; Personality Traits
				;
 = 0001				POST_THEME		=	1		; color theme for POST screen (see below)
 = 0000				POST_CLS		=	0		; clear screen after POST
 = 0000				POST_GLADOS		=	0		; say "Starting GLaDOS..." on boot
 = 0001				POST_CONFIG		=	1		; show CPU, FPU and ports on POST
 = 0001				POST_FD_COUNT	=	1		; show floppy drive count on POST
 = 0001				POST_HD_COUNT	=	1		; show hard drive count and params on POST
 = 0001				POST_HD_PARMS	=	1		; show hard drive parameters on POST
 = 0001				POST_OPT_ROM	=	1		; show option ROM address and loading info
 = 0001				POST_VIDEO_TYPE	=	1		; show the video adapter type on POST
 = 0001				POST_WARM_COLD	=	1		; show boot WARM or COLD
 = 0001				POST_BANNER		=	1		; show banner and version
 = 0001				WARM_ENABLE		=	1		; 1=enable WARM boot or 0=always COLD boot
 = 0001				RANDOM_TAGLINE	=	1		; randomize pithy tagline
 = 0000				UNITS_IEC		=	0		; 0=period-correct "KB" or 1=modern IEC "KiB"
				
				;----------------------------------------------------------------------------;
				; Enable/Disable POST tests (not all tests can be enabled due to 8K ROM space)
				;
 = 0000				POST_TEST_INST	=	0		; POST CPU Instruction/Flag Test
 = 0001				POST_TEST_DMA	=	1		; POST DMA Register Test
 = 0001				POST_TEST_DMA_TC0	=	1		; POST DMA Terminal Count Test
 = 0001				POST_TEST_PIT_1	=	1		; POST Timer Channel 1 Test
 = 0001				POST_TEST_PIC_REG	=	1		; POST PIC Register Test
 = 0001				POST_TEST_PIC_INT	=	1		; POST PIC Interrupt Test
 = 0001				POST_TEST_CHK_ROM	=	1		; POST Checksum ROM
 = 0001				POST_TEST_FD	=	1		; POST Floppy Drive Test
 = 0001				POST_TEST_SEEK	=	1		; POST Seek Floppy Drives
 = 0001				POST_TEST_KB	=	1		; POST Keyboard Test (PKI)
 = 0001				POST_TEST_KEY	=	1		; POST Key Test (PKEY)
				
				;----------------------------------------------------------------------------;
				; Advanced Options (may void your warranty)
				;
 = 0280				MAX_RAM_PC		EQU	640		; 640K: base 0000-A000 (for EGA/VGA)
 = 02C0				MAX_RAM_MDA		EQU	704		; 704K: include A000-B000 (for MDA)
 = 02E0				MAX_RAM_CGA		EQU	736		; 736K: include A000-B800 (for CGA)
 = 0280				MAX_RAM 		=	MAX_RAM_PC	; Max detectable low RAM (in KB)
 = 0000				MAX_RAM_AUTO	=	0		; Auto-detect MAX_RAM from video DIP switches
 = 0012				DRAM_REFRESH	=	18		; DRAM refresh divisor 1.193 MHz/18 = 66,287.87 Hz
										; 0=Disable refresh (use only with SRAM!)
 = 0001				RAM_PARITY		=	1		; Enable RAM parity checking
 = 0001				RAM_TEST_LONG	=	1		; Long RAM test on cold boot
 = 0003				RAM_DIGITS		=	3		; Number of zero-padded digits for RAM (3 or 4)
 = 0001				BASIC_ROM		=	1		; BASIC ROM support at 0F600h
 = FE00				OPT_ROM_END		=	0FE00H	; Option ROM scan ending address (must be xx00)
 = 0001				FDC_ENABLE		=	1		; Enable INT 13h floppy support
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-5


 = 0000				FDC_IPL_SW		=	0		; Use IPL switch to enable/disable floppy
 = 0001				FDC_HLT_WAIT	=	1		; Halt CPU during FD access
										;   Some chipsets (TD3300A known affected)
										;   hang during floppy access if this is
										;   enabled
 = 0001				FDC_ADV_SEEK	=	1		; Advanced floppy seeking performance
										;   Store current head position in BDA
										;   to avoid unnecessary seek commands
 = 0000				FDC_ZERO_BDA	=	0		; clear FDC FIFO buffer between ops
										;   Some HD ROMs appropriate this memory
 = 0000				FDC_ERR_SEC_CT	=	0		; On error, 0=always return 0 sectors
										;   1=return partial/successful sector count
 = 0001				KB_HLT_WAIT		=	1		; Halt CPU during KB wait
 = 0000				MBR_CHECK		=	0		; Verify magic number of DOS MBR at boot
										;   note: DOS 1.0 does not use MBR, so
										;   will not boot if this is enabled
 = 0001				POST_HD_CHECK	=	1		; Enable POST HD drive count and size
										;   note: Some older WD controller ROMs
										;   (version 62-000043-0xx known affected)
										;   have bugs where INT 13h function are
										;   unusable during POST. Set to 0 to
										;   work around (disables POST_HD_PARMS)
 = 0000				FD_AUTO_DETECT	=	0		; Auto-detect number of floppy drives
										;   use only for DIP switch-less PCs!
 = 0001				POST_ERR_WAIT	=	1		; Wait for Any Key press to continue if
										;   there is a POST error
 = 0000				INT_19_BOOT_HD	=	0		; Try IPL to floppy then hard drive (80h)
 = 00C0				SW1_FLP		=	MASK FLP	; Default max number of floppy drives
 = 0001				MDA_ATTR		=	1		; Display MDA character attributes
										; 2=all, 1=intensity only, 0=filter all
 = 0001				LIGHT_PEN		=	1		; INT 10h,4 light pen support
 = 0000				EXP_UNIT		=	0		; Init 5161 I/O Expansion Unit
 = 0000				KB_FILTER_SC	=	0		; Filter KB make/break code >= 70h
 = 0000				INIT_AT_KBC		=	0		; Init AT type KB controller
 = 0000				INIT_V40		=	0		; Init V40 config registers
 = 0000				OEM_FONT		=	0		; 1=use OEM style font, 0=clone style
 = 0000				POST_CARD		=	0		; enable POST codes on port 80H
				
				;----------------------------------------------------------------------------;
				; Hardware hacks!
				; These run your system way out of spec. You have been warned.
				;----------------------------------------------------------------------------;
				
				;----------------------------------------------------------------------------;
				; UNSAFE_FLOPPY: Reduce floppy drive head settling time for possibly faster
				; seek access and burst transfer reads. Warning: this may result in drive
				; read errors on some hardware.
				; Specify UNSAFE_FLP_DIV as percentage of head settling time, as configured
				; in DBT.
				;
 = 0000				UNSAFE_FLOPPY	=	0		; Use % of specified disk head settle time
				;UNSAFE_FLP_DIV	EQU	<1/3>		; 33%
 = 3/10				UNSAFE_FLP_DIV	EQU	<3/10>	; 30%
				;UNSAFE_FLP_DIV	EQU	<1/4>		; 25%
				
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-6


				;	IF FDC_ADV_SEEK EQ 1
				;UNSAFE_FLOPPY	=	1		; reduce head settle times with FDC_ADV
				;UNSAFE_FLP_DIV	EQU	<1/2>		; 50%
				;	ENDIF
				
				;----------------------------------------------------------------------------;
				; UNSAFE_REFRESH: Lower the amount of time spent in DMA/DRAM refresh state.
				; Depending on hardware configuration, this may result in significant speed
				; and performance gains of up to 5 to 10%, or it may result in instability
				; and parity errors.
				;
				; This is similar to programs such as "SPEEDER" or "FASTV20", which lowers
				; refresh from 1/18 (65K/s) to 1/64 (18K/s) and 1/655 (1.8K/s) respectively.
				;
				; https://forum.vcfed.org/index.php?threads/fastv20-com.24005/
				; https://www.pcorner.com/list/UTILITY/SPEEDER.ZIP/INFO/
				; https://www.reenigne.org/blog/how-to-get-away-with-disabling-dram-refresh/
				; https://en.wikipedia.org/wiki/Memory_refresh
				;
 = 0000				UNSAFE_REFRESH	=	0		; Use unsafe DRAM refresh timing
				
				;----------------------------------------------------------------------------;
				; END Configurable Build Options
				;----------------------------------------------------------------------------;
				
				
				;----------------------------------------------------------------------------;
				; ARCH/build-specific configuration
				;----------------------------------------------------------------------------;
				; Defaults / BIOS ID Byte
				;
				; https://stanislavs.org/helppc/id_bytes.html
				;
 = 00FE				ARCH_ID		=	0FEH			; 0xFE=XT v1/clone (default)
 = 0000				CASSETTE		=	0			; disable cassette (default)
				
				
				
				;----------------------------------------------------------------------------;
				; Configuration for 5160 boards
				;
				
				
				
				
				
				
				;----------------------------------------------------------------------------;
				; Configuration for Book 8088
				;
				
				;----------------------------------------------------------------------------;
				; Configuration for Compaq XT (incomplete)
				;
				
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-7


				
					
					IF ARCH_SUB_TYPE EQ ARCH_VIRTUALXT
				;----------------------------------------------------------------------------;
				; Configuration for the VirtualXT emulator
				;
 = 0001				TURBO_TYPE		=	TURBO_STD		; standard PPI 61h (1=turbo, 0=normal)
 = 02E0				MAX_RAM 		=	MAX_RAM_CGA		; 736 KB Max detectable low RAM
 = 0001				MAX_RAM_AUTO	=	1				; select max RAM from video switch
 = 0000				CGA_SNOW_REMOVE	=	0				; disable CGA snow removal
 = 0000				RAM_TEST_LONG	=	0				; disable long RAM test
 = 0000				RAM_PARITY		=	0				; disable RAM parity checking
 = 0000				BASIC_ROM		=	0				; BASIC ROM support at disabled
 = 0000				FDC_ENABLE		=	0				; disable INT 13h floppy support
					ENDIF
				
				
				;----------------------------------------------------------------------------;
				; Boot to normal or turbo speed (if supported)
				;
 =-0001				IS_TURBO		=	TURBO_TYPE NE TURBO_NONE	; use for conditionals
				
					IF IS_TURBO
 =				BOOT_SPEED		EQU	BOOT_TURBO
					ENDIF
				
				;----------------------------------------------------------------------------;
				; Reconfigure features as needed
				;----------------------------------------------------------------------------;
				; If Cassette enabled, some of the following features must be disabled due to
				; code space limitations.
				;
 = 0000				CAS_RELOCATE	=	0			; keep CAS code in contiguous block
				
				
				
				
					IF FDC_ENABLE EQ 0
 = 0000				POST_TEST_SEEK	=	0			; remove test seek code if no floppy
					ENDIF
				
				
				;----------------------------------------------------------------------------;
				; Secret Menu
				;
 = 0000				POST_QUIET		=	0			; Quiet POST, show only memory test
				
				;----------------------------------------------------------------------------;
				; Enable 186 instructions if V20
				;
				
				
				;----------------------------------------------------------------------------;
				; POST colors and visuals
				;----------------------------------------------------------------------------;
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-8


				
				;----------------------------------------------------------------------------;
				; PC Text Colors
				; https://stanislavs.org/helppc/colors.html
				;
 = 0000				BLACK			EQU	0
 = 0001				DARKBLUE		EQU	1
 = 0002				DARKGREEN		EQU	2
 = 0003				CYAN			EQU	3
 = 0004				DARKRED		EQU	4
 = 0005				DARKMAGENTA		EQU	5
 = 0006				BROWN			EQU	6
 = 0007				GRAY			EQU	7
 = 0008				DARKGRAY		EQU	8
 = 0009				BLUE			EQU	9
 = 000A				GREEN			EQU	10
 = 000B				LIGHTCYAN		EQU	11
 = 000C				RED			EQU	12
 = 000D				MAGENTA		EQU	13
 = 000E				YELLOW		EQU	14
 = 000F				WHITE			EQU	15
				
				;----------------------------------------------------------------------------;
				; Theme My POST Test!
				; Pick theme from below or roll your own!
				;----------------------------------------------------------------------------;
						ELSE
						ELSE
				
				; Theme #1 - "Old skool BBS" (default)
 =				POST_CLR_TXT	EQU	CYAN
 =				POST_CLR_VAL1	EQU	GREEN
 =				POST_CLR_VAL2	EQU	YELLOW
 =				POST_CLR_COLD	EQU	BLUE
 =				POST_CLR_WARM	EQU	DARKRED
 =				POST_CLR_GB		EQU	GRAY
						ENDIF
						ENDIF
				
				;----------------------------------------------------------------------------;
				; POST screen column layout options
				;
 = ' [ '			POST_L		EQU	<' [ '>		; left separator string
 = ' ]'				POST_R		EQU	<' ]'>		; right separator string
 = 0002				L_POST_L		EQU	2			; length of separator
				
 = 0020				POST_TAB_COL	EQU	32			; horiz tab width for second column
 = 0007				POST_COL_LBL_W	EQU	7			; column label width
 = 0004				POST_COL_PAD	EQU	4			; padding (non colored) space between cols
				
 = 0006				POST_COL_W		EQU	POST_COL_LBL_W-1	; zero-based column index
				
				; column label width plus separator
 = 0009				POST_COL_VT		EQU	POST_COL_LBL_W + L_POST_L
				
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-9


				; space between next column
 = 0013				POST_TAB_COL_I	EQU	POST_TAB_COL - POST_COL_LBL_W - L_POST_L - POST_COL_PAD
				
				; prefer period-correct "KB" or IEC "KiB"
								ELSE
 = 'KB'				POST_K_UNIT		EQU	<'KB'>		; KB size unit abbrev.
 = 'MB'				POST_M_UNIT		EQU	<'MB'>		; MB size
								ENDIF
				
				;----------------------------------------------------------------------------;
				; Useful CP-437/Control Chars
				;
 = 000D				CR 			EQU	0DH 			; Carriage return
 = 000A				LF 			EQU	0AH 			; Line feed
 = 0008				BS			EQU	08H			; Backspace ASCII
 = 0007				BELL			EQU	07H			; BELL ASCII
 = 0016				SYN			EQU	16H			; SYN C0 control char
 = 00B3				VL			EQU	0B3H			; vertical line
 = 00C4				HL			EQU	0C4H			; horizontal line
 = 00F4				CURL_TOP		EQU	0F4H
 = 00F5				CURL_BOT		EQU	0F5H
 = 00F9				BULL			EQU	0F9H			; Bullet operator (medium centered dot)
 = 00FA				DOT			EQU	0FAH			; Small middle dot
 = 00FE				SQUARE		EQU	0FEH			; Black square (rectangle)
 = 0003				HEART			EQU	03H			; faithful companion
 = 000D				NOTE1			EQU	0DH
 = 000E				NOTE2			EQU	0EH
 = 001D				DBLARROW		EQU	01DH
 = 00AB				HALF			EQU	0ABH			; 1/2
 = 00AC				QUARTER		EQU	0ACH			; 1/4
				
				;----------------------------------------------------------------------------;
				; Beepin' Tones
				; PIT delay = 315,000,000 / 264 / freq (Hz)
				;----------------------------------------------------------------------------;
 = 11D1				BEEP_C4		EQU	4561			; Middle C4 (261.626 Hz) (4560.65)
 = 0A98				BEEP_A4		EQU	2712			; A4 (440.000 Hz)   (2711.78)
 = 0970				BEEP_B4		EQU	2416 			; B4 (493.883 Hz)   (2415.92)
 = 08E8				BEEP_C5		EQU	2280			; C5 (523.251 Hz)   (2280.32)
 = 07F0				BEEP_D5		EQU	2032			; D5 (587.329 Hz)   (2031.54)
 = 0712				BEEP_E5		EQU	1810			; E5 (659.255 Hz)   (1809.89)
 = 06AC				BEEP_F5		EQU	1708			; F5 (698.456 Hz)   (1708.31)
 = 05F2				BEEP_G5		EQU	1522			; G5 (783.991 Hz)   (1521.93)
 = 054C				BEEP_A5		EQU	1356			; A5 (880.000 Hz)   (1355.89)
 = 04B8				BEEP_B5		EQU	1208			; B5 (987.766 Hz)   (1207.96)
 = 0474				BEEP_C6		EQU	1140			; C6 (1046.50 Hz)   (1140.16)
 = 04A9				BEEP_1K		EQU	1193			; ~1 KHz tone       (1193.18)
 = 04A0				BEEP_1K7		EQU	1184			; ~1007 Hz (cassette 1 bit)
 = 0250				BEEP_2K		EQU	BEEP_1K7 / 2	; ~2015 Hz (cassette 0 bit)
				
 =				BEEP_DEFAULT	EQU	BEEP_A5		; default beep
 =				BEEP_ERR_HIGH	EQU	BEEP_F5		; perfect fourth apart for
 =				BEEP_ERR_LOW	EQU	BEEP_C5		;  alternating error beeps
				
				;----------------------------------------------------------------------------;
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-10


				; PC ISA (Instruction Set Architecture) I/O Port Addresses
				;----------------------------------------------------------------------------;
				
				; 8237A DMA Controller
 = 0000				DMA_0_A		EQU	00H 			; W   Start Address Register channel 0
 = 0001				DMA_0_C		EQU	01H			; W   Count Register channel 0
 = 0002				DMA_1_A		EQU	02H			; W   Start Address Register channel 1
 = 0003				DMA_1_C		EQU	03H			; W   Count Register channel 1
 = 0004				DMA_2_A		EQU	04H			; W   Start Address Register channel 2
 = 0005				DMA_2_C		EQU	05H			; W   Count Register channel 2
 = 0006				DMA_3_A		EQU	06H			; W   Start Address Register channel 3
 = 0007				DMA_3_C		EQU	07H			; W   Count Register channel 3
 = 0008				DMA_CMD		EQU	08H			; RW  Status / Command Register
 = 0009				DMA_REQ		EQU	09H			; W   Request Register
 = 000A				DMA_MASK		EQU	0AH 			; W   Single Channel Mask Register
 = 000B				DMA_MODE		EQU	0BH 			; W   Mode Register
 = 000C				DMA_FF		EQU	0CH 			; W   Flip-Flop Reset Register
 = 000D				DMA_RESET		EQU	0DH 			; W   Master Reset Register (Mask bits ON)
 = 000E				DMA_MASKR		EQU	0EH 			; W   Mask Reset Register (Mask bits OFF)
 = 000F				DMA_MMASK		EQU	0FH 			; RW  MultiChannel Mask Register
				
				; DMA Page Registers (74LS670)
 = 0087				DMA_P_C0		EQU	87H			; DMA Channel (unused on PC)
 = 0083				DMA_P_C1		EQU	83H			; DMA Channel 0 and 1
 = 0081				DMA_P_C2		EQU	81H			; DMA Channel 2
 = 0082				DMA_P_C3		EQU	82H			; DMA Channel 3
				
				; 8259 PIC Interrupt Controller
 = 0020				INT_P0		EQU	20H 			; Port 0
 = 0021				INT_IMR		EQU	21H 			; Port 1 - OCW1 Interrupt Mask Register
				
				; 8253 PIT Timer
 = 0040				PIT_CH0		EQU	40H			; Timer Channel/Counter 0
 = 0041				PIT_CH1		EQU	41H			; Timer Channel/Counter 1
 = 0042				PIT_CH2		EQU	42H			; Timer Channel/Counter 2 - Speaker
 = 0043				PIT_CTRL		EQU	43H			; Timer Control Word
				
				; 8255 PPI Peripheral Interface
 = 0060				PPI_A			EQU	60H			; PPI (8255) Port A IN  - Keyboard input
 = 0061				PPI_B			EQU	61H			; PPI (8255) Port B OUT - Speaker, Switch se
				lection, Misc
 = 0062				PPI_C			EQU	62H			; PPI (8255) Port C IN  - Switches
 = 0063				PPI_CW		EQU	63H			; PPI (8255) Port Control Word
				
				; 8042 (AT) Keyboard Controller
 = 0060				ATKB_IO		EQU	60H			; 8042 Keyboard input/output buffer register
 = 0064				ATKB_CMD		EQU	64H			; 8042 Keyboard command/status register
				
				; POST TEST card I/O
 = 0080				POST_CARD_PORT	EQU	80H			; can be 60H, 80H, 300H, 313H
				
				; TD3300A (ST-xx/UNIQUE/Auva) Control Registers (90h)
 = 0070				TD_WS			EQU	70H			; RAM, I/O wait state control
 = 0090				TD_TURBO		EQU	90H			; Write 2 for Turbo, 3 for Normal
 = 00E0				TD_MEM		EQU	0E0H			; Memory bank switch
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-11


				
				; UM82C088 Speed / Status registers
 = 00C0				UM82_SPEED		EQU	0C0H			; write any value to toggle speed mode
 = 00E0				UM82_STATUS		EQU	0E0H			; read memory size, speed mode
				
				; VTech Laser Turbo XT
 = 01F0				LASER_TURBO		EQU	1F0H			; CPU speed control port: only bit 7 used
				
				; NMI flip/flop
 = 00A0				NMI_R0		EQU	0A0H			; NMI Mask Register
				
				; Joystick / Game Port
 = 0201				GAME_CTRL		EQU	0201H			; Game Port
				
				; 5161 Expansion Unit Port
 = 0213				EXP_UNIT_CTRL	EQU	0213H			; Extender Card Control Port
				
				; Hard Disk Controller
 = 0320				HDC_READ		EQU	0320H			; Read from/Write to controller
 = 0321				HDC_CTRL		EQU	0321H			; Read: Controller Status, Write: controller
				 reset
 = 0322				HDC_PULSE		EQU	0322H			; Write: generate controller select pulse
 = 0323				HDC_DMA		EQU	0323H			; Write: Pattern to DMA and interrupt mask register
 = 0324				HDC_STAT		EQU	0324H			; disk attention/status
				
				; Video 6845 CRT Controller
 = 03B8				MDA_CTRL		EQU	03B8H			; MDA CRT Control Port 1
 = 03BA				MDA_STAT		EQU	03BAH			; MDA Status Register
 = 03BB				MDA_PEN_RST		EQU	03BBH			; CGA light pen strobe reset
 = 03D4				CGA_IDX		EQU	03D4H			; CGA Mode Select Register
 = 03D5				CGA_DATA		EQU	03D5H			; CGA Mode Data Register
 = 03D8				CGA_CTRL		EQU	03D8H			; CGA Mode Control Register
 = 03D9				CGA_COLOR		EQU	03D9H			; CGA Color Select register
 = 03DA				CGA_STAT		EQU	03DAH			; CGA Status Register (R)
 = 03DB				CGA_PEN_RST		EQU	03DBH			; CGA light pen strobe reset (W)
				
				; Serial (COM) ports
 = 03F8				COM1_DATA		EQU	03F8H 		; 03F8H: TX/RX Buffer, Divisor LSB (RW)
 = 03F9				COM1_IER		EQU	COM1_DATA+1		; 03F9H: Interrupt Enable Register, Divisor 
				MSB (RW)
 = 03FA				COM1_IIR		EQU	COM1_DATA+2		; 03FAH: Interrupt Identification Register (
				R)
 = 03FB				COM1_LCR		EQU	COM1_DATA+3		; 03FBH: Line Control Register (RW)
 = 03FC				COM1_MCR		EQU	COM1_DATA+4		; 03FCH: Modem Control Register (RW)
 = 03FD				COM1_LSR		EQU	COM1_DATA+5		; 03FDH: Line Status Register (R)
 = 03FE				COM1_MSR		EQU	COM1_DATA+6		; 03FEH: Modem Status Register (R)
 = 03FF				COM1_SPR		EQU	COM1_DATA+7		; 03FFH: Scratch Pad Register (RW)
 = 02F8				COM2_DATA		EQU	COM1_DATA-100H	; 02F8H: TX/RX Buffer, Divisor LSB (RW)
 = 02FA				COM2_IIR		EQU	COM2_DATA+2		; 02FAH: Interrupt Identification Register (
				R)
 = 03E8				COM3_DATA		EQU	COM2_DATA+0F0H	; 03E8H: TX/RX Buffer, Divisor LSB (RW)
 = 03EA				COM3_IIR		EQU	COM3_DATA+2		; 03FAH: Interrupt Identification Register (
				R)
 = 02E8				COM4_DATA		EQU	COM3_DATA-100H	; 02E8H: TX/RX Buffer, Divisor LSB (RW)
 = 02EA				COM4_IIR		EQU	COM4_DATA+2		; 02EAH: Interrupt Identification Register (
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-12


				R)
				
				; Parallel (LPT) ports
 = 03BC				LPT_MDA		EQU	03BCH			; LPT1 data port (MDA)
 = 0378				LPT1			EQU	0378H			; LPT1 data port (I/O)
 = 0278				LPT2			EQU	0278H			; LPT2 data port (I/O)
				
				; Default LPT/COM I/O timeouts (# of 64K LOOPs)
 = 0014				LPT_TO		EQU	20			; LPT default timeout
 = 0001				COM_TO		EQU	1			; COM default timeout
				
				; V40 Control Registers
 = FFF6				V40_WCR2		EQU	0FFF6H		; WCU Wait Cycle 2 Register
 = FFF5				V40_WCR1		EQU	0FFF5H		; WCU Wait Cycle 1 Register
				
				;----------------------------------------------------------------------------;
				; FDC (NEC PD765x) Controller 
				;
				
				; Floppy Disk Controller Ports
 = 03F0				FDC_A_STAT		EQU	03F0H			; Diskette controller status A
 = 03F1				FDC_B_STAT		EQU	03F1H			; Diskette controller status B
 = 03F2				FDC_CTRL		EQU	03F2H			; FD controller control port
 = 03F4				FDC_STAT		EQU	03F4H			; FD controller status register
 = 03F5				FDC_DATA		EQU	03F5H			; data register (write 1-9 byte command, see
				 INT 13)
				
				; FDC Commands
 = 0002				FDC_CMD_RTRK	EQU	00000010B		; 02H: Read Track (Diagnostic)
 = 0003				FDC_CMD_SPEC 	EQU	00000011B		; 03H: Specify Step & Head Load
 = 0004				FDC_CMD_STAT 	EQU	00000100B		; 04H: Sense Drive Status
 = 0005				FDC_CMD_WR		EQU	00000101B		; 05H: Write Sector
 = 0006				FDC_CMD_RD		EQU	00000110B		; 06H: Read Sector
 = 0007				FDC_CMD_RECAL	EQU	00000111B		; 07H: Recalibrate
 = 0008				FDC_CMD_SENSE	EQU	00001000B		; 08H: Sense Interrupt Status
 = 0009				FDC_CMD_WDEL	EQU	00001001B		; 09H: Write Deleted Sector
 = 000A				FDC_CMD_RSID	EQU	00001010B		; 0AH: Read Sector ID
 = 000C				FDC_CMD_RDEL	EQU	00001100B		; 0CH: Read Deleted Sector
 = 000D				FDC_CMD_FMT		EQU	00001101B		; 0DH: Format Track
 = 000F				FDC_CMD_SEEK	EQU	00001111B		; 0FH: Seek
				
				; BDA INT 13H Status Flags 
				; https://stanislavs.org/helppc/int_13-1.html
 = 0000				FDC_ST_OK		EQU	00H			; No error
 = 0001				FDC_ST_BADCMD	EQU	01H			; Bad command passed to driver
 = 0002				FDC_ST_ERR_MARK	EQU	02H			; Address mark not found or bad sector
 = 0003				FDC_ST_ERR_WP	EQU	03H			; Write Protect Error
 = 0004				FDC_ST_ERR_SEC	EQU	04H			; Sector not found
 = 0006				FDC_ST_DISK_CHG	EQU	06H			; diskette changed or removed
 = 0008				FDC_ST_DMA_OVR	EQU	08H			; DMA overrun
 = 0009				FDC_ST_DMA_64K	EQU 	09H			; DMA access across 64k boundary
 = 000C				FDC_ST_ERR_MED	EQU	0CH			; Invalid media type
 = 0010				FDC_ST_ERR_CRC	EQU	10H			; ECC/CRC error on disk read
 = 0020				FDC_ST_ERR_FDC	EQU	20H			; Controller error
 = 0040				FDC_ST_ERR_SEEK	EQU	40H			; Seek failure
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-13


 = 0080				FDC_ST_TIMEOUT	EQU	80H 			; Time out, drive not ready
 = 00FF				FDC_ST_SENSE	EQU	0FFH 			; Sense operation failed
				
				; Trivial RAM / data patterns
 = 95A5				RAM_TEST_1		EQU 	1001010110100101B	; Simple RAM test 095A5H
 = 731D				RAM_TEST_2		EQU 	0111001100011101B	; Alternate RAM test 0731DH
 = 731D				RAM_TEST		=	RAM_TEST_2		; pick one
 = AA55				MAGIC_WORD		EQU	0AA55H		; Magic Word used for option ROM, IPL device
				
				; Warm Boot Flag options set in BDA 40:72H
 = 0000				COLD_BOOT		EQU	0			; Cold Boot - All POST tests
 = 1234				WARM_BOOT		EQU	1234H			; Warm Boot - Skip some POST tests
 = 4321				WARM_BOOT_MEM	EQU	4321H			; Warm Boot - Preserve memory
 = 5678				WARM_BOOT_SUS	EQU	5678H			; Warm Boot - System suspend
 = 9ABC				WARM_BOOT_TEST	EQU	9ABCH			; Warm Boot - Manufacturer test
				
				; Video Related
 = 0050				VID_DEF_COLS	EQU	80			; standard video mode columns
 = 0018				VID_DEF_ROWS	EQU	24			; standard video mode rows
 = 0020				VID_SP		EQU	' '			; fill byte for blank video RAM char
				
				
				;============================================================================;
				;
				; 			   * * *   S T R U C T S   * * *
				;
				;============================================================================;
				
				;----------------------------------------------------------------------------;
				; BDA Timer Counters (6CH-70H)
				;----------------------------------------------------------------------------;
				TIMER_C STRUC
 0000  0000			LW		DW	?	; 6CH  Timer Counter Low Word (ticks)
 0002  0000			HW	  	DW	? 	; 6EH  Timer Counter High Word (hours)
 0004  00			OF 		DB	? 	; 70H  Timer Overflow flag
 0005				TIMER_C ENDS
				
				;----------------------------------------------------------------------------;
				; INT 1E Disk Initialization Parameter Table Vector
				;
				; https://stanislavs.org/helppc/dbt.html
				;----------------------------------------------------------------------------;
				DBT	STRUC
 0000  00			SRT		DB	? 	; 00 step-rate time SRT (0CH), head unload time HUT (0FH)
 0001  00			HLT_ND	DB	? 	; 01 head load time HLT (01H), DMA mode ND (0)
 0002  00			FMCT		DB	? 	; 02 timer ticks to wait before disk motor shutoff
 0003  00			FBPS		DB	? 	; 03 bytes per sector (0=128, 1=256, 2=512, 3=1024)
 0004  00			SPT		DB	? 	; 04 sectors per track (last sector number)
 0005  00			SGAP		DB	? 	; 05 inter-block gap length/gap between sectors
 0006  00			LSEC		DB	? 	; 06 data length, if sector length not specified
 0007  00			FGAP		DB	? 	; 07 gap length between sectors for format
 0008  00			FFILL		DB	? 	; 08 fill byte for formatted sectors
 0009  00			HDST		DB	? 	; 09 head settle time in milliseconds
 000A  00			FMST		DB	? 	; 0A motor startup time in eighths of a second
 000B				DBT	ENDS
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-14


				
				;----------------------------------------------------------------------------;
				; FDC Command Status Bytes (FDC_LAST_ST)
				;----------------------------------------------------------------------------;
				FDC_CSB STRUC
 0000  00			SB0		DB	?	; 00 - status register 0
 0001  00			SB1		DB	?	; 01 - status register 1
 0002  00			SB2		DB	?	; 02 - status register 2
 0003  00			CYL		DB	?	; 03 - cylinder number
 0004  00			HEAD		DB	?	; 04 - head number
 0005  00			SEC		DB	?	; 05 - sector number
 0006  00			BPS		DB	?	; 06 - bytes per sector
 0007				FDC_CSB ENDS
				
				;----------------------------------------------------------------------------;
				; INT 1D Video Initialization Parameter Table Vector (CRTC)
				;
				; https://stanislavs.org/helppc/6845.html
				;----------------------------------------------------------------------------;
				CRTC	STRUC
 0000  00			H_TC		DB	?	; 00 - Horiz. total characters
 0001  00			H_CL		DB	?	; 01 - Horiz. displayed characters per line
 0002  00			H_SP		DB	?	; 02 - Horiz. synch position
 0003  00			H_SW		DB	?	; 03 - Horiz. synch width in characters
 0004  00			V_TL		DB	?	; 04 - Vert. total lines
 0005  00			V_SL		DB	?	; 05 - Vert. total adjust (scan lines)
 0006  00			V_DR		DB	?	; 06 - Vert. displayed rows
 0007  00			V_SP		DB	?	; 07 - Vert. synch position (character rows)
 0008  00			IL		DB	?	; 08 - Interlace mode
 0009  00			MSL		DB	?	; 09 - Maximum scan line address
 000A  00			CSL		DB	?	; 0A - Cursor start (scan line)
 000B  00			CEL		DB	?	; 0B - Cursor end (scan line)
 000C  00			SA_H		DB	0	; 0C - Start address (MSB)
 000D  00			SA_L		DB	0	; 0D - Start address (LSB)
 000E  00			CA_H		DB	0	; 0E - Cursor address (MSB) (read/write)
 000F  00			CA_L		DB	0	; 0F - Cursor address (LSB) (read/write)
 0010				CRTC	ENDS
				
				;============================================================================;
				;
				; 			   * * *   R E C O R D S   * * *
				;
				;============================================================================;
				
				;----------------------------------------------------------------------------;
				; Define Nibbles to Byte
				; Convert two nibbles to byte (big endian)
				;----------------------------------------------------------------------------;
				DNB	RECORD	HBN:4, LBN:4
				
				;----------------------------------------------------------------------------;
				; Define Bytes to Word
				; Convert two bytes to word (big endian)
				;----------------------------------------------------------------------------;
				DBW	RECORD	HWB:8, LWB:8
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-15


				
				;----------------------------------------------------------------------------;
				; Convert KiB to Bytes ( K * 1024 )
				;----------------------------------------------------------------------------;
				KB	RECORD	KBK:6, KBS:10
				
				;----------------------------------------------------------------------------;
				; Convert KiB to Words ( K * 1024 / 2 )
				;----------------------------------------------------------------------------;
				KBW	RECORD	KBWK:7, KBWS:9
				
				;----------------------------------------------------------------------------;
				; Convert KiB to Paragraphs ( K * 1024 / 16 )
				;----------------------------------------------------------------------------;
				KBP	RECORD	KBPK:10, KBPS:6
				
				;----------------------------------------------------------------------------;
				; Convert Word to Paragraphs ( K SHL 4 )
				;----------------------------------------------------------------------------;
				KP	RECORD	KPWP:12, KPWPX:4
				
				;----------------------------------------------------------------------------;
				; x86 EFLAGS
				;----------------------------------------------------------------------------;
				EFLAGS86	RECORD FSF:1,FZF:1,FR1:1,FAF:1,FR2:1,FPF:1,FR3:1=1,FCF:1
				
				;----------------------------------------------------------------------------;
				; BDA Equipment Flags (40:10H)
				;----------------------------------------------------------------------------;
				; 00      |			- LPT : # of LPT ports
				;   x     |			- X1  :  unused, PS/2 internal modem
				;    0    |			- GAM : Game port present
				;     000 |			- COM : # of COM ports present
				;        0| 		- DMA : DMA (should always be 0)
				;         |00	 	- FLP : Floppy drives present (+1) (0=1 drive,1=2,etc)
				;         |  00		- VID : Video mode (00=EGA/VGA, 01=CGA 40x25,
				; 				-	10=CGA 80x25, 11=MDA 80x25)
				;         |    11 	- MBRAM: MB RAM (00=64K, 01=128K, 10=192K, 11=256K+)
				;         |      0	- FPU : FPU installed
				;         |       1	- IPL : Floppy drive(s) installed (always 1 on 5160)
				;----------------------------------------------------------------------------;
								ELSE
				EQFLAGS RECORD	LPT:2,X1:1,GAM:1,COM:3,DMA:1,FLP:2,VID:2,MBRAM:2=11b,FPU:1,IPL:1=0
								ENDIF
				
				;----------------------------------------------------------------------------;
				; Video Card (VID) DIP switch settings (bits 4-5)
				;
 = 0000				VID_ROM	EQU	00b		; OFF/OFF:	EGA/VGA/Option ROM
 = 0001				VID_CGA40	EQU	01b		; OFF/ON:	CGA 40 column
 = 0002				VID_CGA80	EQU	10b		; ON/OFF:	CGA 80 column
 = 0003				VID_MDA	EQU	11b		; ON/ON:	MDA
				
				;----------------------------------------------------------------------------;
				; GLaBIOS Equipment Flags (40:12H)
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-16


				;----------------------------------------------------------------------------;
				; 76543210
				; xxxx    |			- TBD		Reserved
				;     x   |			- TURBO	Turbo supported
				;      x  |			- V20		1 if V20, 0 if 8088
				;       xx|			- TBD		Reserved
				; 84218421
				;----------------------------------------------------------------------------;
				GFLAGS RECORD	GTBD1:4,TURBO:1,V20:1,GTBD2:2
				
				;----------------------------------------------------------------------------;
				; POST status flags are stored in BP
				;----------------------------------------------------------------------------;
				; BP:
				; 76543210
				; x 	    |			- WARM  	Warm Boot flag
				;  x 	    |			- PKI   	POST Keyboard Interrupt Received
				;   x     |			- PKEY  	Keyboard key stuck
				;    x    |			- PFDC  	FDC init failure
				;     x   |			- PFSK  	FDC seek test failure
				;      x  |			- PDMA  	DMA error
				;       x |			- PMEM  	Memory Error
				;        x|			- PFXX  	Reserved (do not use)
				;         |xxxxxx		- TBD
				;         |      xx	- GRND	Random number for tagline
				; 84218421
				;----------------------------------------------------------------------------;
				PFLAGS RECORD WARM:1,PKI:1,PKEY:1,PFDC:1,PFSK:1,PDMA:1,PMEM:1,PFXX:1,PTBD:6,GRND:2
				
				;----------------------------------------------------------------------------;
				; BDA Keyboard Flags
				;----------------------------------------------------------------------------;
				; 40:17	Keyboard Flags Byte 1 (Low)
				;----------------------------------------------------------------------------;
				;          84218421
				; 	    |7 	    	- K1IN	insert is active
				; 	    | 6 	    	- K1CL	caps-lock is active
				; 	    |  5	    	- K1NL	num-lock is active
				; 	    |   4    	- K1SL	scroll-lock is active
				; 	    |    3   	- K1AL	ALT key depressed
				; 	    |     2  	- K1CT	CTRL key depressed
				; 	    |      1 	- K1LS	left shift key depressed
				; 	    |       0	- K1RS	right shift key depressed
				;----------------------------------------------------------------------------;
				KBFLAGS1 RECORD	K1IN:1,K1CL:1,K1NL:1,K1SL:1,K1AL:1,K1CT:1,K1LS:1,K1RS:1
				
				;----------------------------------------------------------------------------;
				; 40:18	Keyboard Flags Byte 2 (High)
				;----------------------------------------------------------------------------;
				; 84218421
				; 7 	    |			- K2IN	insert key is depressed
				;  6 	    |			- K2CL	caps-lock key is depressed
				;   5	    |			- K2NL	num-lock key is depressed
				;    4    |			- K2SL	scroll lock key is depressed
				;     3   |			- K2PA	pause (Ctrl-NumLock) is active
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-17


				;      2  |			- K2SY	system key depressed and held
				;       1 |			- K2LA	left ALT key depressed
				;        0|			- K2LC	left CTRL key depressed
				;----------------------------------------------------------------------------;
				KBFLAGS2 RECORD	K2IN:1,K2CL:1,K2NL:1,K2SL:1,K2PA:1,K2SY:1,K2LA:1,K2LC:1
				
				;----------------------------------------------------------------------------;
				; BDA Keyboard Flags - Enhanced
				;----------------------------------------------------------------------------;
				; 40:96	Keyboard mode/type
				;----------------------------------------------------------------------------;
				;          84218421
				; 	    |7 	    	- KERD	read ID in process
				; 	    | 6 	    	- KEFI	last char was first ID char
				; 	    |  5	    	- KENL	force num-lock if Rd ID & KBX
				; 	    |   4    	- KEEN	101/102 enhanced keyboard installed
				; 	    |    3   	- KERA	right ALT key depressed
				; 	    |     2  	- KERC	right CTRL key depressed
				; 	    |      1 	- KEE0	last code was the E0 hidden code
				; 	    |       0	- KEE1	last code was the E1 hidden code
				;----------------------------------------------------------------------------;
				KBFLAGS3 RECORD	KERD:1,KEFI:1,KENL:1,KEEN:1,KERA:1,KERC:1,KEE0:1,KEE1:1
				
				;----------------------------------------------------------------------------;
				; 40:97	Keyboard LED flags
				;----------------------------------------------------------------------------;
				; 84218421
				; 7 	    |			- KLTE	keyboard transmit error flag
				;  6 	    |			- KLMU	mode indicator update
				;   5	    |			- KLRF	re-send received flag
				;    4    |			- KLAK	ACK received
				;     3   |			- KLCI	circus system indicator
				;      2  |			- KLCL	caps-lock indicator
				;       1 |			- KLNL	num-lock indicator
				;        0|			- KLSL	scroll lock indicator
				;----------------------------------------------------------------------------;
				KBFLAGS4 RECORD	KLTE:1,KLMU:1,KLRF:1,KLAK:1,KLCI:1,KLCL:1,KLNL:1,KLSL:1
				
				;----------------------------------------------------------------------------;
				; 40:71	BIOS Keyboard Break (BIOS_BREAK)
				;----------------------------------------------------------------------------;
				; 84218421
				; 7 	    |			- KBRK	1=break active
				;  654321 |			- KBRX	unused
				;----------------------------------------------------------------------------;
				KBBRK	RECORD	KBRK:1,KBRX:7
				
				;----------------------------------------------------------------------------;
				; FDC BDA Status Flags
				;----------------------------------------------------------------------------;
				; 40:3E	FD_CAL_ST	Drive recalibration status flags
				;----------------------------------------------------------------------------;
				; 84218421
				; 7 	    |			- FWIF	1=working interrupt flag
				;  654    |			- FSTBD	unused
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-18


				;     3   |			- FCAL3	1=recalibrate drive 3
				;      2  |			- FCAL2	1=recalibrate drive 2
				;       1 |			- FCAL1	1=recalibrate drive 1
				;        0|			- FCAL0	1=recalibrate drive 0
				;----------------------------------------------------------------------------;
				FDC_SF RECORD	FWIF:1,FSTBD:3,FCAL3:1,FCAL2:1,FCAL1:1,FCAL0:1
				
				;----------------------------------------------------------------------------;
				; 40:3F	FD_MOTOR_ST	Diskette motor status flags
				;----------------------------------------------------------------------------;
				; 84218421
				; 7 	    |			- FWRT	1=write operation
				;  654    |			- FMTBD	unused
				;     3210|			- FMOT	1=drive 3 motor on
				;----------------------------------------------------------------------------;
				FDC_MF RECORD	FWRT:1,FMTBD:3,FMOT:4
				
				;----------------------------------------------------------------------------;
				; 40:3F	FD_MOTOR_ST	Diskette motor status flags - separated drives
				;----------------------------------------------------------------------------;
				; 84218421
				; 7654    |			- FMOTX	unused
				;     3   |			- FMOT3	1=drive 3 on
				;      2  |			- FMOT2	1=drive 2 on
				;       1 |			- FMOT1	1=drive 1 on
				;        0|			- FMOT0	1=drive 0 on
				;----------------------------------------------------------------------------;
				FDC_MFD RECORD	FMOTX:4,FMOT3:1,FMOT2:1,FMOT1:1,FMOT0:1
				
				;----------------------------------------------------------------------------;
				; 40:8F	FD_MODE	Floppy drive mode
				;----------------------------------------------------------------------------;
				; 84218421
				; 7 	    |			- FM1X	unused
				;  6      |			- FM1D	1=drive 1 determined
				;   5     |			- FM1M	1=drive 1 supports multiple data rates
				;    4    |			- FM18	1=drive 1 supports 80-track
				;     3   |			- FM0X	unused
				;      2  |			- FM0D	1=drive 0 determined
				;       1 |			- FM0M	1=drive 0 supports multiple data rates
				;        0|			- FM08	1=drive 0 supports 80-track
				;----------------------------------------------------------------------------;
				FDC_MODE RECORD	FM1X:1,FM1D:1,FM1M:1,FM18:1,FM0X:1,FM0D:1,FM0M:1,FM08:1
				
				;----------------------------------------------------------------------------;
				; 40:90H-93H	Floppy drive media state (drives 0-3)
				;----------------------------------------------------------------------------;
				; 84218421
				; 76      |			- FSR		data xfr rate in Kb/s (0=500,1=300,2=250)
				;   5     |			- FDDS	1=dub step required
				;    4    |			- FSE		1=media established
				;     3   |			- FSX		unused
				;      210|			- FSD		(see below)
				;----------------------------------------------------------------------------;
				; FSD values:
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-19


				;	0 = 360K disk/360K drive not established
				;	1 = 360K disk/1.2M drive not established
				;	2 = 1.2M disk/1.2M drive not established
				;	3 = 360K disk/360K drive established
				;	4 = 360K disk/1.2M drive established
				;	5 = 1.2M disk/1.2M drive established
				;	6 = reserved
				;	7 = none of the above
				;----------------------------------------------------------------------------;
				FDC_STATE RECORD	FSR:2,FDDS:1,FSE:1,FDX:1,FSD:3
				
				;----------------------------------------------------------------------------;
				; FDC Digital Output Register at 3F2h (write only)
				;----------------------------------------------------------------------------;
				; 84218421
				; 7 	    |			- FDMD	1 = turn floppy drive D motor on
				;  6      |			- FDMC	1 = turn floppy drive C motor on
				;   5     |			- FDMB	1 = turn floppy drive B motor on
				;    4    |			- FDMA	1 = turn floppy drive A motor on
				;     3   |			- FDDMA	1 = DMA & I/O interface enabled
				;      2  |			- FDCEN	1 = FDC enable, 0 = hold FDC at reset
				;       10|			- FDDRV	floppy drive select (0=A, 1=B, 2=C, 3=D)
				;----------------------------------------------------------------------------;
				FDC_DOR RECORD	FDMD:1,FDMC:1,FDMB:1,FDMA:1,FDDMA:1,FDCEN:1,FDSEL:2
				
				;----------------------------------------------------------------------------;
				; FDC 765 Status Flags
				;----------------------------------------------------------------------------;
				; FDC Main Status Register at 3F4h (read only)
				; 84218421
				; 7 	    |			- FDRR	data reg ready for I/O to/from CPU
				;  6      |			- FIOD	I/O direction; 1=FDC to CPU; 0=CPU to FDC
				;   5     |			- FDND	FDC is in non-DMA mode
				;    4    |			- FDRW	FDC read or write command in progress
				;     3   |			- F3SK	floppy drive 3 in seek mode/busy
				;      2  |			- F2SK	floppy drive 2 in seek mode/busy
				;       1 |			- F1SK	floppy drive 1 in seek mode/busy
				;        0|			- F0SK	floppy drive 0 in seek mode/busy
				;----------------------------------------------------------------------------;
				FDC_MSR RECORD	FDRR:1,FIOD:1,FDND:1,FDRW:1,F3SK:1,F2SK:1,F1SK:1,F0SK:1
				
				;----------------------------------------------------------------------------;
				; FDC Command Status Register 0 at 3F5h
				;----------------------------------------------------------------------------;
				; 84218421
				; 76	    |			- ST0CS	last command status (see below)
				;   5     |			- ST0SK	set to 1 when FDD completes a seek command
				;    4    |			- ST0CHK	equipment check (see note)
				;     3   |			- ST0NR	not ready on read/write or SS access to head 1
				;      2  |			- ST0HD	head number at interrupt (head 0 or 1)
				;       10|			- ST0DRV	unit selected at interrupt (0=A, 1=B, 2=...)
				;----------------------------------------------------------------------------;
				; Bits
				;	 76  Last Command Status
				;	 00  command terminated successfully
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-20


				;	 01  command execution started but terminated abnormally
				;	 10  invalid command issued
				;	 11  command terminated abnormally due to a change in state of
				;	     the Ready Signal from the FDC  (reserved on PS/2)
				;
				;	- equipment check can occur if FDD signals a fault or track zero is
				;	  not found after 77 steps on a recalibrate command
				;----------------------------------------------------------------------------;
				FDC_ST0 RECORD	ST0CS:2,ST0SK:1,ST0CHK:1,ST0NR:1,ST0HD:1,ST0DRV:2
				
				;----------------------------------------------------------------------------;
				; FDC Command Byte 0
				;----------------------------------------------------------------------------;
				; 84218421
				; 7       |			- FC0MT	MT = Multi-Track
				;  6      |			- FC0MF	MF = MFM mode
				;   5     |			- FC0SK	SK = SKip Deleted-data address mark
				;    43210|			- FC0CMD	FDC command number
				;----------------------------------------------------------------------------;
				FDC_CB RECORD	FC0MT:1,FC0MF:1=1,FC0SK:1,FC0CMD:5
				
				;----------------------------------------------------------------------------;
				; FDC Command Byte 1
				;----------------------------------------------------------------------------;
				; 84218421
				; 76543   |			- FC1X	unused
				;      2  |			- FC1HD	head (0-1)
				;       10|			- FC1DS	drive (0-3)
				;----------------------------------------------------------------------------;
				FDC_CB1 RECORD	FC1X:5,FC1HD:1,FC1DS:2
				
				;----------------------------------------------------------------------------;
				; Port 3BD Printer Status Flags returned from INT 17
				;----------------------------------------------------------------------------;
				; 84218421
				; 7 	    |			- LPBZ	not busy (note: 0 means busy)
				;  6      |			- LPACK	acknowledge (printer is attached)
				;   5     |			- LPOP	20H out of paper
				;    4    |			- LPSEL	10H selected (0 means off-line)
				;     3   |			- LPIO	08H I/O error
				;      21 |			- LPX		06H unused
				;        0|			- LPTO	01H time-out error
				;----------------------------------------------------------------------------;
				PRN_STAT RECORD	LPBZ:1,LPACK:1,LPOP:1,LPSEL:1,LPIO:1,LPX:2,LPTO:1
				
				;----------------------------------------------------------------------------;
				; Port 3BE printer control register   (Parallel Printer Port)
				;----------------------------------------------------------------------------;
				; 84218421
				; 765	    |			- LCX		unused
				;    4    |			- LCIRQ	0 = IRQ disable, 1=IRQ enable for ACK
				;     3   |			- LCDR	1 = printer reads output,  (pin 17)
				;      2  |			- LCINI	0 = initialize printer,  (pin 16)
				;       1 |			- LCLF	1 = auto line feed,  (pin 14)
				;        0|			- LCOUT	1 = output data to printer,  (pin 1)
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-21


				;----------------------------------------------------------------------------;
				PRN_CTRL RECORD	LCX:3,LCIRQ:1,LCDR:1,LCINI:1,LCLF:1,LCOUT:1
				
				;----------------------------------------------------------------------------;
				; Port 3FB - Line Control Register - LCR (read/write)
				;----------------------------------------------------------------------------;
				; 84218421
				; 7	    |			- DLAB	1 = baud rate divisor (DLAB)
				;  6      |			- LCBK	0 = turn break off, 1 = force spacing break state
				;   5     |			- LCPD	0 = parity disabled, 1 = enabled
				;    4    |			- LCEPS	0 = odd parity, 1 = even (EPS)
				;     3   |			- LCPEN	0 = no parity, 1 = parity (PEN)
				;      2  |			- LCSB	0 = 1 stop bit, 1 = 1.5 or 2
				;       10|			- LCWLS	word length select bits
				;----------------------------------------------------------------------------;
				COM_LCR RECORD	DLAB:1,LCBK:1,LCPD:1,LCEPS:1,LCPEN:1,LCSB:1,LCWLS:2
				
				;----------------------------------------------------------------------------;
				; Port 3FC - Modem Control Register - MCR (read/write)
				;----------------------------------------------------------------------------;
				; 84218421
				; 765	    |			- MCRX	unused
				;    4    |			- MCLB	0 = normal, 1 = loop back test
				;     3   |			- MCO2	OUT2
				;      2  |			- MCO1	OUT1
				;       1 |			- RTS		1 = activate RTS
				;        0|			- DTR		1 = activate DTR
				;----------------------------------------------------------------------------;
				COM_MCR RECORD	MCRX:3,MCLB:1,MCO2:1,MCO1:1,RTS:1,DTR:1
				
				;----------------------------------------------------------------------------;
				; Port 3FE - Modem Status Register - MSR (read only)
				;----------------------------------------------------------------------------;
				; 84218421
				; 7	    |			- MLSD	1 = receive line signal detect
				;  6      |			- MRI		1 = ring indicator (RI)
				;   5     |			- MDSR	1 = DSR
				;    4    |			- MCTS	1 = CTS
				;     3   |			- DDCD	1 = DDCD Delta Data Carrier Detect (DCD changed)
				;      2  |			- DRI		1 = RI ring indicator changed
				;       1 |			- DDSR	1 = DDSR Delta DSR (DSR changed)
				;        0|			- DCTS	1 = DCTS Delta CTS (CTS changed)
				;----------------------------------------------------------------------------;
				COM_MSR RECORD	MLSD:1,MRI:1,MDSR:1,MCTS:1,DDCD:1,DRI:1,DDSR:1,DCTS:1
				
				;----------------------------------------------------------------------------;
				; Port 3FD/2FD - Line Status Register - LSR (read only)
				;----------------------------------------------------------------------------;
				; 84218421
				; 7	    |			- LSX		unused
				;  6      |			- TSRE	1 = transmitter shift register empty (TSRE)
				;   5     |			- THRE	1 = transmitter holding register empty (THRE)
				;    4    |			- LBI		1 = break interrupt  (BI)
				;     3   |			- LFE		1 = framing error (FE)
				;      2  |			- LPE		1 = parity error (PE)
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-22


				;       1 |			- LOE		1 = overrun error (OE)
				;        0|			- LDR		1 = data ready
				;----------------------------------------------------------------------------;
				COM_LSR RECORD	LSX:1,TSRE:1,THRE:1,LBI:1,LFE:1,LPE:1,LOE:1,LDR:1
				
				;----------------------------------------------------------------------------;
				; HALT_BEEP Pattern - Short / Long
				;----------------------------------------------------------------------------;
				BEEP_SL RECORD	BEEP_S:4, BEEP_L: 4
				
				;----------------------------------------------------------------------------;
				; PIT Timer CW
				;----------------------------------------------------------------------------;
				; Control Word Counter 1 (port 43H) - System Timer:
				;  01 		- SC: Select Counter 1
				;    11		- RW: Read/Write 2xR/2xW
				;      010		- M:  Mode 2, Rate Gen
				;         0		- BCD: 0
				;----------------------------------------------------------------------------;
				PIT_CW RECORD	PCWSC:2, PCWRW:2, PCWM:3, PCWBCD:1
				
				;----------------------------------------------------------------------------;
				; DMA Mode Register
				;----------------------------------------------------------------------------;
				; 01 			; Mode 1 (Single)
				;   0 		; INC: address decrement
				;    1 		; Auto-initialization
				;     10 		; Operation: Read from memory
				;       00 		; Channel 0
				;----------------------------------------------------------------------------;
				DMA_MR RECORD	DMM:2=01B, DMINC:1, DMAI:1=1, DMOP:2, DMCH:2
				
				;----------------------------------------------------------------------------;
				; 8237 DMA Command Register
				;----------------------------------------------------------------------------;
				; 84218421
				; 7 	    |		- DACK	1 = DACK sense active high, 0 = low
				;  6      |		- DREQ	1 = DREQ sense active high, 0 = low
				;   5     |		- DWS		1 = Extended write selection, 0 = Late write
				;    4    |		- DPRI	1 = Rotating priority, 0 = Fixed priority
				;     3   |		- DTIM	1 = Compressed timing, 0 = Normal timing
				;      2  |		- DDIS	1 = Controller disable, 0 = Controller enable
				;       1 |		- DHLD	1 = Channel 0 address hold enable, 0 = disable
				;        0|		- DM2M	1 = Memory-to-memory enable, 0 = disable
				;----------------------------------------------------------------------------;
				DMA_CR RECORD	DACK:1,DREQ:1,DWS:1,DPRI:1,DTIM:1,DDIS:1,DHLD:1,DM2M:1
				
				;----------------------------------------------------------------------------;
				; 8237 DMA Status Register
				;----------------------------------------------------------------------------;
				; 84218421
				; 7 	    |		- CR3		1 = Channel 3 request
				;  6      |		- CR2		1 = Channel 2 request
				;   5     |		- CR1		1 = Channel 1 request
				;    4    |		- CR0		1 = Channel 0 request
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-23


				;     3   |		- TC3		1 = Channel 3 has reached TC
				;      2  |		- TC2		1 = Channel 2 has reached TC
				;       1 |		- TC1		1 = Channel 1 has reached TC
				;        0|		- TC0		1 = Channel 0 has reached TC
				;----------------------------------------------------------------------------;
				DMA_SR RECORD	CR3:1,CR2:1,CR1:1,CR0:1,TC3:1,TC2:1,TC1:1,TC0:1
				
				;----------------------------------------------------------------------------;
				; 8237 DMA Single Channel Mask Register
				;----------------------------------------------------------------------------;
				; 84218421
				;      2  |		- SMCLR	1 = Set mask bit, 0 = Clear mask bit
				;       10|		- SMCH	Select channel mask bit (0-3)
				;----------------------------------------------------------------------------;
				DMA_SMR RECORD	SMCLR:6,SMCH:2
				
				;----------------------------------------------------------------------------;
				; PIC Control Registers
				;----------------------------------------------------------------------------;
				; ICW1:
				;  000 		- A7-A5: unused on 8086 mode
				;     1 		- D4:   1 = ICW1 (and Port 0)
				;      0 		- LTIM: 0 = Edge Triggered Mode (low to high TTL transition)
				;       0 		- ADI:  0 = Call Address Interval of 8
				;        1 		- SNGL: 1 = Single mode (no cascading PICs or ICW3)
				;         1		- IC4:  1 = ICW4 Needed
				;----------------------------------------------------------------------------;
				ICW1	RECORD	D4:4=1, LTIM:1, ADI:1, SNGL:1=1, IC4:1=1
				
				; ICW2:
				;  00001 		- T7-T3: Interrupt Vector Address:
				;				INT = INT | 8 -> IRQ 0-7 to CPU INT 8-15
				;       000 	- D2-D0: unused on 8086 mode
				;----------------------------------------------------------------------------;
				ICW2	RECORD	ICW2IVA:5, ICW2X:3=0
				
				; ICW4:
				;  000 		- D7-D5: unused
				;     0		- SFNM: 0 = Not Special Fully Nested Mode
				;      10		- BUF:  2 = Buffered Mode/Slave
				;        0		- AEOI: 0 = normal EOI
				;         1		- uPM:  1 = 8086 system
				;----------------------------------------------------------------------------;
				ICW4	RECORD	SFNM:4=0, ICWBUF:2, AEOI:1, uPM:1
				
				;----------------------------------------------------------------------------;
				; IMR / OCW1 Interrupt Mask
				;----------------------------------------------------------------------------;
				; 84218421
				; 7 	    |		- IRQ7	1=interrupt masked (disabled), 0=not masked
				;  6      |		- IRQ6
				;   5     |		- IRQ5
				;    4    |		- IRQ4
				;     3   |		- IRQ3
				;      2  |		- IRQ2
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-24


				;       1 |		- IRQ1
				;        0|		- IRQ0
				;----------------------------------------------------------------------------;
				OCW1	RECORD	IRQ7:1,IRQ6:1,IRQ5:1,IRQ4:1,IRQ3:1,IRQ2:1,IRQ1:1,IRQ0:1
				
				;----------------------------------------------------------------------------;
				; OCW2
				;----------------------------------------------------------------------------;
				; 84218421
				; 765	    |		- O2CMD	Rotate and End of Interrupt Mode Command
				;					001b = Non-Specific EOI Command (default)
				;    43   |		- O2X		unused (00)
				;      210|		- O2L		Interrupt level acted upon
				;----------------------------------------------------------------------------;
				OCW2	RECORD	O2CMD:3=001b, O2X:2, O2L:3
 = 0020				EOI	EQU		OCW2 <>		; Non-Specific EOI
				
				;----------------------------------------------------------------------------;
				; OCW3
				;----------------------------------------------------------------------------;
				; 84218421
				; 7 	    |		- O3D7	unused (0)
				;  65     |		- ESMM/SMM	Enable/special mask mode
				;    43   |		- O3D3	unused (01b)
				;      2  |		- O3P		1=Poll command, 0=No Poll command
				;       10|		- O3RR	Read Register command
				;----------------------------------------------------------------------------;
				OCW3	RECORD	O3D7:1, ESMM:2, O3D3:2=1, O3P:1, O3RR:2
				
				;----------------------------------------------------------------------------;
				; NMI Mask Register
				;----------------------------------------------------------------------------;
				; 84218421
				; x 	    |		- NMIE	1=enable NMI, 0=disable
				;  0000000|		- NMIX	unused (0)
				;----------------------------------------------------------------------------;
				NMI	RECORD	NMIE:1, NMIX:7
				
				;----------------------------------------------------------------------------;
				; V40 WCY1
				;----------------------------------------------------------------------------;
				; 84218421
				; 76 	    |		- IOW		I/O Wait States (0-3)
				;   54    |		- UMW		Upper Memory Block Wait States (0-3)
				;     32  |		- MMW		Middle Memory Block Wait States (0-3)
				;       10|		- LMW		Lower Memory Block Wait States (0-3)
				;----------------------------------------------------------------------------;
				V40_WCY1	RECORD	IOW:2, UMW:2, MMW:2, LMW:2
				
				;----------------------------------------------------------------------------;
				; 6845 Video - Port 3DA Status Register
				;----------------------------------------------------------------------------;
				; 84218421
				; 7654    |			- VSX		unused
				;     3   |			- VSVS	vertical retrace, RAM access OK (next 1.25ms)
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-25


				;      2  |			- VSPE	0 = light pen on, 1 = light pen off
				;       1 |			- VSPT	light pen trigger set
				;        0|			- VSHS	horiz or vert retrace, RAM access OK
				;----------------------------------------------------------------------------;
				VID_STAT	RECORD	VSX:4, VSVS:1, VSPE:1, VSPT:1, VSHS:1
				
				;----------------------------------------------------------------------------;
				; 6845 Video - 3D9 Color Select Register (Text)
				;----------------------------------------------------------------------------;
				; 84218421
				; 765     |			- CTX		unused
				;    4    |			- CTBI	background intensity
				;     3   |			- CTIN	select intensity setting
				;      210|			- CTBC	screen/border RGB
				;----------------------------------------------------------------------------;
				VID_CSTXT	RECORD	CTX:3=001B, CTBI:1=1B, CTIN:1, CTBC:3
				
				;----------------------------------------------------------------------------;
				; 6845 Video - 3D9 Color Select Register (Graphics)
				;----------------------------------------------------------------------------;
				; 84218421
				; 76      |			- CGPH	palette high bits (unused)
				;   5     |			- CGPL	1 = palette 1, 0=palette 0
				;    4    |			- CGX		unused
				;     3   |			- CGIN	intensity
				;      210|			- CGBG	RGB for background
				;----------------------------------------------------------------------------;
				VID_CSGFX	RECORD	CGPH:2,CGPL:1=1B,CGX:1=1B,CGIN:1=1B,CGBG:3=111B
				
				;----------------------------------------------------------------------------;
				; Default video mem attribute byte to fill memory on clear
				;----------------------------------------------------------------------------;
				; 84218421
				; 7654    |			- VBG		background color (0-15) default black
				;     3210|			- VFB		foreground color (0-15) default gray
				;----------------------------------------------------------------------------;
				VID_ATTR	RECORD	VBG:4=BLACK,VFB:4=GRAY
				
				;----------------------------------------------------------------------------;
				; MDA Character Attributes
				;----------------------------------------------------------------------------;
				; 84218421
				; 7       |			- MDBK	1 = blink, 0 = no blink
				;  654    |			- MDBG	000b = normal, 111b = Reverse
				;     3   |			- MDIN	0 = normal, 1 = bold
				;      210|			- MDFG	111 = normal, 001 = underline, 000 = none
				;----------------------------------------------------------------------------;
				MDA_CH_ATTR	RECORD	MDBK:1,MDBG:3,MDIN:1,MDFG:3=111B
				
				;----------------------------------------------------------------------------;
				; 8255 PPI Channel Control Register Byte (Port 63h) Flags
				;----------------------------------------------------------------------------;
				; Normal operation: Mode 0, Ports A,C (U and L) as INPUT, Port B as OUTPUT
				; 84218421
				; 1 	    |			- PPEN	1=Active
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-26


				;  00     |			- PPAM	Port A Mode: (0 default)
				;    1    |			- PPAD	Port A Dir: 0=output, 1=input (default)
				;     1   |			- PPCU	Port C (Upper): 0=output, 1=input (default)
				;      0  | 		- PPBM	Port B Mode: (0 default)
				;       0 | 		- PPBD	Port B Dir: 0=output (default), 1=input
				;        1|			- PPCL	Port C (Lower): 0=output, 1=input (default)
				;----------------------------------------------------------------------------;
				PPI_CR RECORD	PPEN:1=1,PPAM:2=00b,PPAD:1=1,PPCU:1=1,PPBM:1,PPBD:1,PPCL:1=1
				
				
				
				
							ELSE					; NOT ARCH_FE2010
								ELSE
				;----------------------------------------------------------------------------;
				; 5160/Standard: 8255 PPI Channel B (Port 61h) Flags
				;----------------------------------------------------------------------------;
				; 84218421
				; 7 	    |			- PBKB	0=enable keyboard read, 1=clear
				;  6      |			- PBKC	0=hold keyboard clock low, 1=enable clock
				;   5     |			- PBIO	0=enable i/o check, 1=disable
				;    4    |			- PBPC	0=enable memory parity check, 1=disable
				;     3   |			- PBSW	0=read SW1-4, 1=read SW-5-8
				;      2  |			- PBTB	0=turbo, 1=normal
				;       1 |			- PBSP	0=turn off speaker, 1=turn on
				;        0|			- PBST	0=turn off timer 2, 1=turn on
				;----------------------------------------------------------------------------;
				PPI_B_F RECORD	PBKB:1,PBKC:1,PBIO:1,PBPC:1,PBSW:1,PBTB:1,PBSP:1,PBST:1
								ENDIF
							ENDIF
				
				;----------------------------------------------------------------------------;
				; 5160: 8255 PPI Channel C (Port 62h) Flags
				; * When PPI B PBSW = 0
				;----------------------------------------------------------------------------;
				; 84218421
				; 7 	    |			- PCPE	0=no parity error, 1=memory parity error
				;  6      |			- PCIE	0=no i/o channel error, 1=i/o channel error
				;   5     |			- PCT2	timer 2 output / cassette data output
				;    4    |			- PCCI	cassette data input
				;     32  |			- PCMB	SW 3,4: MB RAM (00=64K, 01=128K, 10=192K, 11=256K)
				;       1 |			- PCFP	SW 2: 0=no FPU, 1=FPU installed
				;        0|			- PCFD	SW 1: Floppy drive (IPL) installed
				;----------------------------------------------------------------------------;
				PPI_C_X_L RECORD	PCPE:1,PCIE:1,PCT2:1,PCCI:1,PCMB:2,PCFP:1,PCFD:1
				
				;----------------------------------------------------------------------------;
				; 8255 PPI Channel C Flags (Port 62h)
				; * When PPI B PBSW = 1
				;----------------------------------------------------------------------------;
				; 84218421
				; 7 	    |			- PC2PE	0=no parity error, 1 r/w memory parity check error
				;  6      |			- PC2IE	0=no i/o channel error, 1 i/o channel check error
				;   5     |			- PC2T2	timer 2 output
				;    4    |			- PC2CI	cassette data input
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-27


				;     32  |			- PCDRV	SW 7,8: # of drives (00=1, 01=2, 10=3, 11=4)
				;       10|			- PCVID	SW 5,6: video Mode (00=ROM, 01=CG40, 10=CG80, 11=MDA)
				;----------------------------------------------------------------------------;
				PPI_C_X_H RECORD	PC2PE:1,PC2IE:1,PC2T2:1,PC2CI:1,PCDRV:2,PCVID:2
				
				;----------------------------------------------------------------------------;
				; Set up boot mode (PPI_B_BOOT) for PPI Channel B
				;----------------------------------------------------------------------------;
				
							ELSE				; ARCH_TYPE NE ARCH_5150
								IF BOOT_SPEED EQ BOOT_TURBO
				;----------------------------------------------------------------------------;
				; Turbo Std Power-On: KB hold low+disable, NMI on, spkr data off, turbo ON/OFF
				;
 = 00A8				PPI_B_BOOT	= MASK PBKB OR MASK PBIO OR MASK PBSW
				
								ENDIF			; /BOOT_SPEED EQ BOOT_TURBO
				
				
							ENDIF				; /ARCH_TYPE EQ ARCH_5150
				
				
				;============================================================================;
				;
				;	 			* * *   M A C R O S   * * *
				;
				;============================================================================;
				
				;----------------------------------------------------------------------------;
				; CALL NO STACK - a CALL without a writable stack
				;----------------------------------------------------------------------------;
				; Input:
				;	CALL_JMP = address for CALL
				;	JMP_SHORT = force SHORT jump
				;
				; - SS must be CS
				;----------------------------------------------------------------------------;
				CALL_NS 	MACRO CALL_JMP, JMP_SHORT
						LOCAL	CALL_JMP_PTR, CALL_JMP_RET
					MOV	SP, OFFSET CALL_JMP_PTR
							IFNB <JMP_SHORT>
					JMP	SHORT CALL_JMP
							ELSE
					JMP	CALL_JMP
							ENDIF
				CALL_JMP_PTR:
					DW	OFFSET CALL_JMP_RET
				CALL_JMP_RET:
						ENDM
				
				;----------------------------------------------------------------------------;
				; JMP_FIX - MASM workaround for forward SHORT or NEAR jumps
				;----------------------------------------------------------------------------;
				; Input:
				;	LBL	= forward jump destination
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-28


				;	DEST	= Offset in BIOS segment for destination LBL
				;----------------------------------------------------------------------------;
				JMP_FIX 	MACRO	LBL, DEST
						LOCAL	D
				D	=	OFFSET LBL - BIOS_TOP	; use to determine correct offset for DEST
										; since cannot use this with forward labels
							IF ( ( DEST - 0E000H ) - ( $ - BIOS_TOP ) ) LT 80H
					JMP	SHORT LBL
							ELSE
					JMP	NEAR PTR LBL
							ENDIF
						ENDM
				
				;----------------------------------------------------------------------------;
				; Introduce a short delay of ~15 clock cycles for I/O
				;----------------------------------------------------------------------------;
				; - Code size: 2 bytes
				; - 15 clock cycles
				; - Affects no registers or flags
				; - CPU Instruction cache is purged
				; - No stack required
				;----------------------------------------------------------------------------;
				IO_DELAY_SHORT	MACRO
						LOCAL _DONE
							IF ARCH_TYPE NE ARCH_EMU
					JMP	SHORT _DONE
				_DONE:
							ENDIF
						ENDM
				
				;----------------------------------------------------------------------------;
				; Variable delay ~ CX * 15 clock cycles
				;----------------------------------------------------------------------------;
				; Input: CX delay in 15 clock cycle increments
				; Output: CX = 0
				;----------------------------------------------------------------------------;
				IO_DELAY	MACRO
						LOCAL _DONE
				_DONE:
					LOOP	_DONE					; long delay for I/O
						ENDM
				
				;----------------------------------------------------------------------------;
				; Long delay ~1.18m clock cycles (roughly 1/4 second on 4.77MHz)
				;----------------------------------------------------------------------------;
				; Output: CX = 0
				;----------------------------------------------------------------------------;
				IO_DELAY_LONG	MACRO
							IF ARCH_TYPE NE ARCH_EMU
					XOR	CX, CX 				; delay 65535 LOOPs
					IO_DELAY
							ENDIF
						ENDM
				
				;----------------------------------------------------------------------------;
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-29


				; Variable delay with slowdown for Turbo builds
				;----------------------------------------------------------------------------;
				; Input: CX delay in 30 clock cycle increments
				; Output: CX = 0
				;----------------------------------------------------------------------------;
				IO_DELAY_TURBO	MACRO
						LOCAL _DONE
				_DONE:
						IF IS_TURBO
					IO_DELAY_SHORT
						ENDIF
					LOOP	_DONE					; long delay for I/O
						ENDM
				
				;----------------------------------------------------------------------------;
				; Compare an equipment flag
				;----------------------------------------------------------------------------;
				; Input:
				;	FLAG = field name from EQUIP_FLAGS RECORD
				;	FVAL = value to compare
				;	SET_BDA = if defined, saves CX and sets DS = BDA
				;		otherwise assumes DS = BDA and clobbers CX
				; Output: AX = flag value
				;
				; Note: flags must not cross byte boundary (which they don't)
				;----------------------------------------------------------------------------;
				CMP_EFLAG	MACRO	FLAG, FVAL, SET_BDA
						LOCAL FLAG_MASK, FLAG_BIT, FLAG_MEM
							IFNB <SET_BDA>
					PUSH	CX					; save CX
					PUSH	DS
					MOV	CX, SEG _BDA			; DS = BDA
					MOV	DS, CX
							ENDIF
				
				;----------------------------------------------------------------------------;
				; Shift if flag is in high byte to low for byte operations
				;
							IF FLAG LT 8		; is in low byte?
				FLAG_MASK	= MASK FLAG
				FLAG_BIT	= FLAG AND 0111B
				FLAG_MEM	= EQUIP_FLAGS[0]			; low BDA flags byte
							ELSE				; is in high byte
				FLAG_MASK	= HIGH MASK FLAG
				FLAG_BIT	= (FLAG - 8) AND 0111B
				FLAG_MEM	= EQUIP_FLAGS[1]			; high BDA flags byte
							ENDIF
				
					MOV	AL, BYTE PTR FLAG_MEM
					AND	AL, FLAG_MASK
					CMP	AL, FVAL SHL FLAG_BIT
				
							IFNB <SET_BDA>
					POP	DS
					POP	CX
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-30


							ENDIF
						ENDM
				
				;----------------------------------------------------------------------------;
				; Get an equipment flag
				;----------------------------------------------------------------------------;
				; Input:
				;	FLAG = field name from EQUIP_FLAGS RECORD
				;	SET_BDA = if defined, saves CX and sets DS = BDA
				;		otherwise assumes DS = BDA and clobbers CX if 3 or 4 shifts
				; Output: AX = flag value
				;
				; Note: flags must not cross byte boundary (which they don't)
				;----------------------------------------------------------------------------;
				GET_EFLAG	MACRO	FLAG, SET_BDA
						LOCAL FLAG_MASK, FLAG_BIT, FLAG_MEM
							IFNB <SET_BDA>
					PUSH	CX					; save CX
					PUSH	DS
					MOV	CX, SEG _BDA			; DS = BDA
					MOV	DS, CX
							ENDIF
				
				;----------------------------------------------------------------------------;
				; Shift if flag is in high byte to low for byte operations
				;
							IF FLAG LT 8		; is in low byte?
				FLAG_MASK	= MASK FLAG
				FLAG_BIT	= FLAG AND 0111B
				FLAG_MEM	= EQUIP_FLAGS[0]			; low BDA flags byte
								IF FLAG + WIDTH FLAG GT 8
									.ERR
									%OUT ERROR: BDA EQFLAG crosses byte boundary
								ENDIF
							ELSE				; is in high byte
				FLAG_MASK	= HIGH MASK FLAG
				FLAG_BIT	= (FLAG - 8) AND 0111B
				FLAG_MEM	= EQUIP_FLAGS[1]			; high BDA flags byte
							ENDIF
				
					MOV	AL, BYTE PTR FLAG_MEM		; AL = equipment flag byte
					AND	AX, FLAG_MASK			; isolate bits, clear AH
				
				;----------------------------------------------------------------------------;
				; Determine optimal number of shifts based on bit position and shift
				; right or left depending on fewest.
				;
							IF CPU_TYPE	EQ CPU_V20
								IF FLAG_BIT GT 4
					ROL	AL, 8-FLAG_BIT			; shift value into position
								ELSE
									IF FLAG_BIT EQ 4
					ROL4	_AL					; shift value into position
									ELSE
					ROR	AL, FLAG_BIT			; shift value into position
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-31


									ENDIF
								ENDIF
							ELSE
								IF FLAG_BIT GT 4	; optimal to roll left
									FLAG_BIT = 8-FLAG_BIT
									IF FLAG_BIT GT 2	; 3-4 shifts use CL
					MOV	CL, FLAG_BIT			; CL = bit(s) position of record
					ROL	AL, CL				; shift value into position
									ELSE		; 0-2 shifts use single op(s)
										REPT FLAG_BIT
					ROL	AL, 1					; shift value into position
										ENDM
									ENDIF
								ELSE			; optimal to roll right
									IF FLAG_BIT GT 2
					MOV	CL, FLAG_BIT			; CL = bit(s) position of record
					ROR	AL, CL				; shift value into position
									ELSE
										REPT FLAG_BIT
					ROR	AL, 1					; shift value into position
										ENDM
									ENDIF
								ENDIF
							ENDIF
							IFNB <SET_BDA>
					POP	DS
					POP	CX
							ENDIF
						ENDM
				
				;----------------------------------------------------------------------------;
				; Set an equipment flag
				;----------------------------------------------------------------------------;
				; Input: 
				;	AL = flag value (clobbered)
				;	FLAG = field name from EQUIP_FLAGS RECORD
				;	SET_BDA = if defined, saves CL and set DS = BDA 
				;		otherwise *requires* DS = BDA and CL clobbered
				; Output: none
				;----------------------------------------------------------------------------;
				SET_EFLAG	MACRO	FLAG, SET_BDA
							IFNB	<SET_BDA>
					PUSH	CX
					PUSH	DS
					MOV	CX, SEG _BDA			; DS = BDA
					MOV	DS, CX
							ENDIF
				
							IF FLAG LT 8		; is in low byte?
				FLAG_MASK	= MASK FLAG
				FLAG_BIT	= FLAG AND 111B
				FLAG_MEM	= EQUIP_FLAGS[0]			; low BDA flags byte
							ELSE				; is in high byte
				FLAG_MASK	= HIGH MASK FLAG
				FLAG_BIT	= (FLAG - 8) AND 0111B
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-32


				FLAG_MEM	= EQUIP_FLAGS[1]			; high BDA flags byte
							ENDIF
				
					AND	AL, MASK FLAG SHR FLAG		; isolate flag's bit width
				
				;----------------------------------------------------------------------------;
				; Determine optimal number of shifts based on bit position and shift
				; right or left depending on fewest.
				;
							IF CPU_TYPE	EQ CPU_V20
								IF FLAG_BIT GT 4
					ROR	AL, 8-FLAG_BIT			; shift value into position
								ELSE
					ROL	AL, FLAG_BIT			; shift value into position
								ENDIF
							ELSE
								IF FLAG_BIT GT 4
					MOV	CL, 8-FLAG_BIT			; CL = bit(s) position of record
					ROR	AL, CL				; shift value into position
								ELSE
					MOV	CL, FLAG_BIT			; CL = bit(s) position of record
					ROL	AL, CL				; shift value into position
								ENDIF
							ENDIF
				
					AND	BYTE PTR FLAG_MEM, NOT FLAG_MASK	; clear existing bits(s)
					OR	BYTE PTR FLAG_MEM, AL			; set new bit(s)
				
							IFNB <SET_BDA>
					POP	DS
					POP	CX
							ENDIF
						ENDM
				
				;----------------------------------------------------------------------------;
				; Test a single BDA equipment flag
				;----------------------------------------------------------------------------;
				; Input: FLAG = field name from EQUIP_FLAGS RECORD
				; Output: ZF if 0, NZ if 1
				;
				; Requires: DS = BDA
				;----------------------------------------------------------------------------;
				TEST_EFLAG	MACRO	FLAG
							IF FLAG LT 8
					TEST	BYTE PTR EQUIP_FLAGS, LOW MASK FLAG
							ELSE
					TEST	BYTE PTR EQUIP_FLAGS[1], HIGH MASK FLAG
							ENDIF
						ENDM
				
				;----------------------------------------------------------------------------;
				; Set a single GLaBIOS flag
				;----------------------------------------------------------------------------;
				; Input:
				;	FLAG = field name from GB_FLAGS RECORD
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-33


				;	FLAG_CLR = if set, zeros flags first
				; Requires: DS = BDA
				;----------------------------------------------------------------------------;
				SET_GFLAG	MACRO	FLAG, FLAG_CLR
							IFNB	<FLAG_CLR>
					AND	GB_FLAGS, MASK FLAG		; clear existing flag(s)
							ENDIF
					OR	GB_FLAGS, MASK FLAG		; set flag(s)
						ENDM
				
				;----------------------------------------------------------------------------;
				; Test a single GLaBIOS flag
				;----------------------------------------------------------------------------;
				; Input:
				;	FLAG = field name from GB_FLAGS RECORD
				; Output: ZF if 0, NZ if 1
				;
				; Requires: DS = BDA
				;----------------------------------------------------------------------------;
				TEST_GFLAG	MACRO	FLAG
					TEST	GB_FLAGS, MASK FLAG
						ENDM
				
				;----------------------------------------------------------------------------;
				; Shortcut to write a null-terminated string to console
				;----------------------------------------------------------------------------;
				; Input:
				;	SZ = string to print
				;	SAVE_REGS = define (anything) to preserve SI (cost of 2 bytes)
				;----------------------------------------------------------------------------;
				PRINT_SZ	MACRO	SZ, SAVE_REGS
						IFNB	<SAVE_REGS>
					PUSH	SI					; save SI
						ENDIF
						IFDIFI <SZ>,<SI>			; if SZ is not SI
					MOV	SI, OFFSET SZ
						ENDIF
					CALL	OUT_SZ
						IFNB	<SAVE_REGS>
					POP	SI
						ENDIF
						ENDM
				
				;----------------------------------------------------------------------------;
				; Same as above but print CRLF at the end
				;----------------------------------------------------------------------------;
				; Input:
				;	SZ = string to print
				;	SAVE_REGS = define (anything) to preserve SI (cost of 2 bytes)
				;
				; If called as PRINTLN_SZ SI, will use SI (effectively an alias to 
				;	'CALL OUTLN_SZ')
				;----------------------------------------------------------------------------;
				PRINTLN_SZ	MACRO	SZ, SAVE_REGS
						IFNB	<SAVE_REGS>
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-34


					PUSH	SI					; save SI
						ENDIF
						IFDIFI <SZ>,<SI>			; if SZ is not SI
					MOV	SI, OFFSET SZ
						ENDIF
					CALL	OUTLN_SZ
						IFNB	<SAVE_REGS>
					POP	SI
						ENDIF
						ENDM
				
				;----------------------------------------------------------------------------;
				; Set text attribute for a block of chars starting at current cursor
				;----------------------------------------------------------------------------;
				; This is a more efficient way to set text colors so any normal way to write
				; to console may be used.
				;
				; Example usage:
				;   SET_SZ_ATTR 0EH, 10			; set attribute to 0EH for next 10 chars
				;
				; Code size:
				; 	16 bytes if registers NOT saved
				;	22 bytes if registers saved
				; 	-3 bytes if ATTR is BL
				;----------------------------------------------------------------------------;
				SET_SZ_ATTR	MACRO	ATTR, LN, SAVE_REGS
							IF POST_THEME NE 0	; display color
						IFNB	<SAVE_REGS>
					PUSH	AX
					PUSH	BX
					PUSH	CX
						ENDIF ; IFNB
					MOV	AX, DBW <9, VID_SP>	; AH = write char w/attr, AL = space
						IFDIFI <ATTR>,<BL>	; if ATTR is not BL
					MOV	BX, LOW ATTR		; BH = video page 0, BL = attribute
						ENDIF	; IFDIFI
					MOV	CX, LN			; CX = repeat times
					INT	10H
						IFNB	<SAVE_REGS>
					POP	CX
					POP	BX
					POP	AX
						ENDIF	; IFNB
							ENDIF			; END display color
						ENDM
				
				;----------------------------------------------------------------------------;
				; POST column UI
				;----------------------------------------------------------------------------;
				POST_COL_1	MACRO LBL_STR, INNER_ATTR, SAVE_REGS, ZERO_BH
						IFNB	<SAVE_REGS>
					PUSH	BX					; save BX
						ENDIF
						IFNB	<ZERO_BH>
					MOV	BX, LOW INNER_ATTR		; BH = 0, BL = attribute
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-35


						ELSE
					MOV	BL, LOW INNER_ATTR		; BL = attribute
						ENDIF
					MOV	SI, OFFSET LBL_STR
					CALL	POST_START_COL_1
						IFNB	<SAVE_REGS>
					POP	BX
						ENDIF
				
						ENDM
				
				POST_COL_2	MACRO LBL_STR, INNER_ATTR, SAVE_REGS, ZERO_BH
						IFNB	<SAVE_REGS>
					PUSH	BX					; save BX
						ENDIF
						IFNB	<ZERO_BH>
					MOV	BX, LOW INNER_ATTR		; BH = 0, BL = attribute
						ELSE
					MOV	BL, LOW INNER_ATTR		; BL = attribute
						ENDIF
					MOV	SI, OFFSET LBL_STR
					CALL	POST_START_COL_2
						IFNB	<SAVE_REGS>
					POP	BX
						ENDIF
						ENDM
				
				POST_COL_END	MACRO	SAVE_REGS
						IFNB	<SAVE_REGS>
					PUSH	BX					; save BX
						ENDIF
					CALL	POST_END_COL
						IFNB	<SAVE_REGS>
					POP	BX
						ENDIF
						ENDM
				
				POST_COL_END_NL	MACRO SAVE_REGS
						IFNB	<SAVE_REGS>
					PUSH	BX					; save BX
						ENDIF
					CALL	POST_END_COL_NL
						IFNB	<SAVE_REGS>
					POP	BX
						ENDIF
						ENDM
				
				;----------------------------------------------------------------------------;
				; Beepin' MACROs
				;----------------------------------------------------------------------------;
				; Beep on Man
				;----------------------------------------------------------------------------;
				BEEP_ON MACRO 	TONE
						IFNB	<TONE>
					MOV	AX, TONE 				; custom tone
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-36


						ELSE
					MOV	AX, BEEP_DEFAULT
						ENDIF
					CALL	BEEP_ON_P
						ENDM
				
				;----------------------------------------------------------------------------;
				; Beep off Man
				;----------------------------------------------------------------------------;
				BEEP_OFF MACRO
					CALL	BEEP_OFF_P
						ENDM
				
				;----------------------------------------------------------------------------;
				; Write to POST status card, if enabled
				;----------------------------------------------------------------------------;;
				; Input: AL (default) or imm8
				;
				; Clobbers AL if imm8
				;----------------------------------------------------------------------------;
				POST_CODE	MACRO	CODE
						IF POST_CARD EQ 1
							IFNB	<CODE>		; if CODE is not blank
							IFDIFI <CODE>,<AL>	; if CODE is not AL
					MOV	AL, LOW CODE
							ENDIF
							ENDIF
					OUT	POST_CARD_PORT, AL
						ENDIF
						ENDM
				
				;----------------------------------------------------------------------------;
				; BYTES_HERE - Track and enforce code/byte space around fixed ORGs
				;----------------------------------------------------------------------------;
				; Use to mark a block of free code space. Outputs assembly warning if code 
				; overruns NEXT_LBL, and defines LBL so space can be viewed. Values displayed
				; in generated listing.
				;
				; WTF: why can't MASM %OUT display the value of NEXT_LBL-$?
				; WTF2: how to fix for MASM 6.1?
				;
					.LALL
				BYTES_HERE	MACRO	NEXT_LBL
						LOCAL LBL
				
				BYTES_HERE_&NEXT_LBL = NEXT_LBL-$
				
						IFDEF BYTES_HERE_&NEXT_LBL
						IF2
						IF BYTES_HERE_&NEXT_LBL LT 0
						.ERR2
					%OUT WARNING: Out of space at: NEXT_LBL (&BYTES_HERE_&NEXT_LBL)
						ENDIF
						ENDIF
						ENDIF
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-37


						ENDM
				
				;----------------------------------------------------------------------------;
				; x86/V20 Instruction MACROs
				;----------------------------------------------------------------------------;
				
				;----------------------------------------------------------------------------;
				; AAM, AAD with immediate other than 0AH
				;
				AAM_I		MACRO	IMM
					DB	0D4H, IMM			; AAM	imm
						ENDM
				
				AAD_I		MACRO	IMM
					DB	0D5H, IMM			; AAD	imm
						ENDM
				
				;----------------------------------------------------------------------------;
				; V20 MACROs for instruction mnemonics not supported by MASM
				;----------------------------------------------------------------------------;
				
				;----------------------------------------------------------------------------;
				; V20_R General Purpose Register operands
				;
				V20_R		RECORD	VRW:5, ROPC:3
				
				;----------------------------------------------------------------------------;
				; Format 3 - Single Register OPC, Variant 1
				;
				V20_F3	RECORD	VF3_OPC:5=11000b, VF3_SRC:3
				
				;----------------------------------------------------------------------------;
				; Format 4 - Two Register OPC, Variant 1
				;
				V20_F4	RECORD	VF4_OPC:2=11b, VF4_DST:3, VF4_SRC:3
				
				;----------------------------------------------------------------------------;
				; Registers used as operands for V20 MACROs
				;
 = 0000				_AL	EQU	V20_R	<, 000b>		; reg8
 = 0001				_CL	EQU	V20_R <, 001b>
 = 0002				_DL	EQU	V20_R <, 010b>
 = 0003				_BL	EQU	V20_R <, 011b>
 = 0004				_AH	EQU	V20_R <, _AL OR 100b>
 = 0005				_CH	EQU	V20_R <, _CL OR 100b>
 = 0006				_DH	EQU	V20_R <, _DL OR 100b>
 = 0007				_BH	EQU	V20_R <, _BL OR 100b>
 = 0008				_AX	EQU	V20_R <1, _AL>		; reg16
 = 0009				_CX	EQU	V20_R <1, _CL>
 = 000A				_DX	EQU	V20_R <1, _DL>
 = 000B				_BX	EQU	V20_R <1, _BL>
 = 000C				_SP	EQU	V20_R <1, _AH>
 = 000D				_BP	EQU	V20_R <1, _CH>
 = 000E				_SI	EQU	V20_R <1, _DH>
 = 000F				_DI	EQU	V20_R <1, _BH>
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-38


				
				;----------------------------------------------------------------------------;
				; Format 1 - Opcode with Size (Byte/Word)
				;
				V20_OP1	MACRO OP, R, IMM
						LOCAL W
					W	= (R AND MASK VRW) SHR VRW		; W=1 if 16, 0 if 8
					DB	0FH, OP OR W				; register Width
					V20_F3 <, R AND MASK ROPC >			; dest register
							IFNB <IMM>
					DB	IMM
							ENDIF
						ENDM
				
				TEST1		MACRO R, IMM
					V20_OP1	18H, R, IMM
						ENDM
				
				SET1		MACRO R, IMM
					V20_OP1	1CH, R, IMM
						ENDM
				
				CLR1		MACRO R, IMM
					V20_OP1	1AH, R, IMM
						ENDM
				
				NOT1		MACRO R, IMM
					V20_OP1	1EH, R, IMM
						ENDM
				
				;----------------------------------------------------------------------------;
				; V20 (B)INS (Binary INS) - reg/reg form
				;----------------------------------------------------------------------------;
				BINS		MACRO D, S
					DB	0FH, 31H
					V20_F4 <, S AND MASK ROPC, D AND MASK ROPC >
						ENDM
				
				;----------------------------------------------------------------------------;
				; V20 (B)EXT (Binary EXT) - reg/reg form
				;----------------------------------------------------------------------------;
				BEXT		MACRO D, S
					DB	0FH, 33H
					V20_F4 <, S AND MASK ROPC, D AND MASK ROPC >
						ENDM
				
				;----------------------------------------------------------------------------;
				; ROL4: roll nibbles left in AL through R8
				;----------------------------------------------------------------------------;
				; R8(low nibble)  = AL(low nibble)
				; R8(high nibble) = R8(low nibble)
				; AL(low nibble)  = R8(high nibble)
				; AL(high nibble) clobbered
				;----------------------------------------------------------------------------;
				ROL4		MACRO R8
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-39


					V20_OP1	28H, R8					; ROL4
						ENDM
				
				;----------------------------------------------------------------------------;
				; ROR4: roll nibbles right in AL through R8
				;----------------------------------------------------------------------------;
				; R8(high nibble) = AL(low nibble)
				; R8(low nibble)  = R8(high nibble)
				; AL(low nibble)  = R8(low nibble)
				; AL(high nibble) clobbered
				;----------------------------------------------------------------------------;
				ROR4		MACRO R8
					V20_OP1	2AH, R8					; ROR4
						ENDM
				
				;----------------------------------------------------------------------------;
				; Operations on POST test FLAGs
				;----------------------------------------------------------------------------;
				POST_FLAG_TEST MACRO	FLAG
							IF CPU_TYPE	EQ CPU_V20 AND (WIDTH FLAG) EQ 1
					TEST1	_BP, FLAG				; V20: is FLAG set?
							ELSE
					TEST	BP, MASK FLAG			; Is FLAG set?
							ENDIF
						ENDM
				
				POST_FLAG_SET MACRO	FLAG
							IF CPU_TYPE	EQ CPU_V20 AND (WIDTH FLAG) EQ 1
					SET1	_BP, FLAG				; V20: Set FLAG
							ELSE
					OR	BP, MASK FLAG			; Set FLAG
							ENDIF
						ENDM
				
				POST_FLAG_FLIP MACRO	FLAG
							IF CPU_TYPE	EQ CPU_V20 AND (WIDTH FLAG) EQ 1
					NOT1	_BP, FLAG				; V20: Invert FLAG
							ELSE
					XOR	BP, MASK FLAG			; Invert flag
							ENDIF
						ENDM
				
				;----------------------------------------------------------------------------;
				; If ZF is needed, set NEED_ZF to use 808x 'AND' instruction instead
				;----------------------------------------------------------------------------;
				POST_FLAG_CLR MACRO	FLAG, NEED_ZF
								LOCAL USE_V20
							IFNB <NEED_ZF>
				USE_V20	EQU	0				; use AND instruction instead
							ELSE
				USE_V20	EQU	1				; use CLR1 (ZF unaffected)
							ENDIF
							IF CPU_TYPE	EQ CPU_V20 AND (WIDTH FLAG) EQ 1 AND USE_V20
					CLR1		_BP, FLAG			; V20: Clear FLAG
							ELSE
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-40


					AND	BP, NOT MASK FLAG			; Clear flag
							ENDIF
						ENDM
				
				;----------------------------------------------------------------------------;
				; Jump if Warm Boot
				;----------------------------------------------------------------------------;
				JWB		MACRO	LBL
							IF WARM_ENABLE EQ 1
					TEST	BP, BP				; is warm boot?
					JS	LBL					; jump if so
							ENDIF
						ENDM
				
				;----------------------------------------------------------------------------;
				; Jump if not Warm Boot
				;----------------------------------------------------------------------------;
				JNWB		MACRO	LBL
					TEST	BP, BP				; is warm boot?
					JNS	LBL					; jump if not
						ENDM
				
				;----------------------------------------------------------------------------;
				; Wait for a video retrace to enable RAM access for CGA 80 column
				;----------------------------------------------------------------------------;
				; Input:
				;	DX = 03DAH (CGA Status Port)
				;
				; Output:
				;	Display is in retrace
				;	CLI: Interrupts OFF - must be re-enabled after read/write operation
				;
				; https://forum.vcfed.org/index.php?threads/cant-get-rid-of-cga-snow.39319/post-478150
				;
				; Due to timing requirements this must be unrolled - CALL/PROC too slow
				;----------------------------------------------------------------------------;
				CGA_WAIT_SYNC	MACRO
						LOCAL	WAIT_NO_HSYNC, WAIT_BLANK, IN_VSYNC
							IF CGA_SNOW_REMOVE EQ 1
					CLI						; [2] disable interrupts
							ENDIF
				WAIT_NO_HSYNC:
							IF CGA_SNOW_REMOVE GT 1
					STI						; [2] enable interrupts
					NOP						; [3] handle pending interrupts
					CLI						; [2] disable interrupts
							ENDIF
					IN	AL, DX				; [12] read CGA status register
							IF CGA_SNOW_REMOVE GT 1
					TEST	AL, MASK VSVS			; [5] in vertical?
					JNZ	IN_VSYNC				; [4/16] if so, do CGA I/O
							ENDIF
					SHR	AL, 1					; [2] in horizontal?
					JC	WAIT_NO_HSYNC			; [4/16] if so, wait for next one
				WAIT_BLANK:
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-41


					IN	AL, DX				; [12] read CGA status register
							IF CGA_SNOW_REMOVE GT 1
					TEST	AL, MASK VSVS OR MASK VSHS	; [5] in either sync?
					JZ	WAIT_BLANK				; [4/16]
							ELSE
					SHR	AL, 1					; [2] in horizontal sync?
					JNC	WAIT_BLANK				; [4/16]
							ENDIF
				IN_VSYNC:
						ENDM
				
				;----------------------------------------------------------------------------;
				; IRET with all current flags
				;----------------------------------------------------------------------------;
				IRET_F	MACRO
					RETF	2
						ENDM
				
				;----------------------------------------------------------------------------;
				; PUSH multiple (X number of) registers (up to 8)
				;----------------------------------------------------------------------------;
				PUSHX	MACRO r1, r2, r3, r4, r5, r6, r7, r8
							IFNB <r1>			; exit if last reg
					PUSH	r1 					; push register and repeat
					PUSHX	r2, r3, r4, r5, r6, r7, r8
							ENDIF
						ENDM
				
				;----------------------------------------------------------------------------;
				; POP multiple registers (up to 8)
				;----------------------------------------------------------------------------;
				POPX	MACRO r1, r2, r3, r4, r5, r6, r7, r8
							IFNB <r1>			; exit if last reg
					POP	r1 					; pop register and repeat
					POPX	r2, r3, r4, r5, r6, r7, r8
							ENDIF
						ENDM
				
				;============================================================================;
				;
				;	   		   * * *   S E G M E N T S   * * * 
				;
				;============================================================================;
				
				;----------------------------------------------------------------------------;
				; 0000:0000 - 8086 INT vector table
				;----------------------------------------------------------------------------;
 0000				_IVT		SEGMENT AT 0H
 0020						ORG 8H*4
 0020  0000			IVT_08 		DW	?			; INT 08H - Timer
 0022  0000			IVT_08_SEG		DW	?			; INT 08H - Timer Segment
 0024  0000			IVT_09 		DW	?			; INT 09H - Keyboard
 0026  0000			IVT_09_SEG		DW	?			; INT 09H - Keyboard Segment
 0040						ORG 10H*4
 0040  0000			IVT_10		DW	?			; INT 10H - BIOS video services
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-42


 0042  0000			IVT_10_SEG		DW	?			; INT 10H - Segment
 0060						ORG 18H*4
 0060  0000			IVT_18		DW	?			; INT 18H - ROM BASIC
 0062  0000			IVT_18_SEG		DW	?			; INT 18H - Segment
 0074						ORG 1DH*4
 0074  00000000			IVT_1D		DD	?			; INT 1DH - CRTC param table
 0078  00000000			IVT_1E		DD	?			; INT 1EH - Floppy param table
 007C  00000000			IVT_1F		DD	?			; INT 1FH - User Font bitmap table
 0080				_IVT 		ENDS
				
				;----------------------------------------------------------------------------;
				; 0000:0400 - BIOS data area (BDA) - Zero Page Segment Addressing
				;----------------------------------------------------------------------------;
 = 0400				_BDA_SEG	=	KP < 40H >			; BDA Seg 40H
 0000				_BDA_ABS	SEGMENT AT 0H
 041A						ORG	1AH + _BDA_SEG
 041A  0000			KB_BUF_HD_ABS	DW	?			; 40:1AH Keyboard buffer head ptr
 043E						ORG	3EH + _BDA_SEG
 043E  00			FD_CAL_ST_ABS	FDC_SF <>			; 40:3EH Floppy drive recalibration
 0440						ORG	40H + _BDA_SEG
 0440  00			FD_MOTOR_CT_ABS	DB	?			; 40:40H FD motor shutoff counter
 046B						ORG	6BH + _BDA_SEG
 046B  00			INT_LAST_ABS	DB	?			; 40:6BH POST / Interrupt happened?
 0472						ORG	72H + _BDA_SEG
 0472  0000			WARM_FLAG_ABS	DW	?			; 40:72H Warm Boot Flag
 0480						ORG	80H + _BDA_SEG
 0480  0000			KB_BUF_ST_ABS	DW	?			; 40:80H Keyboard buffer start ptr
 0482				_BDA_ABS	ENDS
				
				;----------------------------------------------------------------------------;
				; 0030:0000 - Bootstrap temporary stack
				;----------------------------------------------------------------------------;
 0000				_BOOT_STACK	SEGMENT AT 30H
 0000  0080[						DW 	80H DUP(?)		; temporary stack
	   ????			
			 ]	
				
 0100				STACK_TOP		LABEL WORD			; top of stack
 0100				_BOOT_STACK	ENDS
				
				;----------------------------------------------------------------------------;
				; 0040:0000 - BIOS data area (BDA)
				;----------------------------------------------------------------------------;
				; https://stanislavs.org/helppc/bios_data_area.html
				; http://www.bioscentral.com/misc/bda.htm
				;----------------------------------------------------------------------------;
 0000				_BDA		SEGMENT AT 40H
 0000  0004[			COM_ADDR		DW	4 DUP(?) 		; 00H  COM1-4 base addresses
	   ????			
			 ]	
				
 = 0008				LPT_ADDR_B		EQU	$-_BDA		;	 Low byte hack to force short sign-extend en
				coding
 0008  0003[			LPT_ADDR		DW	3 DUP(?) 		; 08H  LPT1-3 base addresses
	   ????			
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-43


			 ]	
				
 000E  0000						DW	? 			; 0EH  Extended BIOS data area segment
 0010  000C			EQUIP_FLAGS		EQFLAGS <> 			; 10H  Equipment Flags
 0012  00			GB_FLAGS		GFLAGS <> 			; 12H  Custom Equipment Flags
 0013  0000			MEM_SZ_KB		DW	?			; 13H  Memory size in kilobytes
 0015  0000			MEM_SZ_PC		DW	?			; 15H  Memory size SW2 on 5150
 0017				KB_FLAGS		LABEL WORD
 0017  00			KB_FLAGS1		KBFLAGS1 <>			; 17H  Keyboard flags 1
 0018  00			KB_FLAGS2		KBFLAGS2 <>			; 18H  Keyboard flags 2
 0019  00			KB_ALT 		DB	?			; 19H  Alt-keypad entry byte
 001A  0000			KB_BUF_HD		DW	?			; 1AH  Keyboard buffer head ptr
 001C  0000			KB_BUF_TL		DW	?			; 1CH  Keyboard buffer tail ptr
 001E  0010[			KB_BUF		DW	16 DUP(?) 		; 1EH  Keyboard buffer
	   ????			
			 ]	
				
 003E				KB_BUF_END		LABEL WORD			; 3EH  End of keyboard buffer (not inclusive
				)
 = 003E				KB_BUF_END_B	EQU	3EH			;	 Low byte to force short sign-extend encodin
				g
 003E  00			FD_CAL_ST		FDC_SF <>			; 3EH  Floppy drive recalibration status
											;	0 = drive not calibrated
											;	high bit = working interrupt flag
 003F  00			FD_MOTOR_ST		FDC_MF <>			; 3FH  FD motor status
											;	high bit = write operation
 0040  00			FD_MOTOR_CT		DB	?			; 40H  FD motor shutoff counter (decr. by IN
				T 8)
 0041  00			FD_LAST_OP		DB	?			; 41H  BIOS Status of last FD operation
 0042  00			FDC_LAST_ST		FDC_CSB <>			; 42H  FDC command status last result (7 byt
				es)
 0043  00			
 0044  00			
 0045  00			
 0046  00			
 0047  00			
 0048  00			
				
 0049  00			VID_MODE		DB	?			; 49H  Current video mode
 004A  0000			VID_COLS		DW	?			; 4AH  Number of screen columns
 004C  0000			VID_BUF_SZ		DW	?			; 4CH  Size of video regen buffer in bytes
 004E  0000			VID_SEG		DW	? 			; 4EH  Starting address in video regen buffer (offse
				t) 
 0050  0008[			VID_CURS_POS	DW	8 DUP(?)		; 50H-5FH Cursor position of pages 1-8, high=row, lo
				w=col
	   ????			
			 ]	
				
 0060  0000			VID_CURS_TYPE	DW	? 			; 60H  Starting (Top), Ending (bottom) scan line for
				 cursor
 0062  00			VID_PAGE		DB	? 			; 62H  Active display page number
 0063  0000			VID_PORT		DW	?			; 63H  Base port address for active 6845 CRT
				 controller
 0065  00			VID_MODE_REG	DB	?			; 65H  6845 CRT mode control register value (port 3x
				8H)
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-44


 0066  00			VID_COLOR		DB	? 			; 66H  CGA current color palette setting (po
				rt 3D9H)
 = 001E				L_VID_BDA		EQU	$-VID_MODE		;      Length in bytes of video data in BDA
 0067				CAS_TIME_CNT	LABEL WORD			; 67H  5150 Cassette: Counter
 0067  0000			ROM_INIT_SS		DW	?			; 67H   or Temp location for SS:SP during bl
				ock move
 0069				CAS_CRC		LABEL	WORD			; 69H  5150 Cassette: CRC
 0069  0000			ROM_INIT_SP 	DW	? 			; 69H	  or Option ROM init
 006B				CAS_PREV		LABEL	BYTE			; 6BH  5150 Cassette: Previous byte
				;FE2010_CONF_REG	LABEL BYTE			; 6BH  FE2010A Config Reg (Standard 63H)
 006B  00			INT_LAST		DB	? 			; 6BH  Reserved for POST / Interrupt happene
				d?
 006C  0000			TIMER			TIMER_C <>			; 6CH-70H Timer Counter
 006E  0000			
 0070  00			
				
 0071  00			BIOS_BREAK		DB	?			; 71H  BIOS break flag (high bit means ctrl-
				break)
 0072  0000			WARM_FLAG		DW	?			; 72H  Warm Boot Flag (1234H to bypass RAM t
				est)
 0074  00			HD_LAST_ST		DB 	? 			; 74H  Status of last hard disk operation (s
				ee INT 13,1)
 0075  00			HD_COUNT		DB 	? 			; 75H  Number of hard disks attached
 0076  00			HD_CTRL		DB 	? 			; 76H  XT fixed disk drive control byte
 0077  00			HD_PORT		DB 	? 			; 77H  Port offset to current fixed disk adapter
 = 0078				LPT_TIME_B		EQU	$-_BDA		;	 Low byte hack to force short sign-extend en
				coding
 0078  0004[			LPT_TIME		DB	4 DUP(?) 		; 78H  Time-out value for LPT1-4 (in # of 64
				K LOOPs)
	   ??			
			 ]	
				
 = 007C				COM_TIME_B		EQU	$-_BDA		;	 Low byte hack to force short sign-extend en
				coding
 007C  0004[			COM_TIME		DB	4 DUP(?) 		; 7CH  Time-out value for COM1-4
	   ??			
			 ]	
				
 0080  0000			KB_BUF_ST		DW	?			; 80H  Keyboard buffer start
 0082  0000						DW	?			; 82H  Keyboard buffer end
 008B						ORG	08BH
 008B  00			FD_LR			DB	?			; 8BH  Last diskette data rate selected
 008F						ORG	08FH
 008F  00			FD_MODE		FDC_MODE <>			; 8FH  FDC Drive Mode (see FDC_MODE)
 0090  0004[			FD_MEDIA_ST		FDC_STATE 4 DUP(<>)	; 90H-93H  Drive 0-3 media state
	   00			
			 ]	
				
 0094  0002[			FD_TRACK		DB	2 DUP(?)		; 94H-95H  Drive 0-1 current track
	   ??			
			 ]	
				
 0096  00			EKB_FLAGS1		KBFLAGS3 <>			; 96H  Keyboard mode/type (Enhanced)
 0097  00			EKB_FLAGS2		KBFLAGS4 <>			; 97H  Keyboard LED flags (Enhanced)
 00A0						ORG	0A0H
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-45


 00A0  00			RTC_WAIT		DB	?			; A0H  RTC wait function flag
 00AC						ORG	0ACH				; ACH-B3H "Reserved" (can be used?)
 00B0						ORG	0B0H				; B0H-B1H (used by Tandy for keyboard)
 00E8						ORG	0E8H				; E8H-EFH "Reserved" (can be used?)
 00E8				VID_MEM_SEG_DW	LABEL DWORD			; E8H-EAH Video mem segment using LDS/LES
 00E8  0000			CURSOR_DEFAULT	DW	?			; E8H  Power on cursor bottom:top scan line (for Tur
				bo)
 00EA  0000			VID_MEM_SEG		DW	?			; EAH	 Video mem segment (MDA = B000, CGA 
				= B800)
 00EC  00			FE2010_CONF_REG	DB	?			; ECH  FE2010A Config Reg (63H) (alternate)
 00ED  00						DB	?			; EDH
 00EE  0000			RTC_DATA		DW	?			; EEH  GLaTICK address and RTC type
 00F0				_BDA		ENDS
				
				;----------------------------------------------------------------------------;
				; 0050:0000 - BIOS/DOS Data Area
				;----------------------------------------------------------------------------;
 0000				_DOS_DAT	SEGMENT AT 50H
 0000  00			PTRSCN_ST		DB 	?			; 00H  Print screen status
 0001  0003[						DB	3  DUP(?)		; 01H  Used by BASIC
	   ??			
			 ]	
				
 0004  00						DB	?			; 04H  Floppy drive flag for single
											;	  drive systems (0=A,1=B)
 0005  000A[						DB	10 DUP(?)		; 05H  POST work area
	   ??			
			 ]	
				
 000F  0013[						DB	19 DUP(?)		
	   ??			
			 ]	
				
 0022  000E[			DOS_FD_PARAM	DB	14 DUP(?)		; 22H  Floppy drive parameter table
	   ??			
			 ]	
				
 0030  0004[						DB	4  DUP(?)		; 30H  Mode command
	   ??			
			 ]	
				
 0034				_DOS_DAT	ENDS
				
				;----------------------------------------------------------------------------;
				; 0000:7C00 - IPL / MBR / Boot Block Segment
				;----------------------------------------------------------------------------;
 0000				_IPL_SEG	SEGMENT AT 0H
 7C00						ORG	07C00H
 7C00  01FE[			IPL_TOP		DB	510 DUP(?)		; MBR code then MBR magic number
	   ??			
			 ]	
				
 7DFE  0000			IPL_ID		DW	?			; 0AA55H if valid MBR
 7E00				_IPL_SEG	ENDS
				
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-46


				;----------------------------------------------------------------------------;
				; B000:0000 - MDA Video Memory
				;----------------------------------------------------------------------------;
 0000				_MDA_MEM	SEGMENT AT 0B000H
 0000  1000[			MDA_MEM		DB	1000H DUP(?)	; 4KiB (1000H) total MDA memory
	   ??			
			 ]	
				
 1000				_MDA_MEM	ENDS
				
				;----------------------------------------------------------------------------;
				; B800:0000 - CGA Video Memory
				;----------------------------------------------------------------------------;
 0000				_CGA_MEM	SEGMENT AT 0B800H
 0000  0800[			CGA_MEM_40		DB	0800H DUP(?)	; page 1 of CGA 40 column (2K)
	   ??			
			 ]	
				
 0800  3800[			CGA_MEM_80		DB	3800H DUP(?)	; pages 1-4 of CGA 80 column (14K)
	   ??			
			 ]	
				
 = 4000				CGA_MEM_SZ		= SIZE CGA_MEM_40 + SIZE CGA_MEM_80	; 16 KiB (4000H) total CGA memory
 = 2000				CGA_MEM_FLD 	= CGA_MEM_SZ / 2		;  8 KiB (2000H) CGA memory field
 4000				_CGA_MEM	ENDS
				
				;----------------------------------------------------------------------------;
				; C000:0000 - Video Option ROM segment
				;----------------------------------------------------------------------------;
 0000				_VID_BIOS	SEGMENT AT 0C000H
 0000  0000			VID_MN		DW	?			; magic number (0AA55H)
 0002  00			VID_BIOS_SZ		DB	?			; length in 512 byte blocks
 0003  0000			VID_VEC		DW	?			; FAR call to ROM init routine
 0005				_VID_BIOS	ENDS
				
				;----------------------------------------------------------------------------;
				; C800:0000 - Start of Storage/Other Option ROM segment
				;----------------------------------------------------------------------------;
 0000				_OPT_ROM	SEGMENT AT 0C800H
 0000				_OPT_ROM	ENDS
				
				;----------------------------------------------------------------------------;
				; F000:E000 - System BIOS ROM segment map
				;----------------------------------------------------------------------------;
 0000				_BIOS		SEGMENT AT 0F000H
 E000						ORG	0E000H
 E000				_BIOS_TOP	LABEL WORD
 E05B						ORG	0E05BH
 E05B				_BOOT		LABEL WORD				; BIOS boot offset
 FFF0						ORG	0FFF0H
 FFF0				_POWER_ON	LABEL WORD				; CPU power-on jump address
 FFF0				_BIOS		ENDS
				
				;----------------------------------------------------------------------------;
				; F600:0000 - ROM BASIC segment
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-47


				;----------------------------------------------------------------------------;
 0000				_BASIC	SEGMENT AT 0F600H
 0000				BASIC_TOP	LABEL WORD 				; ROM BASIC load offset
 0000				_BASIC	ENDS
				
				;----------------------------------------------------------------------------;
				; FFFF:0000: 8086 power-on reset vector
				;----------------------------------------------------------------------------;
				; The x86 CPU begins code excution at hard-coded address FFFF:0000.
				; This is that address. Welcome to the party!
				;----------------------------------------------------------------------------;
 0000				RESET    	SEGMENT AT 0FFFFH
 0000				__POWER_ON	LABEL	FAR				; FFFF:0000
 0000				RESET		ENDS
				
				;============================================================================;
				;
				;				* * *   C O D E   * * * 
				;
				;============================================================================;
				
				;----------------------------------------------------------------------------;
				; Main BIOS ROM begins
				;----------------------------------------------------------------------------;
				; Note: Memory space from F000:0000 - F000:E05A is available, though a
				; BIOS identifier string is typically at or near the top of this segment
				;----------------------------------------------------------------------------;
						ASSUME	DS:BIOS, SS:BIOS, CS:BIOS, ES:BIOS
 0000				BIOS    	SEGMENT
				
				;----------------------------------------------------------------------------;
				; F000:FFF0: 8086 power-on reset vector
				;----------------------------------------------------------------------------;
				; The x86 CPU begins code excution at hard-coded address FFFF:0000.
				; This is that address. Welcome to the party!
				;----------------------------------------------------------------------------;
 FFF0						ORG	0FFF0H
 FFF0				POWER_ON	PROC	FAR
 FFF0  EA E05B ---- R			JMP	FAR	PTR _BOOT 		; always jump to power on routine
				
 FFF5						ORG	0FFF5H
 FFF5  30 39 2F 32 38 2F	REL_DATE 	DB	VER_DATE		; Release date
       32 34			
				
 FFFE						ORG	0FFFEH
 FFFE  FE			ISA_TYPE	DB	ARCH_ID		; Architecture model
				
 FFFF						ORG	0FFFFH		; BIOS ROM checksum byte 
 FFFF  00					DB	?			; (computed at build time)
 00010000			POWER_ON	ENDP
				
				;----------------------------------------------------------------------------;
				; F000:E000: Top of BIOS ROM 8K segment
				;----------------------------------------------------------------------------;
 E000						ORG	0E000H
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-48


 E000				BIOS_TOP	PROC	NEAR
				
 E000  0A			TOP_BANNER	DB	LF
 E001  47 4C 61 42 49 4F			DB	VER_NAME, ' [', HEART, '] '
       53 20 5B 03 5D 20	
								IF RANDOM_TAGLINE EQ 1
 E00D  00					DB	0				; null terminate BANNER string
								ENDIF
 E00E  54 68 65 20 68 65	TAG0		DB	"The hero we need but don't deserve"
       72 6F 20 77 65 20	
       6E 65 65 64 20 62	
       75 74 20 64 6F 6E	
       27 74 20 64 65 73	
       65 72 76 65		
								IF RANDOM_TAGLINE EQ 1
 E030  00					DB	0				; null terminate TAG0 string
								ENDIF
 E031  0D 0A			COPYRIGHT	DB	CR, LF
 E033  28 43 29 20 32 30			DB	'(C) ', COPY_YEAR, ' '
       32 32 2D 32 34 20	
 E03F  36 34 30 4B 42 20			DB	'640KB Released under GPLv3'
       52 65 6C 65 61 73	
       65 64 20 75 6E 64	
       65 72 20 47 50 4C	
       76 33			
 E059  0A					DB	LF
 E05A  00					DB	0
				
 E05B				BIOS_TOP 	ENDP
				
				;
				; 0 BYTES HERE
				;
				BYTES_HERE	BOOT
 = 0000                      1	BYTES_HERE_BOOT = BOOT-$ 
			     1			IFDEF BYTES_HERE_BOOT 
			     1			IF2 
			     1			ENDIF 
			     1			ENDIF 
				
							ASSUME CS:BIOS, DS:NOTHING, ES:NOTHING, SS:NOTHING
				;----------------------------------------------------------------------------;
				; F000:E05B: Beginning of boot execution
				;----------------------------------------------------------------------------;
				; Loosely follow these specs for BIOS POST operations:
				;
				; http://minuszerodegrees.net/5160/post/5160%20-%20POST%20-%20Detailed%20breakdown.htm
				; http://minuszerodegrees.net/5150/post/5150%20-%20POST%20-%20Detailed%20breakdown.htm
				; https://stanislavs.org/helppc/cold_boot.html
				; http://philipstorr.id.au/pcbook/book1/post.htm
				;----------------------------------------------------------------------------;
 E05B						ORG	0E05BH
 E05B				BOOT	PROC	NEAR
 E05B  FA				CLI 					; disable CPU interrupts
 E05C  FC				CLD					; clear direction flag
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-49


				
				
				;----------------------------------------------------------------------------;
				; POST Hardware/System Tests
				;----------------------------------------------------------------------------;
				
 E05D				POST_CPU_TEST:
				;----------------------------------------------------------------------------;
				; [1] Test and clear all CPU Registers
				;----------------------------------------------------------------------------;
				; Check and set all registers to 0.
				;
				; On Failure: 2 short and 1 long beep
				;----------------------------------------------------------------------------;
							ASSUME DS:_BDA_ABS, ES:_IVT
 E05D  B8 731D				MOV	AX, RAM_TEST		; use the standard test pattern
 E060				CPU_REG_TEST:
 E060  8B D8				MOV	BX, AX			; the game of telephone
 E062  8E DB				MOV	DS, BX			;  pass a
 E064  8C D9				MOV	CX, DS			;  known value
 E066  8E C1				MOV	ES, CX			;  through all
 E068  8C C6				MOV	SI, ES			;  registers and
 E06A  8E D6				MOV	SS, SI			;  ensure the
 E06C  8C D7				MOV	DI, SS			;  same value
 E06E  8B EF				MOV	BP, DI			;  makes it all
 E070  8B E5				MOV	SP, BP			;  the way
 E072  8B D4				MOV	DX, SP			;  to the end
 E074  F7 C2 8CE2			TEST	DX, NOT RAM_TEST		; expected result?
 E078  B3 21				MOV	BL, BEEP_SL <2,1>		; on Failure: 2 short and 1 long beep
 E07A  75 74				JNZ	HALT_ERROR
 E07C  33 C0				XOR	AX, AX 			; otherwise repeat with AX = 0
 E07E  85 D2				TEST	DX, DX			; if zero it was second pass
 E080  75 DE				JNZ	CPU_REG_TEST		; Loop again to zero all registers
 E082				CPU_REG_PASS:
				
				;----------------------------------------------------------------------------;
				; [1B] A brief test of flags and CPU instructions
				;----------------------------------------------------------------------------;
				; On Failure: 2 short and 1 long beep
				;----------------------------------------------------------------------------;
				
				;----------------------------------------------------------------------------;
				; [2] Disable non-maskable interrupts (NMIs)
				;----------------------------------------------------------------------------;
 E082				DISABLE_NMI:
 E082  E6 A0				OUT	NMI_R0, AL			; write AL = 0 to NMI register port
				
				;----------------------------------------------------------------------------;
				; [3] Set Zero Page Register for DMA channels 0 and 1
				;----------------------------------------------------------------------------;
 E084  E6 83				OUT	DMA_P_C1, AL 		; AL = high nibble of segment for DMA (0)
				
				;----------------------------------------------------------------------------;
				; [4] Disable MDA/CGA adapters (for now)
				;----------------------------------------------------------------------------;
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-50


 E086				INIT_VIDEO:
 E086  BA 03D8				MOV	DX, CGA_CTRL		; DX = 03D8H
 E089  EE				OUT	DX, AL 			; send Disable to CGA Mode Select Register
 E08A  40				INC	AX 				; clear MDA control, disable video signal
 E08B  B2 B8				MOV	DL, LOW MDA_CTRL		; DX = 03B8H
 E08D  EE				OUT	DX, AL 			; send to MDA CRT Control Port
					POST_CODE				; optionally display 01 on POST card
				
				;----------------------------------------------------------------------------;
				; Set up POST flags in BP
				;----------------------------------------------------------------------------;
 E08E  81 3E 0472 R 1234		CMP	WARM_FLAG_ABS, WARM_BOOT
 E094  75 03				JNZ	POST_FLAG_DONE
 E096  BD 8000				MOV	BP, MASK WARM		; clear and set POST warm boot flag
 E099				POST_FLAG_DONE:
				
							IF RANDOM_TAGLINE EQ 1
				;----------------------------------------------------------------------------;
				; Read PIT for seed of random pithy tagline
				;----------------------------------------------------------------------------;
 E099  48				DEC	AX				; Counter 0, Latch (00b)
 E09A  E6 43				OUT	PIT_CTRL, AL		; write command to CTC
 E09C  E4 40				IN	AL, PIT_CH0			; read low byte of Counter 0 latch
 E09E  D0 E8				SHR	AL, 1				; low bit is always 0
 E0A0  24 03				AND	AL, MASK GRND		; use only last two bits
 E0A2  0B E8				OR	BP, AX			; save to low bits of BP
							ENDIF
				
				;----------------------------------------------------------------------------;
				; Setup SS = CS
				;----------------------------------------------------------------------------;
				; Set up temporary stack to point at ROM to enable CALL_NS MACRO
				;----------------------------------------------------------------------------;
 E0A4  8C CA				MOV	DX, CS 			; DX = 0F000h (BIOS segment)
 E0A6  8E D2				MOV	SS, DX			; SS = temp boot stack in CS
				
				;----------------------------------------------------------------------------;
				; [5] Setup 8255 PPI to normal operating state
				;----------------------------------------------------------------------------;
				; Normal operation: Mode 0, Ports A,C (U and L) as INPUT, Port B as OUTPUT
				;----------------------------------------------------------------------------;
 E0A8				RESET_PPI:
							ELSE
 E0A8  B0 99				MOV	AL, PPI_CR <>		; set 8255 A,C to INPUT, B to OUTPUT
							ENDIF
 E0AA  E6 63				OUT	PPI_CW, AL 			; send to PPI control port (63H)
				
				;----------------------------------------------------------------------------;
				; Set up PPI port B
				;
 E0AC  B0 A8				MOV	AL, PPI_B_BOOT		; KB hold low+disable, NMI on, spkr off
 E0AE  E6 61				OUT	PPI_B, AL			; send to 8255 Port B
				
				
				
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-51


				;			IF (ARCH_TYPE EQ ARCH_EMU) AND (ARCH_SUB_TYPE EQ ARCH_MIST)
				;----------------------------------------------------------------------------;
				; Set up Turbo mode for PCXT_MiSTer
				;
				;	MOV	DX, MC_PORT			; DX = XTCTL port
				;	IN	AL, DX			; read current speed
				;	AND	AL, NOT MCSP_SPD		; clear speed bits
				;			IF BOOT_SPEED EQ BOOT_TURBO
				;	OR	AL, MC_XTCTL <MCSP_AT4>	; boot to AT 4MHz
				;			ELSE
				;	OR	AL, MC_XTCTL <,,,,MCSP_5> ; boot to XT 5MHz
				;			ENDIF
				;	OUT	DX, AL			; set new speed
				;	MOV	DX, SS			; restore DX
				;			ENDIF			; ARCH_MIST
				
							IF POST_TEST_CHK_ROM EQ 1
				;----------------------------------------------------------------------------;
				; [8] Checksum (8 bit) the main ROM to ensure it is not corrupt
				;----------------------------------------------------------------------------;
				; Input: AH = 0, BL = 21h, CX = 0, DX = 0F000h
				; On Failure: 2 long and 2 short beeps
				;----------------------------------------------------------------------------;
					JWB	CHECKSUM_OK			; skip on warm boot
			     1				IF WARM_ENABLE EQ 1 
 E0B0  85 ED                 1		TEST	BP, BP				; is warm boot? 
 E0B2  78 11                 1		JS	CHECKSUM_OK					; jump if so 
			     1				ENDIF 
 E0B4				CHECKSUM_ROM:
							ASSUME DS:BIOS
 E0B4  43				INC	BX				; on failure, 2 short and 2 long beeps
 E0B5  8E DA				MOV	DS, DX			; DS to 0F000h BIOS segment
 E0B7  BE E000 R			MOV	SI, OFFSET BIOS_TOP 	; offset to top of BIOS ROM
 E0BA  B5 10				MOV	CH, HIGH KBW < 8 >	; checksum 8KB (in 2 byte words)
 E0BC				CHECKSUM:
 E0BC  AD				LODSW 				; next two bytes into AL and AH
 E0BD  02 D0				ADD	DL, AL			; DL = accumulator for sum
 E0BF  02 D4				ADD	DL, AH			; ZF if sum is 0
 E0C1  E2 F9				LOOP	CHECKSUM 			; loop through entire ROM
 E0C3  75 2B				JNZ	HALT_ERROR			; if sum not 0, fail
 E0C5				CHECKSUM_OK:
							ENDIF
				
				;----------------------------------------------------------------------------;
				; [9] Disable the 8237 DMA controller chip.
				;----------------------------------------------------------------------------;
 E0C5				INIT_DMA1:
 E0C5  B0 04				MOV	AL, MASK DDIS		; Set Controller Disable bit
 E0C7  E6 08				OUT	DMA_CMD, AL 		; write to DMA Command Register
				
							IF POST_TEST_PIT_1 EQ 1
				;----------------------------------------------------------------------------;
				; [10] Test Channel #1 on 8253 timer chip.
				;----------------------------------------------------------------------------;
				; Channel #1 on 8253 timer chip. Channel #1 is used in RAM refresh process.  
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-52


				; If the test fails, beep failure code
				;
				; Test that all data lines are working by reading counter and checking 
				; that all bits from counter go both high and low.
				;----------------------------------------------------------------------------;
				; Use 16-bit mode to test low three address lines using high byte of counter.
				; This avoids a situation where the read counter code is a binary multiple
				; of the counter causing a bit to not be observed as changing.
				;
				; Control Word Counter 1 (port 43H) - System Timer:
				;  01 		- SC: Select Counter 1
				;    11		- RW: Read/Write 2xR/2xW
				;      010		- M:  Mode 2, Rate Gen
				;         0		- BCD: 0
				;
				; Output: Success SI and DI = 0, Failure 3 short, 2 long beeps
				;----------------------------------------------------------------------------;
						IF DRAM_REFRESH GT 0	; is DRAM refresh enabled?
 E0C9  B0 74				MOV	AL, PIT_CW <1, 11B, 2>	; Control Word: Counter 1
										;   Format: R/W low/high byte: 11b
										;   Mode: 2 Rate Gen, BCD: 0
 E0CB  BA 0041				MOV	DX, LOW PIT_CH1		; DX = PIT channel 1
						ENDIF
 E0CE  E6 43				OUT	PIT_CTRL, AL		; set Counter mode
 E0D0  EE				OUT	DX, AL			; set low byte (any value)
 E0D1  BE 07F8				MOV	SI, 0FFH SHL 3		; flag bits 10-3 for 1 check
 E0D4  BF F807				MOV	DI, NOT 0FFH SHL 3	; flag bits 10-3 for 0 check
 E0D7  EE				OUT	DX, AL			; set high byte (any value)
 E0D8				INIT_PIT1_TEST:
 E0D8  85 FF				TEST	DI, DI			; have all bits flipped to 0?
 E0DA  75 04				JNZ	INIT_PIT1_TEST_READ	; if not, keep reading PIT
 E0DC  46				INC	SI				; have all bits flipped to 1?
 E0DD  74 13				JZ	INIT_PIT1_TEST_DONE	; if so, success
 E0DF  4E				DEC	SI				; if not, undo INC and keep reading PIT
 E0E0				INIT_PIT1_TEST_READ:
						IF DRAM_REFRESH GT 0	; is DRAM refresh enabled?
 E0E0  B0 40				MOV	AL, PIT_CW <1,0>		; latch Counter 1 command
						ENDIF
 E0E2  E6 43				OUT	PIT_CTRL, AL		; write command to CTC
 E0E4  EC				IN	AL, DX			; read timer LSB
 E0E5  8A E0				MOV	AH, AL			; save LSB
 E0E7  EC				IN	AL, DX			; read timer MSB
 E0E8  23 F8				AND	DI, AX			; clear all lines read as 0
 E0EA  0B F0				OR	SI, AX			; set all lines read as 1
 E0EC  E2 EA				LOOP	INIT_PIT1_TEST		; loop until timeout
 E0EE  B3 32				MOV	BL, BEEP_SL <3,2>		; beep pattern (3 short, 2 long)
 E0F0				HALT_ERROR:
 E0F0  EB 63				JMP	SHORT HALT_BEEP_1		; NEAR jump for POST errors
							ENDIF
				
 E0F2				INIT_PIT1_TEST_DONE:
				
				;----------------------------------------------------------------------------;
				; [9B] 8253 PIT Programmable Interval Timer Initialization Channel 1
				;----------------------------------------------------------------------------;
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-53


				; Counter 1 - DRAM Refresh
				;----------------------------------------------------------------------------;
 E0F2				INIT_PIT1:
							ELSE
				;----------------------------------------------------------------------------;
				; Program PIT with single byte
				;
 E0F2  B0 54				MOV	AL, PIT_CW <1, 01B, 2>	; Control Word: Select Counter(SC): 1
										;   Format(RW): 01b (R/W byte LE)
										;   Mode(M): 2 (Rate Gen), BCD: 0 (Binary)
 E0F4  E6 43				OUT	PIT_CTRL, AL		; set Counter mode
				
							ENDIF
				
				;----------------------------------------------------------------------------;
				; [12] Reset, Clear and test DMA Offset and Block Size Registers
				;----------------------------------------------------------------------------;
				; - Master Reset of DMA controller
				; - Test 8237 DMA Address/Count Register channels 0-3
				;----------------------------------------------------------------------------;
 E0F6  E6 0D				OUT	DMA_RESET, AL 		; Master Reset (send any value of AL)
				
							IF POST_TEST_DMA EQ 1
 E0F8  B4 08				MOV	AH, 8				; test 8 ports
 E0FA  99				CWD					; starting at port 00H
					CALL_NS  PORT_TEST		; ZF and CX = 0 if pass, NZ if failed
 E0FB  BC E101 R             1		MOV	SP, OFFSET ??0001 
			     1				ELSE 
 E0FE  E9 E7EB R             1		JMP	PORT_TEST 
			     1				ENDIF 
 E101                        1	??0001: 
 E101  E103 R                1		DW	OFFSET ??0002 
 E103                        1	??0002: 
 E103  B3 42				MOV	BL, BEEP_SL <4,2>		; beep pattern (4 short, 2 long)
 E105  75 E9				JNZ	HALT_ERROR
 E107				DMA_PASS:
 E107  E6 0D				OUT	DMA_RESET, AL 		; master reset of DMA again
							ENDIF			; POST_TEST_DMA
				
							IF DRAM_REFRESH GT 0
				;----------------------------------------------------------------------------;
				; [13] Set Counter DMA Channel 0 for memory refresh
				;----------------------------------------------------------------------------;
				; https://www.reenigne.org/blog/how-to-get-away-with-disabling-dram-refresh/
				;----------------------------------------------------------------------------;
 E109  B0 FF				MOV	AL, 0FFH			; Memory refresh counter (16-bit) is 0FFFFH
 E10B  E6 01				OUT	DMA_0_C, AL			; write low order bits
 E10D  90				NOP					; very short I/O delay
 E10E  E6 01				OUT	DMA_0_C, AL			; write high order bits
				
				;----------------------------------------------------------------------------;
				; [13] Set Mode DMA Channel 0
				;----------------------------------------------------------------------------;
				; 01 			; Mode 1 (Single)
				;   0 		; INC: address decrement
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-54


				;    1 		; Auto-initialization
				;     10 		; type: Read from memory (2)
				;       00 		; Channel 0
				;----------------------------------------------------------------------------;
 E110  B0 58				MOV	AL, DMA_MR <1,0,1,2,0>
 E112  E6 0B				OUT	DMA_MODE, AL		; write to DMA Mode Register
				
				;----------------------------------------------------------------------------;
				; [13B] 8253 Timer set channel #1 for DMA/DRAM refresh
				;----------------------------------------------------------------------------;
 E114  B0 12				MOV	AL, LOW DRAM_REFRESH	; set low byte of divisor
 E116  E6 41				OUT	PIT_CH1, AL			; 
							ENDIF
				
				;----------------------------------------------------------------------------;
				; [13C] Enable DMA and clear mask register on Channels 0-3
				;----------------------------------------------------------------------------;
 E118  B0 00				MOV	AL, DMA_CR <>		; Set Controller Enable bit
 E11A  E6 08				OUT	DMA_CMD, AL 		; write to DMA Command Register
 E11C  B1 03				MOV	CL, 3				; Set mode on Channels 1-3 for [13D]
										;  (and I/O delay between OUTs)
 E11E  E6 0A				OUT	DMA_MASK, AL		; clear mask (enable) on all channels
				
				;----------------------------------------------------------------------------;
				; [13D] Set default Mode for DMA Channels 1-3
				;----------------------------------------------------------------------------;
				; 01 			; Mode 1 (Single)
				;   0 		; INC: address decrement
				;    0 		; No Auto-initialization
				;     00 		; type: Verify (0)
				;       xx 		; Channels 1-3
				;
				; Input: CL = 3 (from [13C]), CH = 0 (from CALL_NS in [12])
				;----------------------------------------------------------------------------;
 E120  B0 41				MOV	AL, DMA_MR <1,0,0,0,1>	; start with channel 1
 E122				DMA_SETUP_CH:
 E122  E6 0B				OUT	DMA_MODE, AL		; write to DMA Mode Register
 E124  40				INC	AX				; next channel
 E125  E2 FB				LOOP	DMA_SETUP_CH		; (delay 13-17 clocks between OUTs)
				
				
				;----------------------------------------------------------------------------;
				; [15] Test and zero first 16KB of RAM
				;----------------------------------------------------------------------------;
				; This is necessary to utilize the BIOS Data Area and a usable stack
				;
				; Parity bits are in an indeterminate state on power up so parity check must
				; be disabled until memory is written once.
				;
				; On failure:
				; - Read/Write Error: 1 short, 3 long beeps
				; - Parity Error: 1 short, 4 long beeps
				;
				; Input: CX = 0 from [13D]
				;----------------------------------------------------------------------------;
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-55


							ASSUME DS:_BDA_ABS, ES:_IVT
 E127				BASE_RAM_TEST:
 E127  E4 61				IN	AL, PPI_B 				; AL = PB0 flags
 E129  0C 30				OR	AL, MASK PBIO OR MASK PBPC	; disable RAM parity and I/O ch. flags
 E12B  E6 61				OUT	PPI_B, AL
 E12D  91				XCHG	AX, CX				; AX = 0 = MEM_CHECK pattern and
 E12E  8E D8				MOV	DS, AX				; DS and ES = IVT segment 0000
 E130  BE 0472 R			MOV	SI, OFFSET WARM_FLAG_ABS	; SI = warm boot flag offset
 E133  8B 14				MOV	DX, [SI]				; save warm boot flag
					CALL_NS  MEM_CHECK			; clear memory and parity bits
 E135  BC E13B R             1		MOV	SP, OFFSET ??0003 
			     1				ELSE 
 E138  E9 E629 R             1		JMP	MEM_CHECK 
			     1				ENDIF 
 E13B                        1	??0003: 
 E13B  E13D R                1		DW	OFFSET ??0004 
 E13D                        1	??0004: 
 E13D  75 14				JNZ	BASE_RAM_ERROR
 E13F  E4 61				IN	AL, PPI_B				; read PPI channel B
 E141  0C 10				OR	AL, MASK PBPC 			; clear MB RAM parity flag only
 E143  E6 61				OUT	PPI_B, AL
 E145  24 EF				AND	AL, NOT MASK PBPC 		; enable MB RAM parity for test
 E147  E6 61				OUT	PPI_B, AL
					CALL_NS  MEM_ADDR_TEST			; test address lines
 E149  BC E14F R             1		MOV	SP, OFFSET ??0005 
			     1				ELSE 
 E14C  E9 E5F8 R             1		JMP	MEM_ADDR_TEST 
			     1				ENDIF 
 E14F                        1	??0005: 
 E14F  E151 R                1		DW	OFFSET ??0006 
 E151                        1	??0006: 
 E151  74 05				JZ	BASE_RAM_ZERO			; continue if no errors
 E153				BASE_RAM_ERROR:
 E153  B3 13				MOV	BL, BEEP_SL <1,3>			; on failure, 1 short and 3 long beeps
 E155				HALT_BEEP_1:
 E155  E9 E874 R			JMP	HALT_BEEP				; NEAR jump to HALT BEEP PROC
 E158				BASE_RAM_ZERO:
 E158  B8 731D				MOV	AX, RAM_TEST			; test pattern
					CALL_NS  MEM_CHECK			; write and verify test pattern
 E15B  BC E161 R             1		MOV	SP, OFFSET ??0007 
			     1				ELSE 
 E15E  E9 E629 R             1		JMP	MEM_CHECK 
			     1				ENDIF 
 E161                        1	??0007: 
 E161  E163 R                1		DW	OFFSET ??0008 
 E163                        1	??0008: 
 E163  75 EE				JNZ	BASE_RAM_ERROR			; ZF and AX = 0 if okay
					CALL_NS  MEM_CHECK			; write and verify zeros
 E165  BC E16B R             1		MOV	SP, OFFSET ??0009 
			     1				ELSE 
 E168  E9 E629 R             1		JMP	MEM_CHECK 
			     1				ENDIF 
 E16B                        1	??0009: 
 E16B  E16D R                1		DW	OFFSET ??000A 
 E16D                        1	??000A: 
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-56


 E16D  75 E4				JNZ	BASE_RAM_ERROR
 E16F  87 14				XCHG	[SI], DX				; restore warm boot flag, DX = 0
 E171  40				INC	AX					; AL = 1
 E172  A2 0440 R			MOV	FD_MOTOR_CT_ABS, AL 		; set motor to turn off on next tick
				
				;----------------------------------------------------------------------------;
				;
				; YAY! It's now okay to use the first 16KB of RAM: 0000:0000-0000:1FFF
				;
				;----------------------------------------------------------------------------;
				
				;----------------------------------------------------------------------------;
				; [18] Setup BOOT R/W stack memory segment
				;----------------------------------------------------------------------------;
							ASSUME SS:_BOOT_STACK
 E175  B8 ---- R			MOV	AX, SEG STACK_TOP 		; SS:SP to temp boot stack 0030:0100
 E178  8E D0				MOV	SS, AX
 E17A  BC 0100 R			MOV	SP, OFFSET STACK_TOP
				
				;----------------------------------------------------------------------------;
				; [19] 8259A PIC Interrupt controller Initialization
				;----------------------------------------------------------------------------;
				; PIC chip Initialization as follows:
				;
				; ICW1:
				;     1 		- D4:   1 = ICW1 (and Port 0)
				;      0 		- LTIM: 0 = Edge Triggered Mode (low to high TTL transition)
				;       0 		- ADI:  0 = Call Address Interval of 8
				;        1 		- SNGL: 1 = Single mode (no cascading PICs or ICW3)
				;         1		- IC4:  1 = ICW4 Needed
				;----------------------------------------------------------------------------;
				; ICW2:
				;  00001 		- T7-T3: Interrupt Vector Address:
				;				INT = INT | 8 -> IRQ 0-7 to CPU INT 8-15
				;       000 	- D2-D0: unused on 8086 mode
				;----------------------------------------------------------------------------;
				; ICW4:
				;     0		- SFNM: 0 = Not Special Fully Nested Mode
				;      10		- BUF:  2 = Buffered Mode/Slave
				;        0		- AEOI: 0 = normal EOI
				;         1		- uPM:  1 = 8086 system
				;----------------------------------------------------------------------------;
 E17D  B2 20				MOV	DL, LOW INT_P0		; DX = PIC Port 0
 E17F  B0 13				MOV	AL, ICW1 <1,0,0,1,1>	; AL = ICW1 - Port 0
 E181  EE				OUT	DX, AL
 E182  42				INC	DX				; DX = PIC Port 1
 E183  B8 0108				MOV	AX, DBW <1,ICW2 <1>> 	; AL = ICW2 - Port 1, AH = PORT_TEST count
 E186  EE				OUT	DX, AL
 E187  40				INC	AX				; AL = ICW4 <0,2,0,1> - Port 1
 E188  EE				OUT	DX, AL
				
							IF POST_TEST_PIC_REG EQ 1
				;----------------------------------------------------------------------------;
				; [22] 8259A PIC Test
				;----------------------------------------------------------------------------;
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-57


				; - Read and write registers (IMR) and verify result
				;----------------------------------------------------------------------------;
 E189  E8 E7EB R			CALL	PORT_TEST			; test of PIC IMR register
 E18C  B3 52				MOV	BL, BEEP_SL <5,2>		; beep error 5 short, 2 long
 E18E  74 02				JZ	PIC_REG_PASS
 E190				PIC_INT_FAIL:
 E190  EB C3				JMP	SHORT HALT_BEEP_1
 E192				PIC_REG_PASS:
 E192  4A				DEC	DX				; DX = Port 1 (0021h)
							ENDIF			; IF POST_TEST_PIC_REG EQ 1
				
 E193  B0 FF				MOV	AL, OCW1 <1,1,1,1,1,1,1,1> ; OCW1 - mask all interrupts (for now)
 E195  EE				OUT	DX, AL			; write IMR to PIC
				
							IF POST_TEST_PIC_INT EQ 1
				;----------------------------------------------------------------------------;
				; - Set up test interrupt handler for all interrupts
				;
 E196				PIC_INT_TEST:
 E196  B1 1F				MOV	CL, 1FH			; 0 - 1EH BIOS vectors (LOW L_VECTOR_TABLE)
 E198  33 FF				XOR	DI, DI			; DI = beginning to IVT
 E19A				PIC_VECT_TMP_LOOP:
 E19A  B8 FF23 R			MOV	AX, OFFSET INT_IRQ	; offset for handler
 E19D  AB				STOSW					; write to IVT (ES=0000 from CPU_REG_TEST)
 E19E  8C C8				MOV	AX, CS			; segment for handler (BIOS)
 E1A0  AB				STOSW					; write to IVT
 E1A1  E2 F7				LOOP	PIC_VECT_TMP_LOOP
				
				;----------------------------------------------------------------------------;
				; - Mask all interrupts and ensure none are received
				; Input: AL = 0 (from MOV AX, CS)
				;
 E1A3  BF 046B R			MOV	DI, OFFSET INT_LAST_ABS
 E1A6  88 05				MOV	[DI], AL			; clear last interrupt flag
 E1A8  FB				STI					; enable interrupts
					IO_DELAY				; wait for it...
 E1A9                        1	??000B: 
 E1A9  E2 FE                 1		LOOP	??000B					; long delay for I/O 
 E1AB  FA				CLI
 E1AC  43				INC	BX				; beep error 5 short, 3 long
 E1AD  08 05				OR	[DI], AL			; did any interrupts happen?
				
							IF POST_TEST_PIC_REG EQ 1
 E1AF  75 DF				JNZ	PIC_INT_FAIL
							ENDIF			; IF POST_TEST_PIC_REG EQ 1
							ENDIF			; IF POST_TEST_PIC_INT EQ 1
				
 E1B1  B0 FE				MOV	AL, NOT MASK IRQ0		; OCW1 - unmask timer
 E1B3  EE				OUT	DX, AL			; write IMR to PIC
				
 E1B4				PIC_INT_PASS:
				
				;----------------------------------------------------------------------------;
				; [23] Setup Channel #0 on 8253 timer chip.
				;----------------------------------------------------------------------------;
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-58


				; Control Word Counter 0 (port 43H) - System Timer:
				;  00 		- SC: Select Counter 0
				;    11		- RW: Read/Write 2xR/2xW
				;      011		- M:  Mode 3, Square Wave
				;         0		- BCD: 0
				;----------------------------------------------------------------------------;
 E1B4  B0 36				MOV	AL, PIT_CW <0, 11B, 3>	; Control Word: Select Counter(SC): 1
										;   Format(RW): 11b (Read/Write 2xR/2xW)
										;   Mode(M): 2 (Rate Gen), BCD: 0 (Binary)
 E1B6  E6 43				OUT	PIT_CTRL, AL
 E1B8  0E				PUSH	CS				; I/O delay and set up for DS = CS below
				
				;----------------------------------------------------------------------------;
				; This is what generates IRQ 0 (system timer).
				; Timer set channel #0 output to a square wave of approx. 18.2 Hz based on
				;	f = 1,193,181.81 / 10000H = ~ 18.2Hz
				; Reload counter to WORD (0) to port 40H
				;
 E1B9  32 C0				XOR	AL, AL			; reload counter is 2^16 (0) ~ 18.2Hz
 E1BB  E6 40				OUT	PIT_CH0, AL	  		; send low byte
 E1BD  1F				POP	DS				; I/O delay and set DS = CS
 E1BE  E6 40				OUT	PIT_CH0, AL 		; send high byte
				
				;----------------------------------------------------------------------------;
				; [25] Setup default BIOS interrupt vectors (00h - 01Eh)
				;----------------------------------------------------------------------------;
				; All segments are set to BIOS (CS) segment by default.
				; INT 1Fh is skipped and left as 0000:0000.
				; Exceptions (such as ROM BASIC) are reset below.
				; Input: ES = 0000 from CPU_REG_TEST
				;----------------------------------------------------------------------------;
							ASSUME DS:BIOS, ES:_IVT
 E1C0				INIT_SW_INT_VECTORS:
 E1C0  8C C8				MOV	AX, CS 			; AX to BIOS segment
 E1C2  B1 1F				MOV	CL, 1FH			; 0 - 1EH BIOS vectors (LOW L_VECTOR_TABLE)
 E1C4  33 FF				XOR	DI, DI			; DI = beginning to IVT
 E1C6  BE FEE3 R			MOV	SI, OFFSET VECTOR_TABLE
 E1C9				BIOS_INT_VECTORS_LOOP:
 E1C9  A5				MOVSW 				; copy vector offset to IVT
 E1CA  AB				STOSW 				; write BIOS/CS segment
 E1CB  E2 FC				LOOP	BIOS_INT_VECTORS_LOOP	; loop and set CX = 0
				
				
				;----------------------------------------------------------------------------;
				; [18] Setup DS and ES to BDA segment
				;----------------------------------------------------------------------------;
							ASSUME DS:_BDA, ES:_BDA
 E1CD  B8 ---- R			MOV	AX, SEG _BDA 			; DS and ES to BDA
 E1D0  8E D8				MOV	DS, AX
 E1D2  8E C0				MOV	ES, AX
				
				;----------------------------------------------------------------------------;
				; Check CPU type
				;----------------------------------------------------------------------------;
				; If V20 is build target but V20 not detected - beep 1 long, 4 short
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-59


				;----------------------------------------------------------------------------;
 E1D4				CPU_IS_V20:
 E1D4  B8 0101				MOV	AX, DBW <1,1>			; Attempt to pack bytes into nibbles
					AAD_I	10H					; result is 11 if V20, 11H if x86
 E1D7  D5 10                 1		DB	0D5H, 10H			; AAD	imm 
 E1D9  3C 0B				CMP	AL, 11				; ZF = 1 if V20, ZF = 0 if 8088
 E1DB  75 05				JNE	CPU_TYPE_8088			; jump if not V20
					SET_GFLAG	V20				; set V20 flag
 E1DD  80 0E 0012 R 04       1		OR	GB_FLAGS, MASK V20		; set flag(s) 
							ELSE
 E1E2				CPU_TYPE_8088:
							ENDIF
 E1E2				CPU_TYPE_DONE:
				
				;----------------------------------------------------------------------------;
				; [14] Read DIP switch settings and init proper EQUIP_FLAGS
				;----------------------------------------------------------------------------;
				;
				; https://sites.google.com/site/pcdosretro/biosdata
				; https://stanislavs.org/helppc/int_11.html
				;
				; 5150 Sense Switches:
				;  Port A - when Port B bit 7 = 1
				;     High| Low
				; 	00  |			; Disk Drives (00=1, 01=2, 10=3, 11=4)
				; 	  00| 		; Video (00=EGA/VGA, 01=CGA 40, 10=CGA 80, 11=MDA)
				;	    |00		; MB RAM (00=16KB, 01=32K, 10=48K, 11=64K)
				;	    |  0		; FPU installed ("Reserved")
				; 	    |   0		; IPL Floppy Disk Drive (0=floppy drive installed)
				;  Port C - I/O RAM (x 32KB)
				;	High| Low
				;	    |4321		; RAM size bits 1-4   when Port B bit 2 = 1
				;	     4325		; RAM size bits 5,2-4 when Port B bit 2 = 0
				;----------------------------------------------------------------------------;
				; 5160 Sense Switches:
				;  Port C
				;	High| Low
				; 	00  |			; Disk Drives (00=1, 01=2, 10=3, 11=4)
				; 	  00| 		; Video (00=EGA/VGA, 01=CGA 40, 10=CGA 80, 11=MDA)
				;	    |00		; MB RAM Banks (00=Bank 0, Bank 0/1, 10=0/1/2, 11=0/1/2/3)
				;	    |  0		; FPU installed
				; 	    |   0		; Test Loop (always 0)
				;
				; EQUIP_FLAGS: LPT:2,X1:1,GAM:1,COM:3,DMA:1,FLP:2,VID:2,MBRAM:2,FPU:1,IPL:1
				;----------------------------------------------------------------------------;
 E1E2				GET_SW_SETTINGS:
 E1E2  E4 61				IN	AL, PPI_B 				; read Port B register
 E1E4  50				PUSH	AX					; save original switches, AH = 0
				
						ELSE
						ELSE                          ; not ARCH_5150 OR ARCH_FE2010
						ELSE
				;----------------------------------------------------------------------------;
				; Is a 5160 or standard PPI
				;
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-60


 E1E5				SETTINGS_5160:
 E1E5  24 F7				AND	AL, NOT MASK PBSW			; set bit 3 = 0 for low switch select
 E1E7  E6 61				OUT	PPI_B, AL
 E1E9  50				PUSH	AX		 			; save port settings
 E1EA  E4 62				IN	AL, PPI_C 				; get low switches
							ELSE
 E1EC  24 0F				AND	AL, MASK MBRAM OR MASK FPU OR MASK IPL ; isolate MB RAM and FPU bits
 E1EE  8A E8				MOV	CH, AL				; save to CH
							ENDIF
 E1F0  58				POP	AX 					; get port settings
 E1F1  0C 08				OR	AL, MASK PBSW 			; set bit 3 = 1 for high switch select
 E1F3  E6 61				OUT	PPI_B, AL
 E1F5  E4 62				IN	AL, PPI_C 				; get high switches
							ELSE
 E1F7  B1 04				MOV	CL, 4
 E1F9  D2 E0				SHL	AL, CL				; shift drives and video to high nibble
 E1FB  0A C5				OR	AL, CH				; combine RAM, FPU with drives and vid
							ENDIF
				
							IF MAX_RAM_AUTO EQ 1
				;----------------------------------------------------------------------------;
				; Set MAX_RAM from video DIP switches: CGA=736, MDA=704 else 640
				; 21 bytes
				;
 E1FD				MAX_RAM_AUTO_SETUP PROC
 E1FD  50				PUSH	AX					; save original equipment byte
 E1FE  BA 0280				MOV	DX, MAX_RAM_PC			; default 640K
 E201  24 30				AND	AL, MASK VID			; bits 4-5 video only
 E203  74 08				JZ	MAX_RAM_AUTO_DONE			; done if EGA/VGA (OFF, OFF)
 E205  B2 C0				MOV	DL, LOW MAX_RAM_MDA		; try MDA 704K
 E207  3C 30				CMP	AL, VID_MDA SHL VID		; is MDA (ON, ON)?
 E209  74 02				JE	MAX_RAM_AUTO_DONE			; done if MDA
 E20B  B2 E0				MOV	DL, LOW MAX_RAM_CGA		; else CGA 736K
 E20D				MAX_RAM_AUTO_DONE:
 E20D  89 16 0015 R			MOV	MEM_SZ_PC, DX			; save to BDA
 E211  58				POP	AX					; restore equipment byte
 E212				MAX_RAM_AUTO_SETUP ENDP
							ENDIF
				
						ENDIF					; not ARCH_TYPE EQ ARCH_EHB
						ENDIF					; not ARCH_TYPE EQ ARCH_FE2010
						ENDIF					; not ARCH_TYPE EQ ARCH_5150
				
 E212				SETTINGS_DONE:
				;----------------------------------------------------------------------------;
				; If set on MB DIP SW1, test and verify FPU. If not detected, disable in BDA.
				;
 E212  A8 02				TEST	AL, MASK FPU			; is FPU set?
 E214  74 07				JZ	SETTINGS_SAVE			; if not, skip to save flags
 E216  E8 FFC3 R			CALL	HAS_FPU				; check FPU, ZF=0 if not detected
 E219  74 02				JZ	SETTINGS_SAVE			; if detected, save flags
							ELSE
 E21B  24 FD				AND	AL, NOT MASK FPU			; otherwise clear FPU flag
							ENDIF
 E21D				SETTINGS_SAVE:
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-61


 E21D  A2 0010 R			MOV	BYTE PTR EQUIP_FLAGS, AL	; set to low byte of EQUIP_FLAGS
				
				
 E220  92				XCHG	AX, DX				; save EQUIP_FLAGS to DL for later
 E221  58				POP	AX					; AL = original settings, AH = 0
 E222  E6 61				OUT	PPI_B, AL				; restore original settings
				
				
				
				;----------------------------------------------------------------------------;
				; [21] Video BIOS Option ROM scan
				;----------------------------------------------------------------------------;
				; Scan 0C000H - 0C800H for video option ROMs (EGA, VGA, etc)
				;
				; A video option ROM should set the BDA video type flag to a non-zero value
				; If the flag is still 0 afterwards, no ROMs loaded succesfully.
				;----------------------------------------------------------------------------;
 E224  B8 ---- R			MOV	AX, SEG _VID_BIOS			; starting segment (C000H)
 E227  BF ---- R			MOV	DI, SEG _OPT_ROM			; ending segment (C800H)
 E22A  52				PUSH	DX					; save EQUIP_FLAGS for below
 E22B  E8 E50B R			CALL	BIOS_ROM_SCAN			; scan segments AX to DI for ROMs
 E22E  5A				POP	DX					; restore EQUIP_FLAGS
				
				;----------------------------------------------------------------------------;
				; Check for a valid video mode in BDA:
				;  - If BDA video mode is 0, video option ROM was not loaded. Beep and halt
				;  - If MB video switch is 0 (option ROM), skip reset
				;  - If not 0, determine correct 6845 video mode and do INT 10H reset
				;----------------------------------------------------------------------------;
					GET_EFLAG  VID				; AX = 00=error(ZF), 01=CGA 40, 10=CGA 80, 11=MDA
			     1	;----------------------------------------------------------------------------; 
			     1	; Shift if flag is in high byte to low for byte operations 
			     1	; 
			     1				IF VID LT 8		; is in low byte? 
 = 0030                      1	??000C	= MASK VID 
 = 0004                      1	??000D	= VID AND 0111B 
 = 0010                      1	??000E	= EQUIP_FLAGS[0]			; low BDA flags byte 
			     1				ENDIF 
 E22F  A0 0010 R             1		MOV	AL, BYTE PTR ??000E		; AL = equipment flag byte 
 E232  25 0030               1		AND	AX, ??000C			; isolate bits, clear AH 
			     1	;----------------------------------------------------------------------------; 
			     1	; Determine optimal number of shifts based on bit position and shift 
			     1	; right or left depending on fewest. 
			     1	; 
			     1				ELSE 
			     1					ELSE			; optimal to roll right 
			     1						IF ??000D GT 2 
 E235  B1 04                 1		MOV	CL, ??000D			; CL = bit(s) position of record 
 E237  D2 C8                 1		ROR	AL, CL				; shift value into position 
			     1						ENDIF 
			     1					ENDIF 
			     1				ENDIF 
 E239  75 05				JNZ	VID_MODE_OK				; jump if mode valid or video option ROM loa
				ded
 E23B  B3 33				MOV	BL, BEEP_SL <3,3>			; Beep 3 long, 3 short
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-62


 E23D				HALT_BEEP_2:
 E23D  E9 E874 R			JMP	HALT_BEEP				; NEAR jump to beep
 E240				VID_MODE_OK:
 E240  F6 C2 30				TEST	DL, MASK VID			; is SW1 mode 00?
 E243  74 07				JZ	RESET_VIDEO_DONE			; if custom video ROM, skip reset
 E245  BB E82A R			MOV	BX, OFFSET VID_MODE_TBL[-1]	; AL = BDA video type, BX = mode table
 E248  2E: D7				XLAT	CS:[BX]				; AL = INT 10H video mode
				
				;----------------------------------------------------------------------------;
				; Clear screen and reset the video display
				;
 E24A				RESET_VIDEO:
 E24A  CD 10				INT	10H					; AH = 0 - Set Video Mode
 E24C				RESET_VIDEO_DONE:
				
							IF POST_BANNER EQ 1
				;----------------------------------------------------------------------------;
				; Hello Computer ("just use the keyboard")
				;----------------------------------------------------------------------------;
 E24C				HELLO_WORLD:
							IF RANDOM_TAGLINE EQ 1
 E24C  E8 F8C7 R			CALL	HELLO_RAND_TAGLINE		; display banner and random tagline
							ENDIF
							ENDIF
				
				;----------------------------------------------------------------------------;
				; Save the initial cursor mode to BDA for hot key and POST display
				;
 E24F  33 DB				XOR	BX, BX				; BH = video page 0
 E251  B4 03				MOV	AH, 3					; get cursor: CX = power-on cursor
 E253  CD 10				INT	10H					;  DX = position
 E255  89 0E 00E8 R			MOV	CURSOR_DEFAULT, CX		; save to BDA for Turbo toggle
				
							IF POST_BANNER EQ 1
				;----------------------------------------------------------------------------;
				; Display VERSION notice in bottom left
				;
 E259  52				PUSH	DX					; save cursor position
 E25A  BA 1800				MOV	DX, DBW <24, 0> 			; bottom left row = 24, col = 0
 E25D  B4 02				MOV	AH, 2 				; set bottom cursor position 
 E25F  CD 10				INT	10H 					; row = DH, column = DL
					PRINT_SZ  VER				; display version
			     1			IFDIFI <VER>,<SI>			; if SZ is not SI 
 E261  BE FFE0 R             1		MOV	SI, OFFSET VER 
			     1			ENDIF 
 E264  E8 F72E R             1		CALL	OUT_SZ 
					PRINT_SZ  REL_DATE			; display build date
			     1			IFDIFI <REL_DATE>,<SI>			; if SZ is not SI 
 E267  BE FFF5 R             1		MOV	SI, OFFSET REL_DATE 
			     1			ENDIF 
 E26A  E8 F72E R             1		CALL	OUT_SZ 
 E26D  5A				POP	DX					; restore previous cursor
 E26E  B4 02				MOV	AH, 2 				; reset cursor position
 E270  CD 10				INT	10H 					; row = DH, column = DL
							ENDIF
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-63


				
				;----------------------------------------------------------------------------;
				; Jump over INT 02h fixed ORG to continue...
				;
					JMP_FIX	POST_DETECT_PORTS, 0E2E7H	; hack to use SHORT jump if possible
 = 02E3                      1	??000F	=	OFFSET POST_DETECT_PORTS - BIOS_TOP	; use to determine correct offset for DEST 
			     1							; since cannot use this with forward labels 
			     1				IF ( ( 0E2E7H - 0E000H ) - ( $ - BIOS_TOP ) ) LT 80H 
 E272  EB 6F                 1		JMP	SHORT POST_DETECT_PORTS 
			     1				ENDIF 
				
				
							IF IS_TURBO
				;----------------------------------------------------------------------------;
				; Toggle Turbo mode on/off
				;----------------------------------------------------------------------------;
				; Note: for standard PPI-based systems, some references state that flipping
				; both bit 2 and 3 (0Ch) are required, and some only bit 2 (04h). Flipping 
				; only bit 2 seems to work fine however.
				;
				; Clobbers AX, CX, DX
				;----------------------------------------------------------------------------;
 E274				TOGGLE_TURBO PROC
							ASSUME DS:_BDA
 E274  FA				CLI						; interrupts off
				
						ELSE					; NOT ARCH_TD3300
				
				;----------------------------------------------------------------------------;
				; VTech Laser Turbo XT switch
				; Only bit 7 is used, 0 for standard speed and 1 for turbo speed
				;
							ELSE				; NOT ARCH_TD3300 OR ARCH_LASER
				
				;----------------------------------------------------------------------------;
				; Standard PPI B Turbo switch
				;
 E275  E4 61				IN	AL, PPI_B				; read PPI
 E277  34 04				XOR	AL, MASK PBTB			; flip turbo bit
 E279  E6 61				OUT	PPI_B, AL
				
				
				
				
				
								ELSE			; NOT ARCH_MIST AND NOT ARCH_TD3300
				
				;----------------------------------------------------------------------------;
				; NZ if turbo bit set, ZF if not turbo
				;
				;					IF ARCH_TYPE EQ ARCH_FE2010
				;	TEST	AL, MASK FSPD			; speed low?
				;					ELSE
 E27B  A8 04				TEST	AL, MASK PBTB			; standard turbo bit set?
				;					ENDIF
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-64


								ENDIF			; ARCH_MIST
							ENDIF				; ARCH_LASER
						ENDIF					; ARCH_TD3300
				
 E27D  8B 0E 00E8 R			MOV	CX, CURSOR_DEFAULT		; original power-on cursor (fast)
 E281  75 02				JNZ	TOGGLE_TURBO_CURSOR		; Jump if turbo, use original cursor
 E283  32 ED				XOR	CH, CH 				; starting scan line 0 ("big cursor")
 E285				TOGGLE_TURBO_CURSOR:
 E285  E8 F03E R			CALL	SET_CURSOR				; Video set cursor
				
 E288				TOGGLE_TURBO_DONE:
 E288  FB				STI						; Enable interrupts
 E289  C3				RET
 E28A				TOGGLE_TURBO ENDP
							ENDIF				; IF IS_TURBO
				
				
				
				
				
				
				;
				; 1 BYTES HERE
				;
				BYTES_HERE	INT_02
 = 0039                      1	BYTES_HERE_INT_02 = INT_02-$ 
			     1			IFDEF BYTES_HERE_INT_02 
			     1			IF2 
			     1			ENDIF 
			     1			ENDIF 
				
				;----------------------------------------------------------------------------;
				; INT 2 - NMI 
				;----------------------------------------------------------------------------;
				; If NMI / IRQ 2 occurs (a parity or I/O exception), display error type and
				; halt. Exit if it was an 8087 exception as that should be intercepted by 
				; a user coprocessor exception handler.
				;----------------------------------------------------------------------------;
 E2C3						ORG 0E2C3H
 E2C3				INT_02 PROC
 E2C3  50				PUSH	AX
 E2C4  E4 62				IN	AL, PPI_C 				; get PC0 register
 E2C6  A8 C0				TEST	AL, MASK PCPE OR MASK PCIE	; parity or I/O error?
 E2C8  75 02				JNZ	INT_02_NMI_PAR 			; first, check parity
 E2CA  58				POP	AX					; if neither, exit
 E2CB  CF				IRET						; must have been an 8087 NMI
 E2CC				INT_02_NMI_PAR:
 E2CC  BE E503 R			MOV	SI, OFFSET NMI_ERR_PAR 		; Parity error string
 E2CF  A8 80				TEST	AL, MASK PCPE			; parity error?
 E2D1  75 02				JNZ	INT_02_NMI_HALT
 E2D3  4E				DEC	SI					; otherwise is I/O error
 E2D4  4E				DEC	SI					; decrement to NMI_ERR_IO
 E2D5				INT_02_NMI_HALT:
 E2D5  33 C0				XOR	AX, AX				; reset video, clear screen
 E2D7  E6 A0				OUT	NMI_R0, AL				; mask the unmaskable
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-65


 E2D9  CD 10				INT	10H					; switch to text video mode
 E2DB  E8 F72E R			CALL	OUT_SZ 				; display string in CS:SI
 E2DE  E8 E638 R			CALL	NMI_RESET				; clear NMI/parity flags
 E2E1  FA				CLI						; ensure interrupts off
 E2E2  F4				HLT						; halt CPU
 E2E3				INT_02 ENDP
				
 E2E3				POST_DETECT_PORTS PROC
				;----------------------------------------------------------------------------;
				; [37] Setup LPT/COM default timeouts
				;----------------------------------------------------------------------------;
							ASSUME ES:_BDA
 E2E3  BF 0078 R			MOV	DI, OFFSET LPT_TIME
 E2E6  B8 1414				MOV	AX, DBW <LPT_TO, LPT_TO>	; LPT timeout values
 E2E9  AB				STOSW						; write x 4 to BDA
 E2EA  AB				STOSW
 E2EB  B8 0101				MOV	AX, DBW <COM_TO, COM_TO>	; COM timeout values
 E2EE  AB				STOSW
 E2EF  AB				STOSW
				
 E2F0  BB 0011 R			MOV	BX, OFFSET EQUIP_FLAGS[1]	; BX = high byte of EQUIP_FLAGS
				
				;----------------------------------------------------------------------------;
				; [38] Detect and enable Game port
				;----------------------------------------------------------------------------;
				; Port 201H
				; Input: 
				;	BX = high byte of EQUIP_FLAGS
				;
				; Equipment Bit is set if the lower nibble of an I/O port 201h read is zero
				; http://www.minuszerodegrees.net/5150_5160/post/IBM%205150%20and%205160%20-%20Bit%2012%20of%20Equip
				ment%20Flag.htm
				;----------------------------------------------------------------------------;
 E2F3				POST_DETECT_GAM:
 E2F3  BA 0201				MOV	DX, GAME_CTRL
 E2F6  EC				IN	AL, DX 				; will be 0FFH if no port
 E2F7  A8 0F				TEST	AL, 0FH
 E2F9  75 03				JNZ	NO_GAME_PORT
 E2FB  80 0F 10				OR	BYTE PTR [BX], HIGH MASK GAM	; enable Game Port bit
 E2FE				NO_GAME_PORT:
				
				;----------------------------------------------------------------------------;
				; [37] Detect and enable COM ports 1-4
				;----------------------------------------------------------------------------;
				; Ports 3F8H, 2F8H, 3E8H, 2E8H
				; Input:
				;	BX = high byte of EQUIP_FLAGS
				;	ES, DS = BDA segment
				;----------------------------------------------------------------------------;
 E2FE				POST_DETECT_COM:
 E2FE  B9 0004				MOV	CX, 4					; four COM ports
 E301  33 FF				XOR	DI, DI 				; 00H BDA COM1-4 base addresses
 E303  BA 03FA				MOV	DX, COM1_IIR			; 3FAH: COM1 Interrupt Ident Reg
 E306				COM_DETECT_LOOP:
 E306  32 C0				XOR	AL, AL				; AL = 0
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-66


 E308  EE				OUT	DX, AL				; clear FIFO Control Register (FCR)
 E309  EC				IN	AL, DX 				; read IIR to clear DMA flags
 E30A  EC				IN	AL, DX 				; read IIR again
 E30B  4A				DEC	DX
 E30C  4A				DEC	DX					; DX = base port
 E30D  A8 F0				TEST	AL, 11110000B 			; check if any high 4 bits are set
 E30F  92				XCHG	AX, DX				; AX = detected port
 E310  75 04				JNZ	NO_COM_PORT				; if so, not a valid port
 E312  AB				STOSW 					; write I/O port to COM BDA table
 E313  80 07 02				ADD	BYTE PTR[BX], HIGH(1 SHL COM)	; INC COM port count in flags
 E316				NO_COM_PORT:
 E316  2D 00FE				SUB	AX, COM1_DATA-COM2_IIR		; base port to next IIR port
 E319  92				XCHG	AX, DX				; DX = next IIR port
 E31A  80 F9 03				CMP	CL, 3 				; is COM2 (COM3 next)?
 E31D  75 03				JNE	NEXT_COM_PORT			; if not, next
 E31F  BA 03EA				MOV	DX, COM3_IIR			; restart at 3EAH: COM3 IIR
 E322				NEXT_COM_PORT:
 E322  E2 E2				LOOP	COM_DETECT_LOOP
				
				;----------------------------------------------------------------------------;
				; [36] Detect and enable LPT ports
				;----------------------------------------------------------------------------;
				; Ports 3BCH, 378H, 278H
				; Input: 
				;	BX = high byte of EQUIP_FLAGS
				;	CH = 0
				;----------------------------------------------------------------------------;
 E324				POST_DETECT_LPT:
 E324  B1 03				MOV	CL, 3					; three LPT ports
 E326  BF 0008 R			MOV	DI, OFFSET LPT_ADDR		; 08H BDA LPT1-3 base addresses
 E329  BA 03BC				MOV	DX, LPT_MDA				; start with MDA printer base
 E32C				LPT_DETECT_LOOP:
 E32C  B0 0B				MOV	AL, MASK LCDR OR MASK LCINI-1	; use init byte - 1 as test data
 E32E  EE				OUT	DX, AL				; send to LPT data port
 E32F  42				INC	DX
 E330  42				INC	DX					; DX = control port
 E331  40				INC	AX					; AL = Strobe off / init (1100b)
 E332  EE				OUT	DX, AL				; send to LPT control port
 E333  4A				DEC	DX
 E334  4A				DEC	DX					; DX = data port
 E335  EC				IN	AL, DX				; read from LPT data port
 E336  34 0B				XOR	AL, MASK LCDR OR MASK LCINI-1	; valid port if same test data
 E338  75 06				JNZ	NO_LPT_PORT				; if not, not a valid port
 E33A  92				XCHG	AX, DX				; AX = detected port
 E33B  AB				STOSW 					; store to LPT BDA table
 E33C  92				XCHG	AX, DX
 E33D  80 07 40				ADD	BYTE PTR[BX], HIGH(1 SHL LPT)	; INC LPT port count in flags
 E340				NO_LPT_PORT:
 E340  FE CE				DEC	DH 					; DX = DX - 100H (LPT1-LPT2)
 E342  80 F9 03				CMP	CL, 3 				; is 3BCH (LPT1 next)?
 E345  75 03				JNE	NEXT_LPT_PORT			; if not, next
 E347  BA 0378				MOV	DX, LPT1				; restart at 378H: LPT1 data port
 E34A				NEXT_LPT_PORT:
 E34A  E2 E0				LOOP	LPT_DETECT_LOOP
				
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-67


 E34C				POST_DETECT_PORTS ENDP
				
				;----------------------------------------------------------------------------;
				; Reset Keyboard Interface
				;----------------------------------------------------------------------------;
				; http://minuszerodegrees.net/5160/keyboard/5160_keyboard_startup.jpg
				;
				; KB Status Port 61h high bits:
				; 01 - normal operation. wait for keypress, when one comes in,
				;		force data line low (forcing keyboard to buffer additional
				;		keypresses) and raise IRQ1 high
				; 11 - stop forcing data line low. lower IRQ1 and don't raise it again.
				;		drop all incoming keypresses on the floor.
				; 10 - lower IRQ1 and force clock line low, resetting keyboard
				; 00 - force clock line low, resetting keyboard, but on a 01->00 transition,
				;		IRQ1 would remain high
				;----------------------------------------------------------------------------;
 E34C				POST_KB_RESET PROC
 E34C  BA 0061				MOV	DX, PPI_B 				; DX = PPI port B (61H)
 E34F  EC				IN	AL, DX
 E350  24 3F				AND	AL, NOT (MASK PBKB OR MASK PBKC) ; keyboard clock hold LOW and enable
 E352  EE				OUT	DX, AL				; send to PPI port B
 E353  96				XCHG	AX, SI				; save modified PPI port B
				
				;----------------------------------------------------------------------------;
				; [31] - Set up and clear keyboard buffer
				;----------------------------------------------------------------------------;
 E354  B8 001E R			MOV	AX, OFFSET KB_BUF 		; AX = initial start of buffer
 E357  BF 001A R			MOV	DI, OFFSET KB_BUF_HD 		; DI = buffer head
 E35A  AB				STOSW 					; write to head pointer
 E35B  AB				STOSW 					; write to tail pointer
 E35C  BF 0080 R			MOV	DI, OFFSET KB_BUF_ST 		; setup buffer start and end
 E35F  AB				STOSW
 E360  B0 3E				MOV	AL, KB_BUF_END_B			; (AH already 00)
 E362  AB				STOSW						; DI = KB_BUF_ST + 4
				
				;----------------------------------------------------------------------------;
				; Hold clock low 20+ ms to signal keyboard to reset. Clear and re-enable.
				;
 E363  B0 1E				MOV	AL, 30				; I/O delay for at least 20ms
 E365  E8 E647 R			CALL	IO_DELAY_MS
 E368  96				XCHG	AX, SI				; restore modified PPI port B
				
 E369  0C C0				OR	AL, MASK PBKB OR MASK PBKC	; keyboard enable clock and clear
 E36B  EE				OUT	DX, AL				; send to PPI port B
 E36C  51				PUSH	CX					; give a little more time
 E36D  24 7F				AND	AL, NOT MASK PBKB			; keyboard enable (clear low)
 E36F  EE				OUT	DX, AL				; send to PPI port B
				
				;----------------------------------------------------------------------------;
				; Unmask KB interrupt IRQ1
				;
 E370  E4 21				IN	AL, INT_IMR 			; get PIC Port 1 INT mask
 E372  96				XCHG	AX, SI 				; SI = save previous INT mask
 E373  B0 FD				MOV	AL, NOT MASK IRQ1			; unmask only keyboard interrupt
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-68


 E375  E6 21				OUT	INT_IMR, AL
				
				;----------------------------------------------------------------------------;
				; Check if reset scan code was received
				;
				; Temporary INT_09_POST interrupt will set 4000H flag on BP
				; when IRQ1 is received with successful reset code of 0AAh
				;
							IF POST_TEST_KB NE 0
 E377  FB				STI 						; enable interrupts
 E378				KB_RESET_TEST:
					IO_DELAY_SHORT				; give a little more time
			     1				IF ARCH_TYPE NE ARCH_EMU 
 E378  EB 00                 1		JMP	SHORT ??0011 
 E37A                        1	??0011: 
			     1				ENDIF 
					POST_FLAG_TEST  PKI			; KB test flag yet?
			     1				ELSE 
 E37A  F7 C5 4000            1		TEST	BP, MASK PKI			; Is FLAG set? 
			     1				ENDIF 
 E37E  E1 F8				LOOPZ	KB_RESET_TEST			; Loop until KB flag OR CX is 0 (timeout)
 E380  FA				CLI 						; disable interrupts again
					POST_FLAG_FLIP  PKI			; invert PKI flag: 1 = error, 0 = success
			     1				ELSE 
 E381  81 F5 4000            1		XOR	BP, MASK PKI			; Invert flag 
			     1				ENDIF 
							ENDIF
					IO_DELAY_LONG 				; additional delay, CX = 0
			     1				IF ARCH_TYPE NE ARCH_EMU 
 E385  33 C9                 1		XOR	CX, CX 				; delay 65535 LOOPs 
			     1		IO_DELAY 
 E387                        2	??0012: 
 E387  E2 FE                 2		LOOP	??0012					; long delay for I/O 
			     1				ENDIF 
				
				;----------------------------------------------------------------------------;
				; Ack scan code, clear keyboard again and check that no scan codes were received
				;
 E389  EC				IN	AL, DX				; read PPI port B
 E38A  0C C0				OR	AL, MASK PBKB OR MASK PBKC	; keyboard enable clock and clear
 E38C  EE				OUT	DX, AL				; send to PPI port B
 E38D  59				POP	CX					; give a little more time
 E38E  24 7F				AND	AL, NOT MASK PBKB			; keyboard enable (clear low)
 E390  EE				OUT	DX, AL				; send to PPI port B
					IO_DELAY					; delay for KBC, CX = 0
 E391                        1	??0013: 
 E391  E2 FE                 1		LOOP	??0013					; long delay for I/O 
 E393  E4 60				IN	AL, PPI_A 				; check KB for extraneous key
							IF POST_TEST_KB NE 0	; all KB tests enabled?
							IF POST_TEST_KEY NE 0	; Key Stuck test enabled?
 E395  84 C0				TEST	AL, AL				; AL should be 0
 E397  74 04				JZ	KB_HAPPY				; if so, KB is ready
					POST_FLAG_SET  PKEY			; otherwise set flag for keyboard error
			     1				ELSE 
 E399  81 CD 2000            1		OR	BP, MASK PKEY			; Set FLAG 
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-69


			     1				ENDIF 
							ENDIF				; end Key Stuck test
							ENDIF
				
 E39D				KB_HAPPY:
				;----------------------------------------------------------------------------;
				; Disable keyboard for rest of POST
				;
 E39D  EC				IN	AL, DX
 E39E  0C C0				OR	AL, MASK PBKB OR MASK PBKC	; keyboard enable clock and clear
 E3A0  EE				OUT	DX, AL				; send to PPI port B
				
 E3A1  96				XCHG	AX, SI 				; restore interrupt mask register
 E3A2  E6 21				OUT	INT_IMR, AL
				
				;----------------------------------------------------------------------------;
				; Set up the real INT 09H keyboard interrupt handler
				;
							ASSUME ES:_IVT
 E3A4  8E C1				MOV	ES, CX 				; ES = IVT seg (CX is 0 from above)
 E3A6  BF 0024 R			MOV	DI, OFFSET IVT_09 		; DI = INT 9H offset in IVT (24H)
 E3A9  B8 E987 R			MOV	AX, OFFSET INT_09 		; Vector offset
 E3AC  AB				STOSW 					; replace in IVT
				
 E3AD				POST_KB_RESET ENDP
				
				;----------------------------------------------------------------------------;
				; Begin Hardware POST Test Results
				;----------------------------------------------------------------------------;
 E3AD  E8 F03B R			CALL	HIDE_CURSOR				; cursor movement is distracting
				
							IF POST_WARM_COLD EQ 1
				;----------------------------------------------------------------------------;
				; Display "WARM" or "COLD" boot
				;----------------------------------------------------------------------------;
				; Size: 38 bytes
				;----------------------------------------------------------------------------;
 E3B0				POST_BOOT_TYPE PROC
 E3B0  BE E8F6 R			MOV	SI, OFFSET POST_BOOT		; BOOT string
 E3B3  B3 04				MOV	BL, POST_CLR_WARM			; attribute to warm color
 E3B5  E8 F6D5 R			CALL	POST_START_COL_1			; display column label
											;  CX=POST_TAB_COL_I, SI=WARM string
					JWB	POST_BOOT_TYPE_OUT		; jump if warm boot
			     1				IF WARM_ENABLE EQ 1 
 E3B8  85 ED                 1		TEST	BP, BP				; is warm boot? 
 E3BA  78 05                 1		JS	POST_BOOT_TYPE_OUT					; jump if so 
			     1				ENDIF 
 E3BC  B3 09				MOV	BL, POST_CLR_COLD			; attribute to cold color
 E3BE  BE E900 R			MOV	SI, OFFSET POST_COLD		; COLD string
 E3C1				POST_BOOT_TYPE_OUT:
 E3C1  E8 F71C R			CALL	OUT_SZ_ATTR				; write string with attribute
 E3C4  E8 F70E R			CALL	POST_END_COL_NL			; end of column with NL and RET
				
 E3C7				POST_BOOT_TYPE ENDP
							ENDIF
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-70


				
				;----------------------------------------------------------------------------;
				; [17] Detect and test conventional memory
				;----------------------------------------------------------------------------;
 E3C7  E8 E562 R			CALL	DETECT_MEMORY			; detect and display memory count
							ASSUME ES:NOTHING		; ES clobbered by DETECT_MEMORY
				
							IF POST_TEST_DMA_TC0 EQ 1
				;----------------------------------------------------------------------------;
				; [27B] Verify that the 8237 DMA Channel 0 Terminal Count (TC 0) status bit 
				; is on. This test is only done on a cold boot.
				;----------------------------------------------------------------------------;
					JWB	DMA_STATUS_OK			; skip on warm boot
			     1				IF WARM_ENABLE EQ 1 
 E3CA  85 ED                 1		TEST	BP, BP				; is warm boot? 
 E3CC  78 0A                 1		JS	DMA_STATUS_OK					; jump if so 
			     1				ENDIF 
 E3CE  E4 08				IN	AL, DMA_CMD				; verify DMA status register
 E3D0  A8 01				TEST	AL, MASK TC0			; Channel 0 TC
 E3D2  75 04				JNZ	DMA_STATUS_OK			; jump if zero reached
					POST_FLAG_SET  PDMA			; else mark in POST error flags
			     1				ELSE 
 E3D4  81 CD 0400            1		OR	BP, MASK PDMA			; Set FLAG 
			     1				ENDIF 
 E3D8				DMA_STATUS_OK:
							ENDIF
				
							IF POST_CONFIG EQ 1
				;----------------------------------------------------------------------------;
				; Display Additional Configuration Items such as COM/LPT, CPU, FPU, etc
				;----------------------------------------------------------------------------;
 E3D8  E8 F5FD R			CALL	POST_SYS_CONFIG			; show CPU, FPU and ports
							ENDIF
				
 E3DB  E8 F032 R			CALL	CRLF_SHOW_CURSOR			; CRLF and re-enable cursor
				
				;----------------------------------------------------------------------------;
				; Unmask IRQs for Timer (IRQ0), Keyboard (IRQ1) and Floppy (IRQ6)
				;----------------------------------------------------------------------------;
 E3DE  E4 21				IN	AL, INT_IMR 			; get current OCW1/IMR register
 E3E0  24 BC				AND	AL, NOT (MASK IRQ6 OR MASK IRQ1 OR MASK IRQ0) ; unmask IR6, IR1, IR0
 E3E2  E6 21				OUT	INT_IMR, AL 			; send to A1 (Port 1)
				
				;----------------------------------------------------------------------------;
				; [28] Option ROM scan for other ROMs (storage, etc)
				;----------------------------------------------------------------------------;
 E3E4  B8 ---- R			MOV	AX, SEG _OPT_ROM			; start at 0C800H
 E3E7  BF FE00				MOV	DI, OPT_ROM_END			; end below 0FE00H
 E3EA  E8 E50B R			CALL	BIOS_ROM_SCAN			; scan for option ROMs, AL = 0
				
				;----------------------------------------------------------------------------;
				; [31] Enable interrupts
				;----------------------------------------------------------------------------;
 E3ED  FB				STI 						; Interrupts now enabled
				
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-71


				
				;----------------------------------------------------------------------------;
				; Detect and show hard drive info
				;----------------------------------------------------------------------------;
 E3EE				HDD_POST PROC
							IF POST_HD_CHECK EQ 1
 E3EE  98				CBW						; AH = 0 reset
 E3EF  B2 80				MOV	DL, 80H				; reset C: (80H)
 E3F1  CD 13				INT	13H
 E3F3  72 24				JC	HDD_POST_NONE			; if CF, no HD or reset failure
				
 E3F5  B2 80				MOV	DL, 80H
 E3F7  E8 E71E R			CALL	GET_DISK_PARAMS			; return # HD's in DX
 E3FA  72 1D				JC	HDD_POST_NONE
				
							IF POST_HD_COUNT EQ 1
				;----------------------------------------------------------------------------;
				; Display HDD POST drive count column
				;
							ELSE
					POST_COL_1	POST_HDD, POST_CLR_VAL2	; no FDC, display HDD in column 1
			     1			ELSE 
 E3FC  B3 0E                 1		MOV	BL, LOW POST_CLR_VAL2		; BL = attribute 
			     1			ENDIF 
 E3FE  BE E4F6 R             1		MOV	SI, OFFSET POST_HDD 
 E401  E8 F6D5 R             1		CALL	POST_START_COL_1 
							ENDIF
				
 E404  52				PUSH	DX					; save drive count
 E405  92				XCHG	AX, DX				; AL = drive count
 E406  E8 F79F R			CALL	NIB_HEX				; write as hex to console (clobs AX)
					POST_COL_END_NL				; end column
 E409  E8 F70E R             1		CALL	POST_END_COL_NL 
 E40C  59				POP	CX					; CX = drive count
 E40D  E3 0D				JCXZ	HDD_POST_DONE			; reset passed but 0 drives
				
							IF POST_HD_PARMS EQ 1
				;----------------------------------------------------------------------------;
				; Display HDD drive letter(s) and size(s)
				;	
 E40F  B2 80				MOV	DL, 80H				; start with drive 80H (C:)
 E411				HDD_POST_SHOW_LOOP:
 E411  E8 F863 R			CALL	SHOW_DISK_PARAMS			; show drive letter and geometry
 E414  42				INC	DX					; move to next drive
 E415  E2 FA				LOOP	HDD_POST_SHOW_LOOP
 E417  EB 03				JMP	SHORT HDD_POST_DONE
							ENDIF				; ENDIF POST_HD_PARMS EQ 1
							ENDIF				; ENDIF POST_HD_COUNT EQ 1
 E419				HDD_POST_NONE:
							ENDIF				; ENDIF POST_HD_CHECK EQ 1
 E419  E8 F757 R			CALL	CRLF
 E41C				HDD_POST_DONE:
 E41C				HDD_POST ENDP
				
				;----------------------------------------------------------------------------;
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-72


				; [39] Clear and enable I/O and parity NMIs
				;----------------------------------------------------------------------------;
 E41C  E8 E638 R			CALL	NMI_RESET				; reset NMI flags
				
				
				;----------------------------------------------------------------------------;
				; Enable keyboard
				;
 E41F  E8 E95F R			CALL	KB_BUF_CLEAR			; clear any stray keys in buffer
 E422  E4 61				IN	AL, PPI_B 				; AL = PB0 flags
 E424  24 7F				AND	AL, NOT MASK PBKB			; keyboard clear LOW (enable KB)
					IO_DELAY_SHORT
			     1				IF ARCH_TYPE NE ARCH_EMU 
 E426  EB 00                 1		JMP	SHORT ??0014 
 E428                        1	??0014: 
			     1				ENDIF 
 E428  E6 61				OUT	PPI_B, AL				; send to PPI port B
				
				;----------------------------------------------------------------------------;
				; Check for POST errors and clear warm boot flag
				;
 E42A  33 C0				XOR	AX, AX				; AX = 0
 E42C  A3 0072 R			MOV	WARM_FLAG, AX			; clear warm boot flag in BDA
					POST_FLAG_CLR  WARM, 1			; remove warm boot flag, NZ if error
			     1				IFNB <1> 
 = 0000                      1	??0015	EQU	0				; use AND instruction instead 
			     1				ENDIF 
			     1				ELSE 
 E42F  81 E5 7FFF            1		AND	BP, NOT MASK WARM			; Clear flag 
			     1				ENDIF 
 E433  74 20				JZ	POST_OK				; if no errors, go ahead and boot
				
				;----------------------------------------------------------------------------;
				; Display any POST errors
				;
 E435				POST_ERROR:
					PRINT_SZ  POST_ERR			; display "Post Error"
			     1			IFDIFI <POST_ERR>,<SI>			; if SZ is not SI 
 E435  BE E905 R             1		MOV	SI, OFFSET POST_ERR 
			     1			ENDIF 
 E438  E8 F72E R             1		CALL	OUT_SZ 
 E43B  8B C5				MOV	AX, BP				; AX = POST error flags
 E43D  E8 F78B R			CALL	WORD_HEX				; display POST error value
 E440  E8 F757 R			CALL	CRLF
 E443  E8 E92E R			CALL	POST_ERROR_MSG			; display POST error messages, BP=0
				
							IF POST_ERR_WAIT GT 0
				;----------------------------------------------------------------------------;
				; Wait for the Any Key if there was an error
				;
 E446  E8 E8C3 R			CALL	MEEPMEEP				; alert that there was an error, CX=0
					PRINT_SZ  NL_ANY_KEY			; "Any key" string
			     1			IFDIFI <NL_ANY_KEY>,<SI>			; if SZ is not SI 
 E449  BE E4A5 R             1		MOV	SI, OFFSET NL_ANY_KEY 
			     1			ENDIF 
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-73


 E44C  E8 F72E R             1		CALL	OUT_SZ 
 E44F  91				XCHG	AX, CX				; wait for key press (AH=0)
 E450  CD 16				INT	16H
 E452  E8 F757 R			CALL	CRLF					; move to next line
							ENDIF
				
 E455				POST_OK:
				;----------------------------------------------------------------------------;
				; Clear screen (partially or completely) and attempt boot
				;
 E455				CLEAR_POST_SCREEN:
 E455  B7 07				MOV	BH, 7					; attribute fill for on blank line
							ELSE				; clear only the lower two rows
 E457  B8 0702				MOV	AX, DBW <7, 2>			; AH = 7, scroll down 2 lines
 E45A  B9 1700				MOV	CX, DBW <23, 0>			; upper left row 23, column 0
							ENDIF
				
 E45D  BA 1950				MOV	DX, DBW <25, 80>			; lower right row 25, column 80
 E460  CD 10				INT	10H
				
				
 E462  E8 E8AE R			CALL	BEEP 					; beep to signify POST test is done
							ELSE
 E465  E8 F757 R			CALL	CRLF
							ENDIF
				
				;----------------------------------------------------------------------------;
				; [40] DO BOOTSTRAP!
				;----------------------------------------------------------------------------;
				
				;----------------------------------------------------------------------------;
				; Attempt to IPL three times. If failure, call INT 18h / ROM BASIC.
				; If INT_19_BOOT_HD is 1, BIOS will also attempt to IPL from 80h (C:)
				;
				
 E468  99				CWD						; start IPL from drive 00h (A:)
 E469				BOOT_DEVICE:
 E469  B9 0003				MOV	CX, 3 				; retry three times
 E46C				BOOT_RETRY:
 E46C  51				PUSH	CX					; save retry counter
 E46D  CD 19				INT	19H
					IO_DELAY_LONG				; delay between attempts
			     1				IF ARCH_TYPE NE ARCH_EMU 
 E46F  33 C9                 1		XOR	CX, CX 				; delay 65535 LOOPs 
			     1		IO_DELAY 
 E471                        2	??0016: 
 E471  E2 FE                 2		LOOP	??0016					; long delay for I/O 
			     1				ENDIF 
 E473  59				POP	CX					; restore retry counter
 E474  E2 F6				LOOP	BOOT_RETRY
				
 E476				TRY_INT_18:
 E476  CD 18				INT	18H					; Try vectored ROM BASIC or boot failure
											; INT 18h should never return...
											;  fall through just in case
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-74


				
				;----------------------------------------------------------------------------;
				; INT 18 - Unbootable IPL
				;----------------------------------------------------------------------------;
				; Display a disk boot failure message and wait for a key to cold reboot.
				;
				; This may be re-vectored to ROM BASIC, if present.
				;
				; Size: 18 bytes
				;----------------------------------------------------------------------------;
 E478				INT_18 PROC
					PRINT_SZ  BOOT_FAIL			; print boot failure string
			     1			IFDIFI <BOOT_FAIL>,<SI>			; if SZ is not SI 
 E478  BE E488 R             1		MOV	SI, OFFSET BOOT_FAIL 
			     1			ENDIF 
 E47B  E8 F72E R             1		CALL	OUT_SZ 
 E47E  33 C0				XOR	AX, AX				; AH = 0 (wait for key)
 E480  CD 16				INT	16H					; wait for key press
 E482  E9 E05B R			JMP	BOOT					; reboot
 E485				INT_18 ENDP
				
 E485				BOOT ENDP
				
				;----------------------------------------------------------------------------;
				;
				; END OF BIOS POST/BOOTSTRAP
				;
				;----------------------------------------------------------------------------;
				
						ASSUME DS:_BDA
 E485				STRINGS PROC
				
 E485				BANNER_STRINGS PROC
				;----------------------------------------------------------------------------;
				; Banner Strings
				;
 E485  0D 0A 00			NL_Z			DB	CR, LF, 0			; one NL, null term'd
 E488  44 69 73 6B 20 42	BOOT_FAIL		DB	'Disk Boot Fail.'
       6F 6F 74 20 46 61	
       69 6C 2E			
 E497  20 59 6F 75 20 6D				DB	' You monster.'
       6F 6E 73 74 65 72	
       2E			
 E4A4  0A			NL2_ANY_KEY		DB	LF
 E4A5  0D 0A			NL_ANY_KEY		DB	CR, LF
 E4A7  50 72 65 73 73 20	ANY_KEY		DB	'Press the Any Key...'
       74 68 65 20 41 6E	
       79 20 4B 65 79 2E	
       2E 2E			
 E4BB  00						DB	 0
 E4BC				BANNER_STRINGS ENDP
				
 E4BC				POST_STRINGS PROC
				;----------------------------------------------------------------------------;
				; POST Test Strings
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-75


				;
 E4BC  43 50 55 00		POST_CPU		DB	'CPU',  0			; 'CPU' followed by default
 E4C0  38 30 38 38 00					DB	'8088', 0			;  *must be after POST_CPU
 E4C5  46 50 55 00		POST_FPU		DB	'FPU',  0			; 'FPU' followed by default
 E4C9  38 30 38 37 00					DB	'8087', 0			;  *must be after POST_FPU
 E4CE  3A 00			POST_HD		DB	':',    0			; HD size letter display
 E4D0  20 4D 42						DB	' ', POST_M_UNIT		;  MB or MiB units display
 E4D3  00						DB	0				;  *must be after POST_HD
 E4D4  52 41 4D 00		POST_MEMORY		DB	'RAM',  0			; RAM Memory test
 E4D8  30 30 30 20 4B 42				DB	'000 ', POST_K_UNIT	;  and KB or KiB
 E4DE  20 4F 4B 00					DB	' OK',  0
 E4E2  32 38 36 00		POST_286		DB	'286', 0
 E4E6  56 32 30			POST_V20		DB	'V20'
 E4E9  00						DB	0
 E4EA  4C 50 54 00		POST_LPT		DB	'LPT',  0
 E4EE  43 4F 4D 00		POST_COM		DB	'COM',  0
 E4F2  46 44 44 00		POST_FDD		DB	'FDD',  0
 E4F6  48 44 44 00		POST_HDD		DB	'HDD',  0
 E4FA  20 5B 20 00		POST_LSEP		DB	POST_L, 0
 E4FE  20 5D 00			POST_RSEP		DB	POST_R, 0
				
				;----------------------------------------------------------------------------;
				; NMI strings - these must be contiguous
				;
 E501  49 4F			NMI_ERR_IO		DB	'IO'				; NMI I/O Error string
 E503  20 50 41 52 49 54	NMI_ERR_PAR		DB	' PARITY', 0		; NMI Parity Error
       59 00			
				
 E50B				POST_STRINGS ENDP
				
 E50B				STRINGS ENDP
				
				;============================================================================;
				;
				;		        * * *   P R O C s  &  I N T s  * * *
				;
				;============================================================================;
				
				;----------------------------------------------------------------------------;
				; Scan, checksum and call BIOS ROM init procedures
				;----------------------------------------------------------------------------;
				; Input:
				;	AX = starting segment
				;	DI = ending segment
				; Output:
				;	AX, DI = ending segment
				;	DF = 0
				;
				; Clobbers: AX, BX, SI (anything else the ROM might, except for DS, ES and BP)
				; Size: 67 bytes
				;----------------------------------------------------------------------------;
 E50B				BIOS_ROM_SCAN PROC
					PUSHX	BP, DS, ES				; call preserve these registers
			     1				IFNB <BP>			; exit if last reg 
 E50B  55                    1		PUSH	BP 					; push register and repeat 
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-76


			     1		PUSHX	DS, ES, , , , ,  
			     2				IFNB <DS>			; exit if last reg 
 E50C  1E                    2		PUSH	DS 					; push register and repeat 
			     2		PUSHX	ES, , , , , ,  
			     3				IFNB <ES>			; exit if last reg 
 E50D  06                    3		PUSH	ES 					; push register and repeat 
			     3		PUSHX	, , , , , ,  
			     3				ENDIF 
			     2				ENDIF 
			     1				ENDIF 
 E50E				CHECK_ROM:
 E50E  8E D8				MOV	DS, AX 				; DS = starting segment
 E510  93				XCHG	AX, BX				; BX = current DS segment
 E511  B8 0080				MOV	AX, KBP < 2 >			; next 2K segment boundary length
 E514  50				PUSH	AX					; save for use if no ROM found
 E515  33 F6				XOR	SI, SI 				; ROM offset to 0
 E517  AD				LODSW 					; AX = first word (must be 0AA55H)
 E518  3D AA55				CMP	AX, MAGIC_WORD			; is it an extension ROM?
 E51B  75 26				JNE	NEXT_ROM 				; if not, check next 2K block
 E51D				FOUND_ROM:
 E51D  AC				LODSB						; AL = ROM size in 512B blocks
 E51E  3C 00				CMP	AL, 0					; is size "reasonable"?
 E520  7E 21				JLE	NEXT_ROM				; if not 1-127, skip it
 E522  E8 E54E R			CALL	ROM_CHECKSUM 			; checksum ROM at DS:0, AX=bytes read
							IF POST_OPT_ROM
 E525  E8 F936 R			CALL	ROM_SCAN_POST			; show ROM offset, size and errors
							ENDIF
 E528  75 19				JNZ	NEXT_ROM				; if NZ, checksum failed, skip it
 E52A  5D				POP	BP					; discard previous boundary size
							ELSE
 E52B  B1 04				MOV	CL, 4					; 8088: 512 byte blocks to paragraph
 E52D  D3 E8				SHR	AX, CL
							ENDIF
 E52F  50				PUSH	AX					; replace next boundary with ROM size
				
				;----------------------------------------------------------------------------;
				; Call Option ROM's BIOS init routine
				;
				; Note: ROM init's can clobber any or all registers so important to save
				; any that are used here between calls.
				;
 E530  E4 21				IN	AL, INT_IMR 			; get current OCW1/IMR register
 E532  50				PUSH	AX					; save IMR
 E533  57				PUSH	DI					; save ROM scan ending segment
 E534  1E				PUSH	DS					; ROM init segment
 E535  56				PUSH	SI					; ROM init offset (always 03H)
 E536  8B EC				MOV	BP, SP				; DS:BP = FAR pointer to ROM init
 E538  FF 5E 00				CALL	DWORD PTR [BP]			; FAR CALL to option ROM init
 E53B  FA				CLI						; ensure interrupts are still disabled
 E53C  5B				POP	BX					; rebalance stack
 E53D  5B				POP	BX					; restore current DS segment
 E53E  5F				POP	DI					; restore ROM scan ending segment
 E53F  58				POP	AX					; restore IMR
 E540  E6 21				OUT	INT_IMR, AL				; reset IMR
 E542  FC				CLD						; ensure direction flag forward
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-77


 E543				NEXT_ROM:
 E543  58				POP	AX					; restore next boundary size
 E544  03 C3				ADD	AX, BX				; next boundary
 E546  3B C7				CMP	AX, DI 				; end of extension ROM regions?
 E548  72 C4				JB	CHECK_ROM 				; if not, check next
 E54A				ROM_SCAN_DONE:
					POPX	ES, DS, BP				; restore regs
			     1				IFNB <ES>			; exit if last reg 
 E54A  07                    1		POP	ES 					; pop register and repeat 
			     1		POPX	DS, BP, , , , ,  
			     2				IFNB <DS>			; exit if last reg 
 E54B  1F                    2		POP	DS 					; pop register and repeat 
			     2		POPX	BP, , , , , ,  
			     3				IFNB <BP>			; exit if last reg 
 E54C  5D                    3		POP	BP 					; pop register and repeat 
			     3		POPX	, , , , , ,  
			     3				ENDIF 
			     2				ENDIF 
			     1				ENDIF 
 E54D  C3				RET
 E54E				BIOS_ROM_SCAN ENDP
				
				;----------------------------------------------------------------------------;
				; Perform 8 bit Checksum on a ROM at DS:0000
				;----------------------------------------------------------------------------;
				; Input:
				;	DS = segment for ROM
				;	AL = ROM size in 512k blocks (1-127)
				; Output:
				;	ZF if checksum is valid
				;	AX = number of bytes read
				;	DX = 8 bit checksum remainder
				;
				; Size: 20 bytes
				;----------------------------------------------------------------------------;
 E54E				ROM_CHECKSUM PROC
							ASSUME DS:NOTHING
 E54E  51				PUSH	CX
 E54F  56				PUSH	SI
 E550  98				CBW					; AH = 0
 E551  99				CWD					; DL = 0 (accumulator for sum)
 E552  8B F2				MOV	SI, DX			; start at offset 0
 E554  86 C4				XCHG	AL, AH			; convert 512 byte blocks to 16 bit words
 E556  91				XCHG	AX, CX			; CX = size in 2 byte WORDs
 E557				CHECKSUM_LOOP:
 E557  AD				LODSW					; next two bytes into AL and AH
 E558  02 D0				ADD	DL, AL			; add both to sum
 E55A  02 D4				ADD	DL, AH			; ZF if sum is 0
 E55C  E2 F9				LOOP	CHECKSUM_LOOP		; loop through entire ROM
 E55E  96				XCHG	AX, SI			; AX = bytes read
 E55F  5E				POP	SI
 E560  59				POP	CX
 E561  C3				RET
 E562				ROM_CHECKSUM ENDP
				
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-78


				;----------------------------------------------------------------------------;
				; DETECT_MEMORY - Detect, test and clear RAM
				;----------------------------------------------------------------------------;
				; Attempt to determine how much RAM is installed using MEM_ADDR_TEST for 
				; more reliable memory detection.
				;
				; Output: Memory count to console
				; Clobbers: Everything except DS
				;
				; NOTE: Testing first two bytes of each block is problematic:
				; http://minuszerodegrees.net/5160/problems/5160_known_problems_issues.htm
				; http://minuszerodegrees.net/5160/problems/5160_ram_size_flaw.htm
				;----------------------------------------------------------------------------;
 E562				DETECT_MEMORY PROC
							ASSUME DS:_BDA, ES:NOTHING
 E562  1E				PUSH	DS
 E563  B8 ---- R			MOV	AX, SEG _BDA
 E566  8E D8				MOV	DS, AX
				
				;----------------------------------------------------------------------------;
				; 5150 or MAX_RAM_AUTO: get MAX RAM from MEM_SZ_PC
				;
							IF ARCH_TYPE EQ ARCH_5150 OR MAX_RAM_AUTO EQ 1
 E568  A1 0015 R			MOV	AX, MEM_SZ_PC			; SW2 RAM size in KB
								ELSE
 E56B  B1 04				MOV	CL, 4					; 8088: Number of 16KB RAM blocks
 E56D  D3 E8				SHR	AX, CL
								ENDIF
 E56F  91				XCHG	AX, CX				; CX = 16KB RAM blocks
 E570  49				DEC	CX					;  after first 16K block
							ENDIF
				
				;----------------------------------------------------------------------------;
				; Detect RAM size in 16K blocks
				;
 E571  BA 0400				MOV	DX, KBP < 16 >			; Start at second 16KB block para
 E574  8E C2				MOV	ES, DX				; ES = seg 0400H
 E576				BLOCK_LOOP:
 E576  E8 E5F8 R			CALL	MEM_ADDR_TEST			; address test on 16KB RAM block at ES
 E579  75 07				JNZ	BLOCK_LOOP_DONE			; exit loop if test failed
 E57B  80 C6 04				ADD	DH, HIGH KBP < 16 >		; add 400h paras (16 KB)
 E57E  8E C2				MOV	ES, DX
 E580  E2 F4				LOOP	BLOCK_LOOP				; loop until MAX_RAM
 E582				BLOCK_LOOP_DONE:
				
				;----------------------------------------------------------------------------;
				; Test and clear RAM, show memory count
				;
				; Input:
				;	ES/DX = highest memory segment detected
				;
				
							ELSE
 E582  B1 06				MOV	CL, 6					; 8088: shift right 6 times to get K
 E584  D3 EA				SHR	DX, CL
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-79


							ENDIF
 E586  89 16 0013 R			MOV	MEM_SZ_KB, DX 			; save to BDA
 E58A  8C C2				MOV	DX, ES				; DX = highest RAM segment detected
				
				;----------------------------------------------------------------------------;
				; Display RAM row
				;
					POST_COL_1	POST_MEMORY, POST_CLR_VAL1 ; display RAM column, SI returned
			     1			ELSE 
 E58C  B3 0A                 1		MOV	BL, LOW POST_CLR_VAL1		; BL = attribute 
			     1			ENDIF 
 E58E  BE E4D4 R             1		MOV	SI, OFFSET POST_MEMORY 
 E591  E8 F6D5 R             1		CALL	POST_START_COL_1 
											;  as POST_KB_OK (next string)
 E594  E8 F72E R			CALL	OUT_SZ				; display '000 KB OK'
					POST_COL_END				; end post column
 E597  E8 F713 R             1		CALL	POST_END_COL 
 E59A  33 DB				XOR	BX, BX				; BX = 0, memory test counter
 E59C  8E C3				MOV	ES, BX				; start at segment 0000
 E59E				ZERO_ALL_RAM:
 E59E  33 C0				XOR	AX, AX				; zero AX
 E5A0  83 C3 10				ADD	BX, 16				; increment memory count value
 E5A3  83 FB 64				CMP	BX, 100				; CF if two digit number
 E5A6  14 09				ADC	AL, POST_COL_VT			; space inner column for 2 or 3 digits
 E5A8  E8 F73D R			CALL	MOVE_COL				; move to start of inner column
 E5AB  53				PUSH	BX					; save RAM size
 E5AC  93				XCHG	AX, BX				; move RAM size to AX for display
 E5AD  E8 F768 R			CALL	OUT_DECU				; display AX as decimal
 E5B0  5B				POP	BX					; restore RAM size
 E5B1  8C C0				MOV	AX, ES				; AX = last segment tested
 E5B3  05 0400				ADD	AX, KBP < 16 >			; move to next 16K segment/block
 E5B6  3B C2				CMP	AX, DX				; is last segment of RAM?
 E5B8  73 0D				JNB	DONE_ZERO_ALL_RAM			; exit if end
 E5BA				ZERO_ALL_RAM_1:
 E5BA  8E C0				MOV	ES, AX				; ES = last segment tested
				
				
				;----------------------------------------------------------------------------;
				; Write 0's to all memory in this block
				;
 E5BC				ZERO_ALL_START:
 E5BC  33 C0				XOR	AX, AX 				; write zeros
 E5BE  B9 2000				MOV	CX, KBW < 16 >			; loop 16KB in WORDs
 E5C1  8B F8				MOV	DI, AX				; DI = beginning of segment
 E5C3  F3/ AB				REP	STOSW 				; write zero to next 16KB
 E5C5  EB D7				JMP	SHORT ZERO_ALL_RAM
 E5C7				DONE_ZERO_ALL_RAM:
				
				
				;----------------------------------------------------------------------------;
				; Done with DETECT_MEMORY
				;
 E5C7  1F				POP	DS
 E5C8  C3				RET
				
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-80


				;----------------------------------------------------------------------------;
				; Compare the result read from memory to the expected results to determine
				; which bit(s) did not match.
				;
				; Error will be displayed as SEG:OFF BBBB.
				;
				; - SEG: location/bank in memory of the failed IC, which can be calculated
				;   using the following:
				;   http://minuszerodegrees.net/5160/ram/5160_ram_201_error_breakdown.jpg
				; - OFF: offset where the failure occurred
				; - BBBB: bit pattern difference between what was expected and what was 
				;   read. This should reveal which IC in that bank failed.
				;----------------------------------------------------------------------------;
				; Input:
				; 	DL = 0 if no parity error, bit 7 or 6 set if error
				;
 E5C9				DETECT_MEMORY_ERR:
					POST_FLAG_SET  PMEM			; set POST Memory error flag
			     1				ELSE 
 E5C9  81 CD 0200            1		OR	BP, MASK PMEM			; Set FLAG 
			     1				ENDIF 
 E5CD  E8 F757 R			CALL	CRLF					; start on new line
					POST_COL_1	POST_ERR_ERR, RED
			     1			ELSE 
 E5D0  B3 0C                 1		MOV	BL, LOW RED		; BL = attribute 
			     1			ENDIF 
 E5D2  BE E90C R             1		MOV	SI, OFFSET POST_ERR_ERR 
 E5D5  E8 F6D5 R             1		CALL	POST_START_COL_1 
 E5D8  4F				DEC	DI					; move back to last address
 E5D9  4F				DEC	DI
 E5DA  26: 33 05			XOR	AX, ES:[DI]				; determine incorrect bit(s)
 E5DD  97				XCHG	AX, DI				; DI = bit pattern, AX = err offset
 E5DE  8C C3				MOV	BX, ES				; segment of error
 E5E0  E8 F77F R			CALL	DWORD_HEX				; write address
 E5E3  84 D2				TEST	DL, DL				; was there a parity error?
 E5E5  74 08				JZ	DETECT_MEMORY_ERR_2		; jump if not
					PRINT_SZ  NMI_ERR_PAR			; print 'PARITY'
			     1			IFDIFI <NMI_ERR_PAR>,<SI>			; if SZ is not SI 
 E5E7  BE E503 R             1		MOV	SI, OFFSET NMI_ERR_PAR 
			     1			ENDIF 
 E5EA  E8 F72E R             1		CALL	OUT_SZ 
 E5ED  EB 04				JMP	SHORT DETECT_MEMORY_ERR_DONE
 E5EF				DETECT_MEMORY_ERR_2:
 E5EF  97				XCHG	AX, DI				; restore failed bit pattern
 E5F0  E8 F78B R			CALL	WORD_HEX
 E5F3				DETECT_MEMORY_ERR_DONE:
					POST_COL_END
 E5F3  E8 F713 R             1		CALL	POST_END_COL 
 E5F6  EB CF				JMP	SHORT DONE_ZERO_ALL_RAM
 E5F8				DETECT_MEMORY ENDP
				
				;----------------------------------------------------------------------------;
				; Test Memory Address Lines on a 16KB block
				;----------------------------------------------------------------------------;
				; Write a byte to the first address in a segment and write a different
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-81


				; value with one address line toggled. Read back the values to ensure
				; they are both correct. Repeat 8 times for each starting bit.
				;
				; Input:
				;	ES = segment to test
				; Output:
				;	ZF if okay, NZ if fail
				;	BX = offset of failed byte/line, DI
				;
				; Clobbers AL
				;
				; Inspired by:
				; http://www.ganssle.com/testingram.htm
				; http://www.paul.de/tips/ramtest.htm
				; https://www.memtest86.com/tech_memtest-algoritm.html
				; Size: 38 bytes
				;----------------------------------------------------------------------------;
 E5F8				MEM_ADDR_TEST PROC
 E5F8  B0 01				MOV	AL, 1					; pattern to rotate
 E5FA  33 DB				XOR	BX, BX				; base address
 E5FC  BF 2000				MOV	DI, 2000H				; highest address in 16KB segment
 E5FF				MEM_ADDR_LOOP:
 E5FF  26: 88 07			MOV	ES:[BX], AL				; write to base address
 E602  F6 D0				NOT	AL					; invert value
 E604  26: 88 05			MOV	ES:[DI], AL				; write inverted value
 E607  F6 D0				NOT	AL					; revert value
 E609  26: 38 07			CMP	ES:[BX], AL				; is base value the same?
 E60C  75 0F				JNZ	MEM_ADDR_ERR			; jump if not
 E60E  F6 D0				NOT	AL					; invert value again
 E610  26: 38 05			CMP	ES:[DI], AL				; is second value the same?
 E613  75 08				JNZ	MEM_ADDR_ERR			; jump if not
 E615  F6 D0				NOT	AL					; revert value again
 E617  D0 C0				ROL	AL, 1					; walk test value
 E619  D1 EF				SHR	DI, 1					; move to next address line
 E61B  75 E2				JNZ	MEM_ADDR_LOOP			; loop until offset is 0
 E61D				MEM_ADDR_ERR:
 E61D  C3				RET
 E61E				MEM_ADDR_TEST ENDP
				
				;----------------------------------------------------------------------------;
				; Test a 16KB block of Memory at ES:0000
				;----------------------------------------------------------------------------;
				; Trivial read/write test - Write pattern RAM_TEST and reads it back, then 
				; repeat with inverse RAM_TEST. If NMI is on, this could trigger a parity
				; error.
				;
				; Input:
				; 	ES = segment to test
				; Output:
				;	ZF and AX = 0 if pass, NZ if fail
				;
				; Clobbers: AX, CX, DI
				;
				; Size: 26 bytes
				;----------------------------------------------------------------------------;
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-82


 E61E				MEM_TEST PROC
 E61E  B8 731D				MOV	AX, RAM_TEST			; test pattern
 E621  E8 E629 R			CALL	MEM_CHECK				; write and verify pattern
 E624  75 F7				JNZ	MEM_ADDR_ERR			; return if error
 E626  B8 8CE2				MOV	AX, NOT RAM_TEST			; inverted test pattern
				
				;----------------------------------------------------------------------------;
				; Write and verify a 16KB block of Memory at ES:0000
				;----------------------------------------------------------------------------;
				; Input:
				;	AX = pattern to write
				; 	ES = segment for test
				; Output:
				;	ZF and AX = 0 if pass, NZ if fail
				;
				; Clobbers: AX, CX, DI
				;----------------------------------------------------------------------------;	
 E629				MEM_CHECK PROC
 E629  B9 2000				MOV	CX, KBW < 16 >			; loop 16KB in WORDs
 E62C  33 FF				XOR	DI, DI 				; start at offset 0
 E62E  F3/ AB				REP	STOSW 				; write test pattern
 E630				MEM_TEST_VERIFY:
 E630  B5 20				MOV	CH, HIGH KBW < 16 >		; restart loop 16KB in WORDs
 E632  33 FF				XOR	DI, DI 				; start at offset 0
 E634  F3/ AF				REPZ	SCASW 				; loop until CX = 0 OR WORD is not AX
 E636  91				XCHG	AX, CX				; AX = 0 if success
 E637  C3				RET
 E638				MEM_CHECK ENDP
 E638				MEM_TEST ENDP
				
				;----------------------------------------------------------------------------;
				; Reset NMI enable flags
				;----------------------------------------------------------------------------;
				; Output:
				;	AL = current PPI B flags
				;
				; Size: 11 bytes
				;----------------------------------------------------------------------------;
 E638				NMI_RESET PROC
 E638  E4 61				IN	AL, PPI_B				; read current flags
 E63A  0C 30				OR	AL, MASK PBIO OR MASK PBPC	; parity, I/O flags high (disable)
 E63C  E6 61				OUT	PPI_B, AL				; write to PPI
 E63E  34 30				XOR	AL, MASK PBIO OR MASK PBPC	; flags low (enable)
 E640  E6 61				OUT	PPI_B, AL				; write to PPI
 E642  C3				RET
 E643				NMI_RESET ENDP
				
				;----------------------------------------------------------------------------;
				; Delay using PIT counter increments of 125 ms
				;----------------------------------------------------------------------------;
				; Input:
				;	AL = wait in 125 ms increments
				;
				; AX clobbered
				; Size: 53 bytes
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-83


				;----------------------------------------------------------------------------;
 E643				IO_WAIT_MS_125 PROC
 E643  B4 7D				MOV	AH, 125
 E645  F6 E4				MUL	AH				; AX = wait in 1 ms
				
				;----------------------------------------------------------------------------;
				; Delay using PIT counter increments of 1 ms
				;----------------------------------------------------------------------------;
				; - Calculate the total number of PIT ticks necessary (where 1,193,182 = 1s)
				; - Latch the PIT and draw down the countdown total on each read.
				; - Exit when countdown underflows.
				;
				; Note: Mode 3 (Square Wave) decements the readable counter by 2, so the
				; effective frequency of the counter is actually 2,386,364 Hz.
				;
				; Input:
				;	AX = wait in number of ms (clobbered)
				;
				; Based on contribution by @Raffzahn (under CC BY-SA 4.0):
				; https://retrocomputing.stackexchange.com/a/24874/21323
				;
				; https://stanislavs.org/helppc/8253.html
				;----------------------------------------------------------------------------;
 E647				IO_DELAY_MS PROC
 E647  53				PUSH	BX
 E648  BB 0952				MOV	BX, 1193 * 2		; 1,193,182 / 1000 ms * 2 = 2,386 ticks/ms
				
				;----------------------------------------------------------------------------;
				; Delay using PIT counter DX:AX number of ticks
				;----------------------------------------------------------------------------;
 E64B				IO_DELAY_TICK PROC
 E64B  51				PUSH	CX
 E64C  52				PUSH	DX
 E64D  F7 E3				MUL	BX				; DX:AX = countdown of PIT ticks to wait
 E64F  93				XCHG	AX, BX			; DX:BX = countdown ticks
 E650  E8 E665 R			CALL	IO_WAIT_LATCH		; AX = start read
 E653				IO_WAIT_MS_LOOP:
 E653  8B C8				MOV	CX, AX			; CX = last read
 E655  E8 E665 R			CALL	IO_WAIT_LATCH		; AX = current counter reading
 E658  2B C8				SUB	CX, AX			; CX = # of ticks elapsed since last reading
 E65A  2B D9				SUB	BX, CX			; subtract change in ticks from countdown
 E65C  83 DA 00				SBB	DX, 0				; borrow out of high word (if necessary)
 E65F  73 F2				JAE	IO_WAIT_MS_LOOP		; loop while countdown >= 0
 E661  5A				POP	DX
 E662  59				POP	CX
 E663  5B				POP	BX
 E664				IO_WAIT_MS_DONE:
 E664  C3				RET
				
				;----------------------------------------------------------------------------;
				; Latch PIT 0 and read counter to AX
				;----------------------------------------------------------------------------;
				; Output: AX = current counter
				; Time: 123 clock cycles (including CALL)
				;----------------------------------------------------------------------------;
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-84


 E665				IO_WAIT_LATCH PROC
 E665  B0 00				MOV	AL, PIT_CW <0, 0>		; Counter 0, Latch (00b)
 E667  9C				PUSHF					; save current IF
 E668  FA				CLI					; disable interrupts
 E669  E6 43				OUT	PIT_CTRL, AL		; Write command to CTC
 E66B  E4 40				IN	AL, PIT_CH0			; Read low byte of Counter 0 latch
 E66D  8A E0				MOV	AH, AL			; Save it
 E66F  E4 40				IN	AL, PIT_CH0			; Read high byte of Counter 0 latch
 E671  9D				POPF					; restore IF state
 E672  86 C4				XCHG	AL, AH			; convert endian
 E674  C3				RET
 E675				IO_WAIT_LATCH ENDP
 E675				IO_DELAY_TICK ENDP
 E675				IO_DELAY_MS ENDP
 E675				IO_WAIT_MS_125 ENDP
				
						ELSE
 =				IO_DELAY_MS_FDC	EQU IO_DELAY_MS
						ENDIF
				
				
				;
				; 40 BYTES HERE / 6 BYTES HERE 5150
				;
				BYTES_HERE	INT_19
 = 007D                      1	BYTES_HERE_INT_19 = INT_19-$ 
			     1			IFDEF BYTES_HERE_INT_19 
			     1			IF2 
			     1			ENDIF 
			     1			ENDIF 
				
				;----------------------------------------------------------------------------;
				; INT 19 - Bootstrap Loader
				;----------------------------------------------------------------------------;
				; IPL: track 0, sector 1 is loaded into address 0:7C00 and control 
				; is transferred.
				;
				; Input:
				; 	DL = physical drive where boot sector is located (00=A:,80h=C:)
				; Output:
				;	Transfer control to bootable MBR if success
				;	IRET if failure
				;
				; Clobbers AX, BX, CX, DH, DI, DS, ES
				;----------------------------------------------------------------------------;
 E6F2						ORG 0E6F2H
 E6F2				INT_19 PROC
						ASSUME DS:_IPL_SEG, ES:_IPL_SEG
 E6F2  FB				STI						; enable interrupts
 E6F3  FC				CLD						; clear direction for STOS
 E6F4  33 C9				XOR	CX, CX				; CX = 0
 E6F6  8E D9				MOV	DS, CX				; DS = IPL Segment (0000)
 E6F8  8E C1				MOV	ES, CX				; ES = IPL Segment (0000)
 E6FA  BF 0078 R			MOV	DI, OFFSET IVT_1E			; INT 1E vector table address
 E6FD  B8 EFC7 R			MOV	AX, OFFSET INT_1E 		; INT 1E DBT address
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-85


 E700  AB				STOSW
 E701  8C C8				MOV	AX, CS				; INT 1E DBT segment
 E703  AB				STOSW
 E704				INT_19_READ_MBR:
 E704  91				XCHG	AX, CX				; AH = 0 (reset)
 E705  CD 13				INT	13H					; reset disk 0
 E707  72 14				JC	INT_19_IPL_FAIL			; exit if error
 E709  B8 0201				MOV	AX, DBW <2, 1>			; AH = 2 (read), AL = 1 sector
 E70C  BB 7C00 R			MOV	BX, OFFSET IPL_TOP		; ES:BX = IPL boot sector offset
 E70F  B9 0001				MOV	CX, DBW <0, 1>			; CH = cyl 0, CL = sec 1
 E712  8A F5				MOV	DH, CH 				; DH = head 0, DL = drive #
 E714  CD 13				INT	13H					; read 1 sector into ES:BX
 E716  72 05				JC	INT_19_IPL_FAIL			; exit if error
 E718  EA 7C00 ---- R			JMP 	FAR PTR IPL_TOP 			; jump to IPL segment and boot!
 E71D				INT_19_IPL_FAIL:
 E71D  CF				IRET
						ASSUME DS:NOTHING, ES:NOTHING
 E71E				INT_19 ENDP
				
						IF POST_HD_CHECK EQ 1
				;----------------------------------------------------------------------------;
				;  Get Hard Drive Parameters
				;----------------------------------------------------------------------------;
				;  Input:
				;	DL = drive number
				;  Output:
				; 	CF if Error
				;	AL = number of heads (AX if no error)
				; 	AH = return code
				;	BX = last cylinder
				; 	CX = logical last index of sectors/track
				;	DX = number of hard disk drives (all)
				;----------------------------------------------------------------------------;
 E71E				GET_DISK_PARAMS PROC
 E71E  B4 08				MOV	AH, 8 			; Get Drive in DL Parameters: 
 E720  CD 13				INT	13H				;  CH = Last cyl, CL = # cylinders
										;  DH = heads, DL = # drives
										;  ES:DI = drive table
 E722  72 14				JC	GET_DISK_PARAMS_ERR 	; if error, exit
 E724  8B D9				MOV	BX, CX 			; BX = last cylinder
 E726  86 FB				XCHG	BH, BL 			; swap bytes
 E728  D0 C7				ROL	BH, 1 			; rotate high two bits into low bits
 E72A  D0 C7				ROL	BH, 1
 E72C  80 E7 03				AND	BH, 11B			; BX = cylinder (10 bits)
 E72F  83 E1 3F				AND	CX, 00111111B		; CX = logical last index of sectors/track
 E732  8A C6				MOV	AL, DH
 E734  40				INC	AX				; convert heads to 1 index (count)
 E735  43				INC	BX				; convert cylinders to 1 index
 E736  32 F6				XOR	DH, DH			; clear high byte of DX, CF = 0
 E738				GET_DISK_PARAMS_ERR:
 E738  C3				RET
 E739				GET_DISK_PARAMS ENDP
						ENDIF
				
				;
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-86


				; 0 BYTES HERE
				;
				BYTES_HERE	INT_14
 = 0000                      1	BYTES_HERE_INT_14 = INT_14-$ 
			     1			IFDEF BYTES_HERE_INT_14 
			     1			IF2 
			     1			ENDIF 
			     1			ENDIF 
				
				;----------------------------------------------------------------------------;
				; INT 14 - BIOS COM Port Services
				;----------------------------------------------------------------------------;
				;	INT 14,0  Initialize serial port parameters
				;	INT 14,1  Send/write character in AL
				;	INT 14,2  Receive/read character in AL
				;	INT 14,3  Get Serial port status
				;
				; All functions have:
				;	  AH = function number (bounds not checked)
				;	  AL = character to send or receive
				;	  DX = zero based RS232 card number
				;
				; All registers call-preserved (except AX)
				;----------------------------------------------------------------------------;
				; Ref:
				; https://stanislavs.org/helppc/int_14.html
				;----------------------------------------------------------------------------;
 E739						ORG 0E739H
 E739				INT_14 PROC
							ASSUME DS:_BDA
 E739  FB				STI 					; enable interrupts
 E73A  51				PUSH	CX 				; call-preserve CX
 E73B  B9 0003				MOV	CX, 3 			; will use this 3 in multiple places
 E73E  3B D1				CMP	DX, CX			; is port number valid?
 E740  77 53				JA	INT_14_EXIT 		; exit if port is > 3
					PUSHX	DI, BX, DX, DS		; call-preserve registers
			     1				IFNB <DI>			; exit if last reg 
 E742  57                    1		PUSH	DI 					; push register and repeat 
			     1		PUSHX	BX, DX, DS, , , ,  
			     2				IFNB <BX>			; exit if last reg 
 E743  53                    2		PUSH	BX 					; push register and repeat 
			     2		PUSHX	DX, DS, , , , ,  
			     3				IFNB <DX>			; exit if last reg 
 E744  52                    3		PUSH	DX 					; push register and repeat 
			     3		PUSHX	DS, , , , , ,  
			     4				IFNB <DS>			; exit if last reg 
 E745  1E                    4		PUSH	DS 					; push register and repeat 
			     4		PUSHX	, , , , , ,  
			     4				ENDIF 
			     3				ENDIF 
			     2				ENDIF 
			     1				ENDIF 
 E746  BF ---- R			MOV	DI, SEG _BDA 		; DS = BDA
 E749  8E DF				MOV	DS, DI
 E74B  8B FA				MOV	DI, DX 			; DI = COM port index (0-3)
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-87


 E74D  8B DF				MOV	BX, DI			; convert to word index
 E74F  99				CWD					; DX = 0
 E750  03 11				ADD	DX, [BX][DI]		; DX = 3F8/2F8 base port address
 E752  74 3D				JZ	INT_14_DONE 		; is port index valid (detected)?
 E754  3A E1				CMP	AH, CL			; check function number (CL = 3)
 E756  77 39				JA	INT_14_DONE			; > 3? Not valid
 E758  74 2D				JZ 	INT_14_3	 		; = 3 then status
 E75A  80 FC 01				CMP	AH, 1				; check remaining functions
 E75D  77 56				JA	INT_14_2 			; = 2 then read
 E75F  74 36				JZ	INT_14_1 			; = 1 then write
										; = 0 fall through to init
				
				;----------------------------------------------------------------------------;
				; INT 14,0  Initialize serial port parameters
				;----------------------------------------------------------------------------;
				; https://stanislavs.org/helppc/int_14-0.html
				; https://stanislavs.org/helppc/8250.html
				;----------------------------------------------------------------------------;
				; Baud rate divisor table:
				;	0 (000) = 110 baud -> 417H	|	4 (100) = 1200 baud -> 60H
				;	1 (001) = 150 baud -> 300H	|	5 (101) = 2400 baud -> 30H
				;	2 (010) = 300 baud -> 180H	|	6 (110) = 4800 baud -> 18H
				;	3 (011) = 600 baud -> 0C0H	|	7 (111) = 9600 baud -> 0CH
				;
				; Formula:
				;	if (baud == 110) then
				; 		divisor = 417H
				;	else
				;		divisor = 600H >> index
				;----------------------------------------------------------------------------;
				; Input:
				;	DX = base port address
				;	AL = port params, AH = 0
				;	CX = 3 (from earlier)
				;----------------------------------------------------------------------------;
				
 E761				INT_14_0 PROC
				;----------------------------------------------------------------------------;
				; Set baud rate
				;
 E761  8B FA				MOV	DI, DX 			; DX = 3F8/2F8 base port
 E763  03 D1				ADD	DX, CX			; DX = 3FB/2FB Line Control Register (LCR), CX = 3
 E765  93				XCHG	AX, BX			; save port params to BL
 E766  B0 80				MOV	AL, MASK DLAB 		; set baud rate divisor (DLAB); 0 = RBR, THR or IER
 E768  EE				OUT	DX, AL 			; write to 3FB/2FB (LCR)
 E769  D3 E3				SHL	BX, CL 			; BH = baud rate, CL = 3
 E76B  D2 EB				SHR	BL, CL 			; BL = flags
 E76D  B8 0417				MOV	AX, 417H 			; divisor for 110 baud
 E770  8A CF				MOV	CL, BH 			; CL = shift counter or 0 for 110 baud (CH = 0)
 E772  E3 05				JCXZ	INT_14_0_SET_BAUD		; Jump if 110 baud
 E774  B8 0600				MOV	AX, 600H 			; AX = divisor base (see above formula)
 E777  D3 E8				SHR	AX, CL			; divisor = 600H >> CL
 E779				INT_14_0_SET_BAUD:
 E779  87 D7				XCHG	DX, DI 			; DX = 3F8/2F8, DI = 3FB/2FB (4)
										; AL = Divisor LSB, AH = Divisor MSB (4)
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-88


 E77B  EF				OUT	DX, AX			; write LSB, then MSB to ports 3F8/3F9
				;----------------------------------------------------------------------------;
				; Set parity, stop and word bits
				; 
 E77C				INT_14_0_SET_PSW:
 E77C  93				XCHG	AX, BX 			; AL = parity, stop and word bits (4)
 E77D  87 D7				XCHG	DX, DI 			; DX = 3FB/2FB, DI = 3F8/2F8 (4)
 E77F  EE				OUT	DX, AL			; set LCR parity, stop and word bits
 E780  87 D7				XCHG	DX, DI 			; DX = 3F8/2F8, DI = 3FB/2FB (4)
				;----------------------------------------------------------------------------;
				; Disable IER
				;
 E782  33 C0				XOR	AX, AX 			; AL = 0 (3)
 E784  42				INC	DX 				; DX = 3F9/2F9 (3)
 E785  EE				OUT	DX, AL			; DX = 3F9 - Interrupt Enable Register (IER) disabled
 E786  4A				DEC	DX 				; DX = 3F8 (3)
										; fall through to get status
				
				;----------------------------------------------------------------------------;
				; INT 14,3  Get Serial port status
				;----------------------------------------------------------------------------;
				; Input:
				; 	DX = base port address
				; Output:
				;	AH = port status
				;	AL = modem status
				;----------------------------------------------------------------------------;
 E787				INT_14_3 PROC
 E787  83 C2 05				ADD	DX, COM1_LSR-COM1_DATA	; DX = 3FD/2FD LSR - Line Status Register
 E78A  53				PUSH	BX				; delay for I/O
 E78B  EC				IN	AL, DX 			; get line/port status 
 E78C  86 E0				XCHG	AH, AL 			; save to AH
 E78E  42				INC	DX 				; DX = 3FE/2FE MSR - Modem Status Register
 E78F  5B				POP	BX 				; delay for I/O
 E790  EC				IN	AL, DX 			; get modem status 
 E791				INT_14_3 ENDP
				
 E791				INT_14_DONE PROC
					POPX	DS, DX, BX, DI		; restore all registers
			     1				IFNB <DS>			; exit if last reg 
 E791  1F                    1		POP	DS 					; pop register and repeat 
			     1		POPX	DX, BX, DI, , , ,  
			     2				IFNB <DX>			; exit if last reg 
 E792  5A                    2		POP	DX 					; pop register and repeat 
			     2		POPX	BX, DI, , , , ,  
			     3				IFNB <BX>			; exit if last reg 
 E793  5B                    3		POP	BX 					; pop register and repeat 
			     3		POPX	DI, , , , , ,  
			     4				IFNB <DI>			; exit if last reg 
 E794  5F                    4		POP	DI 					; pop register and repeat 
			     4		POPX	, , , , , ,  
			     4				ENDIF 
			     3				ENDIF 
			     2				ENDIF 
			     1				ENDIF 
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-89


				
 E795				INT_14_EXIT:
 E795  59				POP	CX
 E796  CF				IRET
 E797				INT_14_DONE ENDP
				
 E797				INT_14_0 ENDP
				
				;----------------------------------------------------------------------------;
				; INT 14, 1 - Send/write character in AL
				;----------------------------------------------------------------------------;
				; Input:
				; 	DX = base port address
				;	BL = port timeout
				;----------------------------------------------------------------------------;
 E797				INT_14_1 PROC
 E797  52				PUSH	DX 					; save base port
 E798  50				PUSH	AX
 E799  83 C2 04				ADD	DX, COM1_MCR-COM1_DATA		; DX = 3FC/2FC - Modem Control Register
 E79C  B0 03				MOV	AL, MASK RTS OR MASK DTR	; activate DTR & RTS
 E79E  EE				OUT	DX, AL				; set DTR or RTS
 E79F  42				INC	DX
 E7A0  42				INC	DX 					; DX = 3FE - Modem Status Register
 E7A1  BB 3020				MOV	BX, DBW <MASK THRE OR MASK LBI, MASK MDSR> ; BH = line (THRE)
											;  BL = modem (DSR/CTS)
 E7A4  E8 E7CB R			CALL	INT_14_POLL 			; poll both registers, AH = status
 E7A7  5B				POP	BX
 E7A8  8A C3				MOV	AL, BL 				; AL = output char
 E7AA  5A				POP	DX 					; restore base port
 E7AB  75 03				JNZ	INT_14_RW_ERR			; Jump if port timeout
 E7AD  EE				OUT	DX, AL
 E7AE  EB E1				JMP	SHORT INT_14_DONE
 E7B0				INT_14_RW_ERR:
 E7B0  80 CC 80				OR	AH, 10000000B			; set error bit
 E7B3  EB DC				JMP	SHORT INT_14_DONE
 E7B5				INT_14_1 ENDP
				
				;----------------------------------------------------------------------------;
				; INT 14, 2 - Receive/read character in AL
				;----------------------------------------------------------------------------;
				; Input:
				;	DX = base port address
				;	BL = port timeout
				; Output:
				;	AH = port status
				;	AL = character read
				;	NZ = timeout or failure occurred
				;
				; Clobbers: BX
				;----------------------------------------------------------------------------;
 E7B5				INT_14_2 PROC
 E7B5  52				PUSH	DX 					; save base port
 E7B6  83 C2 04				ADD	DX, COM1_MCR-COM1_DATA		; DX = 3FC/2FC - Modem Control Register
 E7B9  B0 01				MOV	AL, MASK DTR			; activate DTR
 E7BB  EE				OUT	DX, AL				; set DTR
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-90


 E7BC  42				INC	DX
 E7BD  42				INC	DX 					; DX = 3FE/2FE - Modem Status Register
 E7BE  BB 2001				MOV	BX, DBW <MASK MDSR, MASK LDR>	; BH = modem (DSR), BL = line (data ready)
 E7C1  E8 E7CB R			CALL	INT_14_POLL 			; poll both registers, AH = status
 E7C4  5A				POP	DX 					; restore base port
 E7C5  80 E4 1E				AND	AH, MASK LBI OR MASK LFE OR MASK LPE OR MASK LOE ; include only 
											;  error bits in port status
 E7C8  EC				IN	AL, DX				; read char from buffer
 E7C9  EB C6				JMP	SHORT INT_14_DONE
 E7CB				INT_14_2 ENDP
				
				;----------------------------------------------------------------------------;
				; INT 14 - Poll line then modem status registers
				;----------------------------------------------------------------------------;
				; Input:
				;	DI = port index (0 based byte)
				; 	DX = 3FE Modem Status Register
				;	BL = line status expected masked
				;	BH = modem status expected masked
				; Output:
				;	AH = port status
				;	DX = 3FD Line Status Register
				;	NZ = timeout or failure occurred
				;
				; Clobbers: AX, CX
				;----------------------------------------------------------------------------;
 E7CB				INT_14_POLL PROC
 E7CB  E8 E7D3 R			CALL	INT_14_POLL_PORT 		; first poll modem status
 E7CE  75 1A				JNZ	INT_14_POLL_RET  		; jump if ZF = 0, timeout or failure occurred
 E7D0  86 FB				XCHG	BH, BL 			; BH = line status
 E7D2  4A				DEC	DX				; DX = 3FD Line Status Register (LSR)
				
				;----------------------------------------------------------------------------;
				; INT 14 - Poll status register in DX
				;----------------------------------------------------------------------------;
 E7D3				INT_14_POLL_PORT PROC
 E7D3  56				PUSH	SI 				; call-preserve SI
 E7D4  33 C9				XOR	CX, CX			; reset poll loop counter
 E7D6  8A 45 7C				MOV	AL, COM_TIME_B[DI]	; AL = port timeout (< 127)
 E7D9  98				CBW					; zero extend AX
 E7DA  96				XCHG	AX, SI 			; SI = port timeout
 E7DB				INT_14_POLL_LOOP:
 E7DB  EC				IN	AL, DX 			; check port status
 E7DC  8A E0				MOV	AH, AL 			; save to AH
 E7DE  32 C7				XOR	AL, BH 			; mask result bits
 E7E0  84 C7				TEST	AL, BH 			; did it match expected result?
 E7E2  74 05				JZ	INT_14_POLL_DONE
 E7E4  E2 F5				LOOP	INT_14_POLL_LOOP		; poll port 65,535 * timeout times
 E7E6  4E				DEC	SI 				;
 E7E7  75 F2				JNZ	INT_14_POLL_LOOP		; Jump if timeout not expired
 E7E9				INT_14_POLL_DONE:
 E7E9  5E				POP	SI
 E7EA				INT_14_POLL_RET:
 E7EA  C3				RET
 E7EB				INT_14_POLL_PORT ENDP
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-91


 E7EB				INT_14_POLL ENDP
				
 E7EB				INT_14 ENDP
				
				;----------------------------------------------------------------------------;
				; I/O port register test
				;----------------------------------------------------------------------------;
				; Do a Walking Bit/March test on I/O port registers.
				;
				; Input:
				;	DX = starting port
				;	AH = number of sequential ports to test
				; Output:
				;	ZF and CX = 0 if success
				;	NZ if failed
				;
				; Adapted from:
				; https://barrgroup.com/embedded-systems/how-to/memory-test-suite-c
				; https://www.edaboard.com/threads/walking-1-0-test-for-memory-bist.241278/
				;
				; Size: 47 bytes
				; Clobbers AX, BX, CX, DX, DI
				;----------------------------------------------------------------------------;
 E7EB				PORT_TEST PROC
 E7EB  B7 01				MOV	BH, 1				; start with low order bit
 E7ED  33 C9				XOR	CX, CX			; clear counter
 E7EF  8B FA				MOV	DI, DX			; save starting port
				
				;----------------------------------------------------------------------------;
				; Write a single 1 bit to a different position in each register
				;
 E7F1				WB_WRITE_1:
 E7F1  8A CC				MOV	CL, AH			; register counter
 E7F3  8B D7				MOV	DX, DI 			; start at first register
 E7F5  8A C7				MOV	AL, BH			; AL = starting bit to write
 E7F7				WB_WRITE_LOOP:
 E7F7  EE				OUT	DX, AL			; write to low byte
					IO_DELAY_SHORT
			     1				IF ARCH_TYPE NE ARCH_EMU 
 E7F8  EB 00                 1		JMP	SHORT ??0019 
 E7FA                        1	??0019: 
			     1				ENDIF 
 E7FA  EE				OUT	DX, AL			; write to high byte
 E7FB  42				INC	DX				; next register/port
 E7FC  D0 C0				ROL	AL, 1				; walk bit to next position
 E7FE  E2 F7				LOOP	WB_WRITE_LOOP
				
				;----------------------------------------------------------------------------;
				; Read back bit pattern from each register
				;
 E800  8A CC				MOV	CL, AH			; register counter
 E802  8B D7				MOV	DX, DI 			; start at first register
 E804  8A DF				MOV	BL, BH			; BL = starting bit to compare
 E806				WB_READ_LOOP:
 E806  EC				IN	AL, DX			; read low byte
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-92


 E807  3A C3				CMP	AL, BL			; compare to correct bit
 E809  75 0E				JNZ	PORT_TEST_DONE		; jump if not okay
 E80B				WB_LOW_CHECK_OK:
 E80B  EC				IN	AL, DX			; read high byte
 E80C  3A C3				CMP	AL, BL			; compare to correct bit
 E80E  75 09				JNZ	PORT_TEST_DONE		; jump if not okay
 E810  42				INC	DX				; next register/port
 E811  D0 C3				ROL	BL, 1				; rotate for next register/bit
 E813  E2 F1				LOOP	WB_READ_LOOP		; loop all eight registers
 E815  D0 E7				SHL	BH, 1				; rotate to next starting bit
 E817  75 D8				JNZ	WB_WRITE_1			; loop until BH = 0
 E819				PORT_TEST_DONE:
 E819  C3				RET
 E81A				PORT_TEST ENDP
							IF POST_VIDEO_TYPE EQ 1
				;----------------------------------------------------------------------------;
				; POST Video Adapter Type Strings
				; 17 bytes
				;
 E81A  56 47 41 00		POST_VGA		DB	'VGA', 0
 E81E  45 47 41 00		POST_EGA		DB	'EGA', 0
 E822  43 47 41 00		POST_CGA		DB	'CGA', 0
 E826  4D 6F 6E 6F 00		POST_MDA		DB	'Mono', 0
							ENDIF
				
				;----------------------------------------------------------------------------;
				; POST Initial INT 10H Video Mode to BIOS video equipment type
				;
 E82B  01 03 07			VID_MODE_TBL	DB	1, 3, 7	; Color 40x25, Color 80x25, Mono 80x25
				
				;
				; 0 BYTES HERE
				;
				BYTES_HERE	INT_16
 = 0000                      1	BYTES_HERE_INT_16 = INT_16-$ 
			     1			IFDEF BYTES_HERE_INT_16 
			     1			IF2 
			     1			ENDIF 
			     1			ENDIF 
				
				;----------------------------------------------------------------------------;
				; INT 16 - Keyboard BIOS Services
				;----------------------------------------------------------------------------;
				;	INT 16,0	Wait for keystroke and read
				;	INT 16,1	Get keystroke status
				;	INT 16,2	Get shift status
				; Enhanced:
				;	INT 16,5	Keyboard buffer write
				;	INT 16,10	Wait for keystroke and read
				;	INT 16,11	Get keystroke status
				;	INT 16,12	Get shift status
				;----------------------------------------------------------------------------;
 E82E						ORG 0E82EH
 E82E				INT_16 PROC
						ASSUME DS:_BDA
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-93


 E82E  FB				STI					; necessary?
 E82F  FC				CLD
 E830  1E				PUSH	DS
 E831  56				PUSH	SI
 E832  BE ---- R			MOV	SI, SEG _BDA
 E835  8E DE				MOV	DS, SI 			; DS = BDA segment
 E837  80 FC 02				CMP	AH, 2
 E83A  74 33				JE	KB_SHIFT_STATUS 		; AH = 2 - Get Shift Status
 E83C  77 2E				JA	INT_16_DONE			; AH > 2 - Not valid, exit
 E83E  7B 15				JNP	KB_WAIT_READ_1		; AH = 0 - Wait for keystroke and read
										; AH = 1 - Get keystroke (fall through)
				
				;----------------------------------------------------------------------------;
				; AH = 1 - Get keystroke status
				;----------------------------------------------------------------------------;
				; Check if a key press is in buffer and return. Does not wait or remove.
				; Output:
				;	ZF = 0 if a key pressed (even Ctrl-Break)
				;	AH = scan code
				;	AL = ASCII character or zero if special function key
				;----------------------------------------------------------------------------;
				;	KB_BUF_HD (1Ah) = "head" next character stored in keyboard buffer
				;	KB_BUF_TL (1Ch) = "tail" next spot available in keyboard buffer
				;----------------------------------------------------------------------------;
 E840				KB_KEY_STATUS PROC
 E840  BE 001A R			MOV	SI, OFFSET KB_BUF_HD 	; SI = head ptr
 E843  FA				CLI 					; disable interrupts (already off)
 E844  AD				LODSW 				; AX = head, SI = tail ptr
 E845  3B 04				CMP	AX, [SI]	 		; head == tail?
 E847  75 06				JNE	KB_BUF_HAS_KEY 		; if not, buffer has a key
 E849				KB_KEY_STATUS_DONE:
 E849  FB				STI					; re-enable interrupts
 E84A  5E				POP	SI
 E84B  1F				POP	DS
					IRET_F				; IRET with current flags
 E84C  CA 0002               1		RETF	2 
 E84F				KB_BUF_HAS_KEY:
 E84F  96				XCHG	AX, SI 			; SI = head
 E850  AD				LODSW 				; AX = buffer[head], SI = next
 E851  EB F6				JMP	KB_KEY_STATUS_DONE
 E853				KB_KEY_STATUS ENDP
				
				;----------------------------------------------------------------------------;
				; AH = 0 - Wait for keystroke and read
				;----------------------------------------------------------------------------;
				; Wait until keystroke is in buffer. Key press is removed from buffer.
				; Output:
				;	AH = scan code
				;	AL = ASCII code
				;----------------------------------------------------------------------------;
 E853				KB_WAIT_READ PROC
 E853  FB				STI					; enable interrupts
						IF KB_HLT_WAIT EQ 1
 E854  F4				HLT					; wait for keystroke interrupt
						ENDIF
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-94


 E855				KB_WAIT_READ_1:
 E855  BE 001A R			MOV	SI, OFFSET KB_BUF_HD 	; SI = head ptr
 E858  FA				CLI 					; disable interrupts again
 E859  AD				LODSW 				; AX = head, SI = tail ptr
 E85A  3B 04				CMP	AX, [SI] 			; head == tail?
 E85C  74 F5				JE	KB_WAIT_READ 		; if so, buffer is empty
 E85E  96				XCHG	AX, SI 			; SI = tail
 E85F  AD				LODSW 				; AX = buffer[tail], SI = next
 E860  83 FE 3E				CMP	SI, KB_BUF_END_B		; is next >= end of buffer?
 E863  72 03				JB	KB_GET_READ 		; if not, get tail value
 E865  BE 001E R			MOV	SI, OFFSET KB_BUF 	; otherwise, wrap next to buffer top
 E868				KB_GET_READ:
 E868  89 36 001A R			MOV	KB_BUF_HD, SI 		; head ptr = next
 E86C				INT_16_DONE:
 E86C  5E				POP	SI
 E86D  1F				POP	DS
 E86E  CF				IRET
 E86F				KB_WAIT_READ ENDP
				
				;----------------------------------------------------------------------------;
				; AH = 2 - Get shift status
				;----------------------------------------------------------------------------;
				; Read Keyboard Flags
				; Output:
				;	AL = BIOS keyboard flags (from BDA 0040:0017)
				;----------------------------------------------------------------------------;
 E86F				KB_SHIFT_STATUS PROC
 E86F  A0 0017 R			MOV	AL, KB_FLAGS1
 E872  EB F8				JMP	SHORT INT_16_DONE
 E874				KB_SHIFT_STATUS ENDP
				
 E874				INT_16 ENDP
				
 E874				BEEP_PROC PROC
				
				;----------------------------------------------------------------------------;
				; Repeats LONG_BEEPs then SHORT_BEEPs indefinetly
				;----------------------------------------------------------------------------;
				; Input:
				;	BL low nibble = long beeps
				;	BL high nibble = short beeps
				;
				; Note: must use LOOP for beep since BEEP could occur if PIT is not working
				;  (then how does the speaker work?)
				; Note 2: cannot use stack since HALT_BEEP could occur before stack
				;
				; Size: 60 bytes
				;----------------------------------------------------------------------------;
 E874				HALT_BEEP PROC
 E874  8C CA				MOV	DX, CS 				; SS to CS
 E876  8E D2				MOV	SS, DX				; for CALL_NS
 E878  93				XCHG	AX, BX				; beep pattern to AL
					POST_CODE					; optionally display beep code on POST card
					AAM_I	10H					; split nibbles
 E879  D4 10                 1		DB	0D4H, 10H			; AAM	imm 
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-95


 E87B  95				XCHG	AX, BP				; BP(H) = short beeps, BP(L) = long beeps
 E87C				HALT_BEEP_START:
 E87C  8B D5				MOV	DX, BP 				; restore original beep pattern
 E87E  BE 08E8				MOV	SI, BEEP_ERR_LOW			; low C5
 E881  33 C9				XOR	CX, CX				; low beep on 100%
 E883				HALT_BEEP_START_ODD:
 E883  8B F9				MOV	DI, CX				; save counter length
 E885				HALT_BEEP_REP:
 E885  8B C6				MOV	AX, SI				; restore beep tone
					CALL_NS  BEEP_ON_P, 1			; turn on speaker / beep
 E887  BC E88C R             1		MOV	SP, OFFSET ??001B 
			     1				IFNB <1> 
 E88A  EB 50                 1		JMP	SHORT BEEP_ON_P 
			     1				ENDIF 
 E88C                        1	??001B: 
 E88C  E88E R                1		DW	OFFSET ??001C 
 E88E                        1	??001C: 
 E88E  8B CF				MOV	CX, DI				; reset counter
					IO_DELAY					; delay for beep
 E890                        1	??001D: 
 E890  E2 FE                 1		LOOP	??001D					; long delay for I/O 
					CALL_NS  BEEP_OFF_P, 1			; turn off speaker
 E892  BC E897 R             1		MOV	SP, OFFSET ??001E 
			     1				IFNB <1> 
 E895  EB 5A                 1		JMP	SHORT BEEP_OFF_P 
			     1				ENDIF 
 E897                        1	??001E: 
 E897  E899 R                1		DW	OFFSET ??001F 
 E899                        1	??001F: 
 E899  2B CF				SUB	CX, DI				; set for remainder of counter
					IO_DELAY					; delay for silence
 E89B                        1	??0020: 
 E89B  E2 FE                 1		LOOP	??0020					; long delay for I/O 
 E89D  FE CA				DEC	DL					; dec beep repeat count
 E89F  75 E4				JNZ	HALT_BEEP_REP			; jump if more of this length
 E8A1  86 D6				XCHG	DL, DH				; swap beep counts
 E8A3  85 D2				TEST	DX, DX				; both cycles done?
 E8A5  74 D5				JZ	HALT_BEEP_START			; if so, restart beep pattern
 E8A7  B5 55				MOV	CH, 100H * 1/3			; else, short beep on 33%
 E8A9  BE 06AC				MOV	SI, BEEP_ERR_HIGH			; high F5
 E8AC  EB D5				JMP	SHORT HALT_BEEP_START_ODD	; start short cycle
 E8AE				HALT_BEEP ENDP
				
				;----------------------------------------------------------------------------;
				; Make a beepin' beep
				;----------------------------------------------------------------------------;
				; Play a (correctly pitched) A6 for 250ms
				;----------------------------------------------------------------------------;
 E8AE				BEEP PROC
 E8AE  50				PUSH	AX
 E8AF  53				PUSH	BX
					BEEP_ON
			     1			ELSE 
 E8B0  B8 054C               1		MOV	AX, BEEP_DEFAULT 
			     1			ENDIF 
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-96


 E8B3  E8 E8DC R             1		CALL	BEEP_ON_P 
 E8B6  B0 02				MOV	AL, 2				; 1/4 second pause
 E8B8  E8 E643 R			CALL	IO_WAIT_MS_125
					BEEP_OFF
 E8BB  E8 E8F1 R             1		CALL	BEEP_OFF_P 
 E8BE  5B				POP	BX
 E8BF  58				POP	AX
 E8C0  C3				RET
 E8C1				BEEP ENDP
				
				;----------------------------------------------------------------------------;
				; Two very short beeps if ZF, one short if NZ
				;----------------------------------------------------------------------------;
 E8C1				MEEPMEEP_Z PROC
 E8C1  75 03				JNZ	MEEP				; if ZF=0, skip first meep
				
				;----------------------------------------------------------------------------;
				; Two very short beeps
				; Size: 27 bytes
				; Output: CX = 0
				;----------------------------------------------------------------------------;
							IF IS_TURBO
 = 0040				MEEP_DELAY	EQU	40H
							ENDIF
 E8C3				MEEPMEEP PROC
 E8C3  E8 E8C6 R			CALL MEEP				; first meep
				
				;----------------------------------------------------------------------------;
				; One very short beep
				;----------------------------------------------------------------------------;
 E8C6				MEEP PROC
 E8C6  50				PUSH	AX
 E8C7  53				PUSH	BX
					BEEP_ON
			     1			ELSE 
 E8C8  B8 054C               1		MOV	AX, BEEP_DEFAULT 
			     1			ENDIF 
 E8CB  E8 E8DC R             1		CALL	BEEP_ON_P 
 E8CE  B5 40				MOV	CH, MEEP_DELAY
					IO_DELAY				; delay while meeping
 E8D0                        1	??0021: 
 E8D0  E2 FE                 1		LOOP	??0021					; long delay for I/O 
					BEEP_OFF
 E8D2  E8 E8F1 R             1		CALL	BEEP_OFF_P 
 E8D5  B5 40				MOV	CH, MEEP_DELAY
					IO_DELAY				; delay between beeps
 E8D7                        1	??0022: 
 E8D7  E2 FE                 1		LOOP	??0022					; long delay for I/O 
 E8D9  5B				POP	BX
 E8DA  58				POP	AX
 E8DB  C3				RET
 E8DC				MEEP ENDP
 E8DC				MEEPMEEP ENDP
 E8DC				MEEPMEEP_Z ENDP
				
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-97


				;----------------------------------------------------------------------------;
				; Turn on speaker at given tone
				;----------------------------------------------------------------------------;
				; Input:
				; 	AX = TONE
				; Output:
				;	BL = previous PPI state
				;
				; http://www.cs.binghamton.edu/~reckert/220/8254_timer.html
				;
				; Clobbers BL, AL
				; Cannot use stack since this could be called before it is working.
				;----------------------------------------------------------------------------;
 E8DC				BEEP_ON_P PROC
 E8DC  93				XCHG	AX, BX				; save tone to BX
 E8DD  B0 B6				MOV	AL, PIT_CW <2, 11B, 3>		; Select Timer 2, LE, Mode 3 (square)
 E8DF  E6 43				OUT	PIT_CTRL, AL			; Send to PIT control word (43H)
 E8E1  93				XCHG	AX, BX				; restore tone
 E8E2				BEEP_ON_1 PROC
 E8E2  E6 42				OUT	PIT_CH2, AL				; send low byte to timer
 E8E4  8A C4				MOV	AL, AH 				; select high byte
 E8E6  E6 42				OUT	PIT_CH2, AL				; send high byte to timer
 E8E8  E4 61				IN	AL, PPI_B				; read current PPI port B status
 E8EA  8A D8				MOV	BL, AL				; save original PPI state
 E8EC  0C 03				OR	AL, MASK PBSP OR MASK PBST	; enable speaker and time gates
 E8EE  E6 61				OUT	PPI_B, AL				; write back to port B
 E8F0  C3				RET
 E8F1				BEEP_ON_1 ENDP
 E8F1				BEEP_ON_P ENDP
				
				;----------------------------------------------------------------------------;
				; Turn off speaker
				;----------------------------------------------------------------------------;
				; Input:
				;	BL = original (speaker off) PPI state
				;
				; Clobbers: AL
				;----------------------------------------------------------------------------;
 E8F1				BEEP_OFF_P PROC
 E8F1  8A C3				MOV	AL, BL				; restore original PPI state
 E8F3  E6 61				OUT	PPI_B, AL				; write back to port B
 E8F5  C3				RET
 E8F6				BEEP_OFF_P ENDP
				
 E8F6				BEEP_PROC ENDP
				
				;----------------------------------------------------------------------------;
				; Additional POST messages
				;----------------------------------------------------------------------------;
								IF POST_WARM_COLD EQ 1
 E8F6  42 6F 6F 74 00		POST_BOOT		DB	'Boot', 0
 E8FB  57 41 52 4D 00		POST_WARM		DB	'WARM', 0
 E900  43 4F 4C 44 00		POST_COLD		DB	'COLD', 0
								ENDIF
				
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-98


				;----------------------------------------------------------------------------;
				; Display all POST messages
				;----------------------------------------------------------------------------;
				; See PFLAGS
				; Output: BP (high byte) = 0
				; Clobbers: AX, CX, SI
				; Size: 63 bytes
				;----------------------------------------------------------------------------;
 E905				POST_ERR_MSG PROC
				
				;----------------------------------------------------------------------------;
				; POST Error Strings
				;
 E905  0D 0A 50 4F 53 54	POST_ERR		DB	CR, LF, 'POST '	; POST Error
       20			
 E90C  45 72 72 6F 72 20	POST_ERR_ERR	DB	'Error ', 0		; Error
       00			
 E913  4B 42 00			POST_ERR_PKI	DB	'KB',   0		; Reset returned non-success "301"
 E916  4B 65 79 00		POST_ERR_PKEY	DB	'Key',  0		; Reset did not clear KBC
 E91A  46 44 43 00		POST_ERR_PFDC	DB	'FDC',  0		; General FD init failure
 E91E  44 4D 41 00		POST_ERR_PDMA	DB	'DMA',  0		; DMA TC0 error
				
				;----------------------------------------------------------------------------;
				; POST String Vectors - indexed by PFLAGS
				;
 E922				POST_ERRORS LABEL WORD
 E922  E913 R				DW	OFFSET POST_ERR_PKI		; PKI  : Keyboard Interrupt Error
 E924  E916 R				DW	OFFSET POST_ERR_PKEY		; PKEY : Keyboard Key Stuck
 E926  E91A R				DW	OFFSET POST_ERR_PFDC		; PFDC : FDC Init Failure
 E928  E4F2 R				DW	OFFSET POST_FDD			; PFSK : FDC Seek Test Failure
 E92A  E91E R				DW	OFFSET POST_ERR_PDMA		; PDMA : DMA TC0 Error
 E92C  E4D4 R				DW	OFFSET POST_MEMORY		; PMEM : RAM Error
 = 0006				L_POST_ERRORS	EQU	($-POST_ERRORS)/SIZE POST_ERRORS
				
 E92E				POST_ERROR_MSG PROC
 E92E  B9 0007				MOV	CX, L_POST_ERRORS+1		; # of available POST error messages
 E931  BE E920 R			MOV	SI, OFFSET POST_ERRORS-2	; SI = string table pointer
											;  add one LOOP for WARM BOOT flag
 E934				POST_ERROR_MSG_LOOP:
 E934  2E: AD				LODS	WORD PTR CS:[SI]			; AX = next message offset
 E936  D1 E5				SHL	BP, 1					; CF = POST error flag
 E938  73 07				JNC	POST_ERROR_MSG_NEXT		; no flag?
 E93A  9C				PUSHF						; save BP ZF
 E93B  96				XCHG	AX, SI				; SI = error string
					PRINTLN_SZ  SI				; write string with CRLF
 E93C  E8 F754 R             1		CALL	OUTLN_SZ 
 E93F  96				XCHG	AX, SI				; SI = string table pointer
 E940  9D				POPF
 E941				POST_ERROR_MSG_NEXT:
 E941  E0 F1				LOOPNZ  POST_ERROR_MSG_LOOP		; loop until end of strings or flags
 E943				POST_ERROR_MSG_EXIT:
 E943  C3				RET
 E944				POST_ERROR_MSG ENDP
				
 E944				POST_ERR_MSG ENDP
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-99


				
				;----------------------------------------------------------------------------;
				; Additional INT 9h - Keyboard Code
				;----------------------------------------------------------------------------;
				
				;----------------------------------------------------------------------------;
				; INT 9 - Test keyboard during POST
				; Size: 27 bytes
				;----------------------------------------------------------------------------;
 E944				INT_09_POST PROC
 E944  50				PUSH	AX
					POST_FLAG_CLR PKI				; clear POST test int flag
			     1				ELSE 
 = 0001                      1	??0023	EQU	1				; use CLR1 (ZF unaffected) 
			     1				ENDIF 
			     1				ELSE 
 E945  81 E5 BFFF            1		AND	BP, NOT MASK PKI			; Clear flag 
			     1				ENDIF 
 E949  E4 60				IN	AL, PPI_A				; read keyboard scan from PPI
 E94B  3C AA				CMP	AL, 0AAH
 E94D  75 04				JNE	INT_09_POST_DONE			; jump if not expected AAh
					POST_FLAG_SET PKI				; set POST keyboard test pass flag
			     1				ELSE 
 E94F  81 CD 4000            1		OR	BP, MASK PKI			; Set FLAG 
			     1				ENDIF 
 E953				INT_09_POST_DONE:
 E953  E4 61				IN	AL, PPI_B				; read keyboard status
 E955  0C C0				OR	AL, MASK PBKB OR MASK PBKC	; set clear keyboard and enable clock
 E957  E6 61				OUT	PPI_B, AL				; write to PPI Control Port B
 E959  B0 20				MOV	AL, EOI				; Send End of Interrupt
 E95B  E6 20				OUT	INT_P0, AL
 E95D  58				POP	AX
 E95E  CF				IRET
 E95F				INT_09_POST ENDP
				
				;----------------------------------------------------------------------------;
				; Clear keyboard circular buffer
				;----------------------------------------------------------------------------;
				; Clear/init circular buffer at KB_BUF
				; Clobbers AX, DI
				;
				; Size: 16 bytes
				;----------------------------------------------------------------------------;
 E95F				KB_BUF_CLEAR PROC
						ASSUME ES:_BDA_ABS
 E95F  06				PUSH	ES 					; save ES
 E960  33 C0				XOR	AX, AX
 E962  8E C0				MOV	ES, AX
 E964  26: A1 0480 R			MOV	AX, ES:KB_BUF_ST_ABS 		; AX = original start of buffer
 E968  BF 041A R			MOV	DI, OFFSET KB_BUF_HD_ABS	; DI = buffer head
 E96B  AB				STOSW 					; write to head pointer
 E96C  AB				STOSW 					; write to tail pointer
 E96D  07				POP	ES
 E96E  C3				RET
						ASSUME ES:NOTHING
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-100


 E96F				KB_BUF_CLEAR ENDP
				
				;----------------------------------------------------------------------------;
				; INT 9 - Keyboard Additional Data Tables
				;----------------------------------------------------------------------------;
				; When CTRL held, modify ASCII codes for these scan codes (10 bytes)
				;
 E96F				INT_KB_CTRL_ASC_TBL LABEL BYTE
 E96F  00 03				DB	00H, 03H				; Ctrl 2	-> ASCII 0
 E971  1E 07				DB	1EH, 07H				; Ctrl 6	-> ASCII 1EH
 E973  1F 0C				DB	1FH, 0CH				; Ctrl '-'	-> ASCII 1FH
 E975  7F 0E				DB	7FH, 0EH				; Ctrl BS 	-> ASCII 07FH
 E977  0A 1C				DB	0AH, 1CH				; Ctrl Enter -> ASCII 0AH
				
				;----------------------------------------------------------------------------;
				; When CTRL held, modify scan codes for these scan codes (14 bytes)
				;
 E979				INT_KB_CTRL_SCAN_TBL LABEL BYTE
 E979  77 47				DB	77H, 47H 				; Ctrl Home
 E97B  84 49				DB	84H, 49H 				; Ctrl PgUp
 E97D  73 4B				DB	73H, 4BH 				; Ctrl Left Arrow
 E97F  74 4D				DB	74H, 4DH 				; Ctrl Right Arrow
 E981  75 4F				DB	75H, 4FH 				; Ctrl End
 E983  76 51				DB	76H, 51H 				; Ctrl PgDn
 E985  72 37				DB	72H, 37H				; Keypad * / PrtSc
				
 = 000C				L_INT_KB_CTRL_ASC_TBL	EQU ($-INT_KB_CTRL_ASC_TBL)/2		; 12 total
 = 0006				L_INT_KB_CTRL_SCAN_TBL	EQU ($-INT_KB_CTRL_SCAN_TBL)/2-1	; 6
				
				;
				; 0 BYTES HERE
				;
				BYTES_HERE	INT_09
 = 0000                      1	BYTES_HERE_INT_09 = INT_09-$ 
			     1			IFDEF BYTES_HERE_INT_09 
			     1			IF2 
			     1			ENDIF 
			     1			ENDIF 
				
				;----------------------------------------------------------------------------;
				; INT 9 - Keyboard Interrupt IRQ1 (Hardware Handler)
				;----------------------------------------------------------------------------;
				; Handles hardware Interrupt generated by the KBC connected to IRQ 1. The 
				; scan code that is received is translated to all of the behaviors and key
				; combinations used by the PC.
				;
				;----------------------------------------------------------------------------;
				; References:
				;  https://stanislavs.org/helppc/scan_codes.html
				;  https://stanislavs.org/helppc/make_codes.html
				;  https://stanislavs.org/helppc/keyboard_commands.html
				;  https://stanislavs.org/helppc/8042.html
				;  http://www.techhelpmanual.com/106-int_09h__keyboard_interrupt.html
				;  https://www.phatcode.net/res/223/files/html/Chapter_20/CH20-1.html
				;
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-101


				; KBFLAGS1 RECORD	K1IN:1,K1CL:1,K1NL:1,K1SL:1,K1AL:1,K1CT:1,K1LS:1,K1RS:1
				; KBFLAGS2 RECORD	K2IN:1,K2CL:1,K2NL:1,K2SL:1,K2PA:1,K2SY:1,K2LA:1,K2LC:1
				;----------------------------------------------------------------------------;
				; Things you must do:
				; - Check for a scan code from the KBC via PPI Port A (60h)
				; - Clear and Enable the keyboard bit (7) on PPI Port B
				; - Examine the Make or Break system scan code
				; - If a toggle key (Shift, Alt, Ctrl, Caps Lock, Num Lock or Scroll Lock),
				;	update that flag in the BDA (17-18h)
				; - Determine if the scan code is altered by an active shift or toggle state
				; - If Ctrl-Alt-Del is pressed, do a warm reboot of the system
				; - If Print Screen is pressed, call INT 05h
				; - If Pause/Ctrl-NumLock is pressed, enter pause/hold state
				; - If Ctrl-Break is pressed, call INT 1Bh
				; - Handle any special, non-standard translations
				; - Translate printable chars to their ASCII/CP-437 value
				;
				; In short, it needs to do this:
				;    https://stanislavs.org/helppc/scan_codes.html
				;----------------------------------------------------------------------------;
 E987						ORG 0E987H
 E987				INT_09 PROC
							ASSUME DS:_BDA
 E987  50				PUSH	AX						; save AX first
 E988  E4 60				IN	AL, PPI_A 					; read scan code from PPI Port A
 E98A  8A E0				MOV	AH, AL					; save scan code to AH
 E98C  E4 61				IN	AL, PPI_B 					; read Control Port B
 E98E  50				PUSH	AX						; save status, and I/O delay
 E98F  0C 80				OR	AL, MASK PBKB				; set clear keyboard bit
 E991  E6 61				OUT	PPI_B, AL 					; write to Control Port B
 E993  58				POP	AX						; restore status, and I/O delay
 E994  E6 61				OUT	PPI_B, AL 					; write to Control Port B
				
				;----------------------------------------------------------------------------;
				; Send non-specific EOI to PIC
				;
 E996  B0 20				MOV	AL, EOI 					; End of Interrupt OCW
 E998  E6 20				OUT	INT_P0, AL					; write EOI to port 0
 E99A  FB				STI							; enable interrupts
 E99B  FC				CLD							; string functions increment
							ELSE
					PUSHX	BX, CX, DX, DI, SI			; save working registers
			     1				IFNB <BX>			; exit if last reg 
 E99C  53                    1		PUSH	BX 					; push register and repeat 
			     1		PUSHX	CX, DX, DI, SI, , ,  
			     2				IFNB <CX>			; exit if last reg 
 E99D  51                    2		PUSH	CX 					; push register and repeat 
			     2		PUSHX	DX, DI, SI, , , ,  
			     3				IFNB <DX>			; exit if last reg 
 E99E  52                    3		PUSH	DX 					; push register and repeat 
			     3		PUSHX	DI, SI, , , , ,  
			     4				IFNB <DI>			; exit if last reg 
 E99F  57                    4		PUSH	DI 					; push register and repeat 
			     4		PUSHX	SI, , , , , ,  
			     5				IFNB <SI>			; exit if last reg 
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-102


 E9A0  56                    5		PUSH	SI 					; push register and repeat 
			     5		PUSHX	, , , , , ,  
			     5				ENDIF 
			     4				ENDIF 
			     3				ENDIF 
			     2				ENDIF 
			     1				ENDIF 
							ENDIF
					PUSHX	DS, ES					; save segment registers
			     1				IFNB <DS>			; exit if last reg 
 E9A1  1E                    1		PUSH	DS 					; push register and repeat 
			     1		PUSHX	ES, , , , , ,  
			     2				IFNB <ES>			; exit if last reg 
 E9A2  06                    2		PUSH	ES 					; push register and repeat 
			     2		PUSHX	, , , , , ,  
			     2				ENDIF 
			     1				ENDIF 
 E9A3  B9 ---- R			MOV	CX, SEG _BDA 				; CX = BIOS Data Area, CH = 0
 E9A6  8A C4				MOV	AL, AH					; AL = original scan code
 E9A8  3C FF				CMP	AL, 0FFH 					; check for Detection Error/Overrun
 E9AA  74 6D				JZ	INT_KB_MEEP_DONE				; if overrun, meep and exit
 E9AC  8E D9				MOV	DS, CX					; DS = BIOS Data Area
 E9AE  8C CA				MOV	DX, CS					; ES = BIOS code segment
 E9B0  8E C2				MOV	ES, DX
 E9B2  8B 16 0017 R			MOV	DX, KB_FLAGS				; DL=KB_FLAGS1, DH=KB_FLAGS2
				
				;----------------------------------------------------------------------------;
				; 1. Is a function key?
				; Function keys have different scan codes based on shift, ALT or CTRL state
				;
 E9B6				KB_INT_CHECK_FN_KEY:
 E9B6  3C 44				CMP	AL, 044H					; is above F10 scan code?
 E9B8  77 21				JA	KB_INT_CHECK_FN_KEY_DONE
 E9BA  3C 3B				CMP	AL, 03BH					; is below F1 scan code?
 E9BC  72 1D				JB	KB_INT_CHECK_FN_KEY_DONE
 E9BE  B0 00				MOV	AL, 0						; ASCII always 0 on F-keys
				
				;----------------------------------------------------------------------------;
				; Is a Function key. Check if shift, ALT or Ctrl is held?
				;
 E9C0  F6 C2 0F				TEST	DL, MASK K1AL OR MASK K1CT OR MASK K1LS OR MASK K1RS
 E9C3  74 16				JZ	KB_INT_CHECK_FN_KEY_DONE		; no control keys held
 E9C5  80 C4 2D				ADD	AH, 2DH					; adjust to ALT
 E9C8  F6 C2 08				TEST	DL, MASK K1AL				; is it ALT?
 E9CB  75 0B				JNZ	KB_INT_PUT_BUFFER_2			; if so, put in buffer
 E9CD  80 EC 0A				SUB	AH, 2DH-23H					; adjust to CTRL
 E9D0  F6 C2 04				TEST	DL, MASK K1CT				; is CTRL?
 E9D3  75 03				JNZ	KB_INT_PUT_BUFFER_2			; if so, put in buffer
 E9D5  80 EC 0A				SUB	AH, 23H-19H					; adjust to shift
 E9D8				KB_INT_PUT_BUFFER_2:					; fit short jumps above
 E9D8  E9 EA71 R			JMP	KB_INT_PUT_BUFFER
				
 E9DB				KB_INT_CHECK_FN_KEY_DONE:				; not a function key
				
				;----------------------------------------------------------------------------;
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-103


				; 2. Handle "early" Ctrl such as Ctrl-Break and Ctrl-NumLock
				;
 E9DB  F6 C2 04				TEST	DL, MASK K1CT				; is Ctrl held?
 E9DE  74 14				JZ	KB_INT_IS_NUM				; if not, skip to IS_NUM
				
				;----------------------------------------------------------------------------;
				; Is Ctrl-Break?
				;
 E9E0  3C 46				CMP	AL, 46H					; Scroll Lock (Break)
 E9E2  75 0C				JNZ	INT_KB_CHECK_CTRL_NUM			; jump if not Break
				
 E9E4				INT_KB_CTRL_BREAK:
 E9E4  E8 E95F R			CALL	KB_BUF_CLEAR				; clear keyboard buffer
 E9E7  C6 06 0071 R 80			MOV	BIOS_BREAK, KBBRK <1>			; BIOS break flag
 E9EC  CD 1B				INT	1BH						; call BIOS Break handler
 E9EE  EB 27				JMP	SHORT INT_KB_DONE_2
				
				;----------------------------------------------------------------------------;
				; Is Ctrl-NumLock (Pause)?
				;
 E9F0				INT_KB_CHECK_CTRL_NUM:
 E9F0  3C 45				CMP	AL, 45H					; is Num Lock key?
					;CMP	AL, 35H					; key pad / (for testing)
 E9F2  74 16				JZ	INT_KB_SET_PAUSE				; if not, put in Pause
				
				;----------------------------------------------------------------------------;
				; 3. Handle numeric keypad entry according to the following:
				;
				;	Num	Shift	ASCII	Scan
				; 	0	0	0	52h	5230 0020
				;	0	1	'0'	52h	5200 80A2
				;	1	0	'0'	52h	5200 8000
				;	1	1	0	52h	5200 8080
				;
 E9F4				KB_INT_IS_NUM:
 E9F4  F6 C2 20				TEST	DL, MASK K1NL				; is NUM LOCK on?
 E9F7  74 25				JZ	KB_INT_IS_NUM_DONE			; if not, do nothing
 E9F9  3C 53				CMP	AL, 53H					; is higher than Del key?
 E9FB  77 21				JA	KB_INT_IS_NUM_DONE
 E9FD  3C 47				CMP	AL, 47H					; is lower than Home/7 key?
 E9FF  72 1D				JB	KB_INT_IS_NUM_DONE
				
				;----------------------------------------------------------------------------;
				; Keypad number pressed and Num Lock is on, so invert shift behavior.
				;
 EA01  D0 E0				SHL	AL, 1						; invert NumLock and Shift
 EA03  F6 C2 03				TEST	DL, MASK K1LS OR MASK K1RS		;  behavior and jump ahead
 EA06  74 1E				JZ	KB_INT_UC					; jump if no shift held
 EA08  EB 1B				JMP	SHORT KB_INT_SHIFT
				
				;----------------------------------------------------------------------------;
				; KB Ctrl-NumLock Screen Pause
				;----------------------------------------------------------------------------;
 EA0A				INT_KB_SET_PAUSE:
 EA0A  BB 0018 R			MOV	BX, OFFSET KB_FLAGS2			; (-1 byte to use indirect)
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-104


 EA0D  80 0F 08				OR	BYTE PTR [BX], MASK K2PA		; set PAUSE flag
				
				
				;----------------------------------------------------------------------------;
				; Loop until Pause flag is cleared
				;
 EA10				INT_KB_PAUSE_LOOP:
 EA10  F4				HLT							; be a good neighbor
 EA11  90				NOP							; let another interrupt happen
 EA12  F6 07 08				TEST	BYTE PTR [BX], MASK K2PA		; check the Pause flag
 EA15  75 F9				JNZ	INT_KB_PAUSE_LOOP				; loop until clear
 EA17				INT_KB_DONE_2:
 EA17  EB 73				JMP	SHORT INT_KB_DONE				; exit INT
				
				;----------------------------------------------------------------------------;
				; Emit a feeble meep and exit
				;
 EA19				INT_KB_MEEP_DONE:
 EA19  E8 E8C6 R			CALL	MEEP
 EA1C  EB 6E				JMP	SHORT INT_KB_DONE				; exit INT
				
 EA1E				KB_INT_IS_NUM_DONE:
				
				;----------------------------------------------------------------------------;
				; 4. Do scan code to ASCII translation
				;----------------------------------------------------------------------------;
 EA1E				KB_INT_CHAR:						; is a regular key ?
 EA1E  D0 E0				SHL	AL, 1						; align index for table
 EA20  F6 C2 0B				TEST	DL, MASK K1LS OR MASK K1RS OR MASK K1AL	; is either shift key or ALT already pressed
				?
 EA23  75 01				JNZ	KB_INT_UC					; if so, use uppercase table
 EA25				KB_INT_SHIFT:
 EA25  40				INC	AX 						; if not shifted, increment
 EA26				KB_INT_UC:							;  one to use lower case
 EA26  BB EB9C R			MOV	BX, OFFSET KEY_SCAN_TBL
 EA29  2E: D7				XLAT	CS:[BX]					; ASCII key in AL = CS:BX[AL]
 EA2B  84 C0				TEST	AL, AL					; a is flag key code?
 EA2D  79 03				JNS	KB_INT_NOT_FLAG
 EA2F  E9 EB39 R			JMP	INT_KB_IS_FLAG
 EA32				KB_INT_NOT_FLAG:
 EA32  84 E4				TEST	AH, AH					; test high bit of scan code
 EA34  78 56				JS	INT_KB_DONE					; if set, it is an unhandled break c
				ode
 EA36				KB_INT_IS_CAPS:
 EA36  F6 C2 40				TEST	DL, MASK K1CL				; is CAPS LOCK on?
 EA39  74 0F				JZ	KB_INT_IS_CAPS_DONE
 EA3B				IS_ALPHA:							; CF if AL is not [A-Za-z]
 EA3B  50				PUSH	AX						; save original AL
 EA3C  0C 20				OR	AL, 'a'-'A'					; lowercase it for comparison
 EA3E  3C 61				CMP	AL, 'a'					; is less than 'a'?
 EA40  72 03				JB	IS_ALPHA_DONE				; CF if not alpha
 EA42  3C 7B				CMP	AL, 'z'+1					; is greater than 'z'?
 EA44  F5				CMC							; CF if not alpha
 EA45				IS_ALPHA_DONE:
 EA45  58				POP	AX						; restore original AL
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-105


 EA46  72 02				JC	KB_INT_IS_CAPS_DONE			; jump if not alpha
 EA48  34 20				XOR	AL, 'a'-'A'					; otherwise, toggle case
				
 EA4A				KB_INT_IS_CAPS_DONE:
				;----------------------------------------------------------------------------;
				; 5. Handle ALT chars that require ASCII translation
				;
 EA4A				KB_INT_IS_ALT:
 EA4A  F6 C2 08				TEST	DL, MASK K1AL				; is ALT currently held?
 EA4D  75 46				JNZ	INT_KB_ALT
				
				;----------------------------------------------------------------------------;
				; 6. Handle additional Non-ALT special case chars
				;
 EA4F  3D 3700				CMP	AX, 3700H					; is Shift-PrtSc?
 EA52  74 0D				JZ	KB_INT_PRTSC				; jump if so
 EA54  3D 4C00				CMP	AX, 4C00H					; Numeric 5 key (unshifted)
 EA57  74 33				JZ	INT_KB_DONE					; discard and exit
				
 EA59				KB_INT_IS_ALT_DONE:
				
				;----------------------------------------------------------------------------;
				; 7. Handle CTRL chars
				;
 EA59				KB_INT_IS_CTRL:
 EA59  F6 C2 04				TEST	DL, MASK K1CT				; is CTRL currently held?
 EA5C  74 07				JZ	KB_INT_IS_CTRL_DONE			; jump if not
 EA5E  E9 EB12 R			JMP	INT_KB_CTRL					; otherwise, CTRL is held
				
				;----------------------------------------------------------------------------;
				; Handle Shift-PrtSc
				;
 EA61				KB_INT_PRTSC:
 EA61  CD 05				INT	5H						; call print screen handler
 EA63  EB 27				JMP	SHORT INT_KB_DONE
				
 EA65				KB_INT_IS_CTRL_DONE:
				;----------------------------------------------------------------------------;
				; Test if in Ctrl-NumLock PAUSE
				; If in Pause, any remaining key will exit and be discarded
				;
 EA65				KB_INT_IS_PAUSE:
 EA65  F6 C6 08				TEST	DH, MASK K2PA				; is in pause?
 EA68  74 07				JZ	KB_INT_PUT_BUFFER
 EA6A  80 26 0018 R F7			AND	KB_FLAGS2, NOT MASK K2PA		; clear pause flag
 EA6F  EB 1B				JMP	SHORT INT_KB_DONE				; discard key and exit int
				
				;----------------------------------------------------------------------------;
				; All special cases have been handled
				; Store AX in keyboard buffer
				;
 EA71				KB_INT_PUT_BUFFER:
 EA71  8B 3E 001C R			MOV	DI, KB_BUF_TL 				; DI = tail ptr
 EA75  8D 75 02				LEA	SI, [DI][2]					; SI = next (maybe)
 EA78  83 FE 3E				CMP	SI, KB_BUF_END_B				; is next >= end of buffer?
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-106


 EA7B  72 03				JB	KB_INT_CHECK_FULL 			; if not, check if buffer is full
 EA7D  BE 001E R			MOV	SI, OFFSET KB_BUF 			; otherwise, wrap to first address
 EA80				KB_INT_CHECK_FULL:
 EA80  3B 36 001A R			CMP	SI, KB_BUF_HD 				; next == head?
 EA84  74 93				JE	INT_KB_MEEP_DONE				; Beep if ZF - buffer is full
 EA86  89 05				MOV	[DI], AX 					; buffer[head] = AX
 EA88  89 36 001C R			MOV	KB_BUF_TL, SI 				; tail = next
				
				;----------------------------------------------------------------------------;
				; Restore registers and exit
				;
 EA8C				INT_KB_DONE:
					POPX	ES, DS
			     1				IFNB <ES>			; exit if last reg 
 EA8C  07                    1		POP	ES 					; pop register and repeat 
			     1		POPX	DS, , , , , ,  
			     2				IFNB <DS>			; exit if last reg 
 EA8D  1F                    2		POP	DS 					; pop register and repeat 
			     2		POPX	, , , , , ,  
			     2				ENDIF 
			     1				ENDIF 
							ELSE
					POPX	SI, DI, DX, CX, BX			; restore used registers
			     1				IFNB <SI>			; exit if last reg 
 EA8E  5E                    1		POP	SI 					; pop register and repeat 
			     1		POPX	DI, DX, CX, BX, , ,  
			     2				IFNB <DI>			; exit if last reg 
 EA8F  5F                    2		POP	DI 					; pop register and repeat 
			     2		POPX	DX, CX, BX, , , ,  
			     3				IFNB <DX>			; exit if last reg 
 EA90  5A                    3		POP	DX 					; pop register and repeat 
			     3		POPX	CX, BX, , , , ,  
			     4				IFNB <CX>			; exit if last reg 
 EA91  59                    4		POP	CX 					; pop register and repeat 
			     4		POPX	BX, , , , , ,  
			     5				IFNB <BX>			; exit if last reg 
 EA92  5B                    5		POP	BX 					; pop register and repeat 
			     5		POPX	, , , , , ,  
			     5				ENDIF 
			     4				ENDIF 
			     3				ENDIF 
			     2				ENDIF 
			     1				ENDIF 
							ENDIF
 EA93  58				POP	AX
 EA94  CF				IRET
				
				;----------------------------------------------------------------------------;
				; 6. Only ALT key is held (no CTRL)
				;
				; Space bar is the only key that returns the same scan code and ASCII code 
				; when ALT is held.
				;
 EA95				INT_KB_ALT PROC
 EA95  80 FC 39				CMP	AH, 39H					; is space bar?
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-107


 EA98  74 BF				JZ	KB_INT_IS_ALT_DONE			; continue
 EA9A  8B D8				MOV	BX, AX
 EA9C  B0 00				MOV	AL, 0						; AL will be 0 for any others
				
 EA9E				CHECK_TOP_ROW_NUM:
 EA9E  80 FC 0D				CMP	AH, 0DH					; is above '=' scan code?
 EAA1  77 0A				JA	CHECK_ALT_ON
 EAA3  80 FC 02				CMP	AH, 2
 EAA6  72 05				JB	CHECK_ALT_ON
 EAA8  80 C4 76				ADD	AH, 76H
 EAAB  EB C4				JMP	SHORT KB_INT_PUT_BUFFER
				
				;----------------------------------------------------------------------------;
				; 7. Check for ALT + 000 numeric entry
				; Alt held, and number is valid numeric keypad
				; Note: AH must be preserved
				;
 EAAD				CHECK_ALT_ON:
 EAAD  80 EB 30				SUB	BL, '0'					; ASCII convert and test
 EAB0  72 12				JB	INT_KB_NOT_ALT_000			; jump if less than 0
 EAB2  80 FB 09				CMP	BL, 9
 EAB5  77 0D				JA	INT_KB_NOT_ALT_000			; jump if above 9
				
 EAB7				INT_KB_IS_ALT_000:
 EAB7  93				XCHG	AX, BX					; AL = input byte, save AX
 EAB8  8A 26 0019 R			MOV	AH, KB_ALT					; AH = partial working byte
 EABC  D5 0A				AAD							; AL = AL + ( AH * 10 )
 EABE  A2 0019 R			MOV	KB_ALT, AL					; save new working byte to BDA
 EAC1  93				XCHG	AX, BX					; restore AH, AL = 0
 EAC2  EB C8				JMP	SHORT INT_KB_DONE				; interrupt complete
				
				;----------------------------------------------------------------------------;
				; 8. Check for ALT modified chars that are skipped
				; Uses table INT_KB_ALT_SKIP
				;
 EAC4				INT_KB_NOT_ALT_000:
 EAC4  BF EC1A R			MOV	DI, OFFSET INT_KB_ALT_SKIP
 EAC7  B1 0A				MOV	CL, 10					; L_INT_KB_ALT_SKIP
 EAC9  86 E0				XCHG	AH, AL
 EACB  F2/ AE				REPNE SCASB						; is in table?
 EACD  86 E0				XCHG	AH, AL
 EACF  75 88				JNZ	KB_INT_IS_ALT_DONE			; if not found, continue
 EAD1				INT_KB_DONE_1:
 EAD1  EB B9				JMP	SHORT INT_KB_DONE				; if found, skip
				
 EAD3				INT_KB_ALT ENDP
				
				;----------------------------------------------------------------------------;
				; 9. Only CTRL key is held (no ALT)
				;----------------------------------------------------------------------------;
 EAD3				INT_KB_CTRL_NO_ALT PROC
				
				;----------------------------------------------------------------------------;
				; Handle CTRL exceptions after ASCII or scan code is modified. These require
				; a lookup table since they do not follow a predictable pattern.
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-108


				;
 EAD3  93				XCHG	AX, BX					; BH = scan code, BL = ASCII
 EAD4  B1 0C				MOV	CL, L_INT_KB_CTRL_ASC_TBL		; length of table
 EAD6  BE E96F R			MOV	SI, OFFSET INT_KB_CTRL_ASC_TBL
 EAD9				INT_KB_CTRL_ASC_TBL_LOOP:
 EAD9  2E: AD				LODS	WORD PTR CS:[SI]				; AH = scan code, AL = new ASCII
 EADB  3A E7				CMP	AH, BH					; scan code match?
 EADD  E0 FA				LOOPNE INT_KB_CTRL_ASC_TBL_LOOP		; if not keep looping until end
 EADF  75 0C				JNZ	INT_KB_CTRL_ASC_TBL_DONE		; no matches, restore AX and continue
 EAE1  80 F9 06				CMP	CL, L_INT_KB_CTRL_SCAN_TBL		; was first list segment?
 EAE4  7F 04				JG	INT_KB_CTRL_NO_DONE			; if so, match found and AX is set, exit
 EAE6  B4 00				MOV	AH, 0						; ASCII code 0
 EAE8  86 C4				XCHG	AL, AH					; AH = scan code, AL = 0
 EAEA				INT_KB_CTRL_NO_DONE:
 EAEA  E9 EA65 R			JMP	KB_INT_IS_CTRL_DONE			; AX set, exit
 EAED				INT_KB_CTRL_ASC_TBL_DONE:
 EAED  93				XCHG	AX, BX					; restore AX
				
				;----------------------------------------------------------------------------;
				; Skip ; ' `
				;
 EAEE  80 FC 27				CMP	AH, 27H					; pass < 27
 EAF1  72 05				JB	INT_KB_CTRL_ALPHA
 EAF3  80 FC 29				CMP	AH, 29H					; pass > 29
 EAF6  76 94				JNA	INT_KB_DONE					; skip 27-29
				
				;----------------------------------------------------------------------------;
				; For scan codes 10H-32H return only low 5 bits of ASCII code when CTRL is held
				;
 EAF8				INT_KB_CTRL_ALPHA:
 EAF8  80 FC 10				CMP	AH, 10H
 EAFB  72 09				JB	INT_KB_CTRL_NO_ALT_1
 EAFD  80 FC 32				CMP	AH, 32H
 EB00  77 04				JA	INT_KB_CTRL_NO_ALT_1
 EB02  24 1F				AND	AL, 00011111B				; adjust ASCII value
 EB04  EB E4				JMP	SHORT INT_KB_CTRL_NO_DONE
 EB06				INT_KB_CTRL_NO_ALT_1:
				
				;----------------------------------------------------------------------------;
				; If scan code between 02H-35H and hasn't been modified yet, return nothing
				;
 EB06  80 FC 02				CMP	AH, 2
 EB09  72 DF				JB	INT_KB_CTRL_NO_DONE			; pass < 2
 EB0B  80 FC 35				CMP	AH, 35H
 EB0E  77 DA				JA	INT_KB_CTRL_NO_DONE			; pass > 35
 EB10  EB BF				JMP	SHORT INT_KB_DONE_1			; don't return 2-35?
				
 EB12				INT_KB_CTRL_NO_ALT ENDP
				
				;----------------------------------------------------------------------------;
				; 8. Ctrl key is held
				;----------------------------------------------------------------------------;
 EB12				INT_KB_CTRL:
 EB12  F6 C2 08				TEST	DL, MASK K1AL				; is ALT also currently held?
 EB15  74 BC				JZ	INT_KB_CTRL_NO_ALT			; jump if no ALT
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-109


				
				;----------------------------------------------------------------------------;
				; 9. Ctrl-Alt keys are held
				;----------------------------------------------------------------------------;
 EB17				INT_KB_CTRL_ALT:
 EB17  80 FC 53				CMP	AH, 53H					; is Ctrl-Alt-Del?
							IF IS_TURBO
 EB1A  75 0C				JNZ	INT_KB_CTRL_ALT_1				; if not check for turbo hotkey
							ENDIF
				
				;----------------------------------------------------------------------------;
				; Handle Ctrl-Alt-Del (Warm reboot)
				;
 EB1C				INT_KB_CTRL_ALT_DEL:
 EB1C  E8 E8AE R			CALL	BEEP						; BEEP on ctrl-alt-del
							IF WARM_ENABLE EQ 1
 EB1F  C7 06 0072 R 1234		MOV	WARM_FLAG, WARM_BOOT			; set warm boot flag
							ENDIF
 EB25  E9 E05B R			JMP	BOOT						; warm reboot
				
							IF IS_TURBO
				;----------------------------------------------------------------------------;
				; 10. Handle Ctrl-Alt but not Del (only Turbo hotkey)
				;
 EB28				INT_KB_CTRL_ALT_1:
				
				;----------------------------------------------------------------------------;
				; Is Turbo speed toggle Ctrl-Alt-+ hotkey?
				;
 EB28  80 FC 4E				CMP	AH, 4EH					; numeric pad + key
 EB2B  75 BD				JNZ	INT_KB_CTRL_NO_DONE
				
				;	;CMP	AH, 4AH					; numeric pad - key
				;	;JZ	INT_KB_TURBO_MINUS
				
				;----------------------------------------------------------------------------;
				; Handle Turbo speed mode toggle
				;
 EB2D				INT_KB_TOGGLE_TURBO PROC
							ELSE
								ELSE
 EB2D  E4 61				IN	AL, PPI_B					; read standard PPI register
								ENDIF				; /IF ARCH_TYPE EQ INIT_V40
 EB2F  A8 04				TEST	AL, MASK PBTB				; is in Turbo mode?
							ENDIF					; /IF ARCH_TYPE EQ ARCH_TD3300
 EB31  E8 E8C1 R			CALL	MEEPMEEP_Z					; two meeps if to high (ZF)
												; one meep if to low (NZ)
 EB34  E8 E274 R			CALL	TOGGLE_TURBO				; toggle speed setting
 EB37  EB 32				JMP	SHORT INT_KB_DONE_3			; done with keyboard
 EB39				INT_KB_TOGGLE_TURBO ENDP
							ENDIF
				
				;----------------------------------------------------------------------------;
				; 5. Is a flag key?
				;----------------------------------------------------------------------------;
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-110


				;  40:18	Keyboard Flags Byte 2 (High)
				; 84218421
				; 7 	    |			- K2IN	insert key is depressed
				;  6 	    |			- K2CL	caps-lock key is depressed
				;   5	    |			- K2NL	num-lock key is depressed
				;    4    |			- K2SL	scroll lock key is depressed
				;     3   |			- K2PA	suspend key has been toggled
				;      2  |			- K2SY	system key depressed and held
				;       1 |			- K2LA	left ALT key depressed
				;        0|			- K2LC	left CTRL key depressed
				;----------------------------------------------------------------------------;
 = BYTE PTR[BX]			_KB_FLAGS2	EQU	BYTE PTR[BX]			; Use index addressing
 = BYTE PTR[BX][-1]		_KB_FLAGS1	EQU	_KB_FLAGS2[-1]			;  for byte savings
				
 EB39				INT_KB_IS_FLAG PROC
 EB39  BB 0018 R			MOV	BX, OFFSET KB_FLAGS2			; BX = KB_FLAGS2
 EB3C  BF EC12 R			MOV	DI, OFFSET KEY_FLAG_ON_TBL
 EB3F  8A C4				MOV	AL, AH					; AL = original scan code
 EB41  24 7F				AND	AL, 01111111B				; clear high bit for search
 EB43  B1 01				MOV	CL, 1						; set up bit mask counter
 EB45				INT_KB_FLAG_LOOP:
 EB45  AE				SCASB 						; look for scan code
 EB46  74 07				JZ	INT_KB_FLAG_FOUND
 EB48  D0 E1				SHL	CL, 1 					; CL will contain bit mask
 EB4A  75 F9				JNZ	INT_KB_FLAG_LOOP				; CF if not found too
 EB4C  E9 EA32 R			JMP	KB_INT_NOT_FLAG
 EB4F				INT_KB_FLAG_FOUND:
 EB4F  FA				CLI
 EB50  8A C1				MOV	AL, CL					; move to AL for work
				
				;----------------------------------------------------------------------------;
				; Ins, Caps, Num, Scrl send break codes, but state is kept by BIOS so ignore those.
				;
 EB52  A8 F0				TEST	AL, MASK K1IN OR MASK K1CL OR MASK K1NL OR MASK K1SL
 EB54  74 18				JZ	INT_KB_NOT_ICNS				; don't clear on break code on these
 EB56  84 E4				TEST	AH, AH					; is Ins, Caps, Num, Scrl break code?
 EB58  79 06				JNS	INT_KB_ICNS_MAKE				; if not, jump to make
				
				;----------------------------------------------------------------------------;
				; Handle KB_FLAGS2 for Ins, Caps, Num, Scroll Lock for both make and break
				;
 EB5A				INT_KB_ICNS_BREAK:
 EB5A  F6 D0				NOT	AL
 EB5C  20 07				AND	_KB_FLAGS2, AL
 EB5E  EB 0B				JMP	SHORT	INT_KB_DONE_3
 EB60				INT_KB_ICNS_MAKE:
 EB60  08 07				OR	_KB_FLAGS2, AL				; set flag in KB_FLAGS2
				
				;----------------------------------------------------------------------------;
				; Otherwise toggle the flag for Ins, Caps, Num, Scrl.
				;
				; Note: The Ins key is treated as a key press with code 5200H.
				;
 EB62				INT_KB_FLAG_TOGGLE:
 EB62  30 47 FF				XOR	_KB_FLAGS1, AL				; toggle flag
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-111


 EB65  A8 80				TEST	AL, MASK K1IN				; is insert key?
 EB67  B0 00				MOV	AL, 0
 EB69  75 2E				JNZ	INT_KB_PUT_BUFFER_2			; pass through as a key if so
 EB6B				INT_KB_DONE_3:
 EB6B  E9 EA8C R			JMP	INT_KB_DONE
				
				;----------------------------------------------------------------------------;
				; Scan code for Alt, Ctrl, Left or Right Shift
				; On make code, set flag.  On break code, clear flag.
				;
 EB6E				INT_KB_NOT_ICNS:
				
				;----------------------------------------------------------------------------;
				; Handle KB_FLAGS2 for Ctrl or Alt
				;
 EB6E  A8 0C				TEST	AL, MASK K1AL OR MASK K1CT		; is Alt or Ctrl?
 EB70  74 08				JZ	INT_KB_NOT_ICNS_1				; jump if not
 EB72  D0 E8				SHR	AL, 1						; adjust for KB_FLAGS2
 EB74  D0 E8				SHR	AL, 1
 EB76  30 07				XOR	_KB_FLAGS2, AL				; toggle flag
 EB78  8A C1				MOV	AL, CL					; restore AL
				
 EB7A				INT_KB_NOT_ICNS_1:
 EB7A  4B				DEC	BX						; _KB_FLAGS2 = KB_FLAGS1
 EB7B  84 E4				TEST	AH, AH					; is a break code?
 EB7D  78 04				JS	INT_KB_FLAG_CLEAR				; if so, clear flag
 EB7F  08 07				OR	_KB_FLAGS2, AL				; set flag
 EB81  EB E8				JMP	SHORT INT_KB_DONE_3			; done
				
 EB83				INT_KB_FLAG_CLEAR:
 EB83  F6 D0				NOT	AL						; invert mask
 EB85  20 07				AND	_KB_FLAGS2, AL				; clear flag
 EB87  80 F9 08				CMP	CL, MASK K1AL				; was it ALT key?
 EB8A  75 DF				JNZ	INT_KB_DONE_3				; if not, done
				
 EB8C				INT_KB_IS_FLAG ENDP
				
				;----------------------------------------------------------------------------;
				; ALT has just been released
				;----------------------------------------------------------------------------;
				; Check if there a partial value of ALT+000 (ALT-GR) numpad entry work byte?
				;
 EB8C				INT_KB_ALT_BREAK:
 EB8C  A0 0019 R			MOV	AL, KB_ALT
 EB8F  84 C0				TEST	AL, AL					; is ALT working sum 0?
 EB91  74 D8				JZ	INT_KB_DONE_3				; if so, end
 EB93  B4 00				MOV	AH, 0						; Scan code is 0
 EB95  88 26 0019 R			MOV	KB_ALT, AH					; clear ALT byte working sum
 EB99				INT_KB_PUT_BUFFER_2:
 EB99  E9 EA71 R			JMP	KB_INT_PUT_BUFFER				; use value as output char
				
				;----------------------------------------------------------------------------;
				; Keyboard scancode mapping tables
				;----------------------------------------------------------------------------;
				; For each scan code this table contains ASCII characters. The first byte is
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-112


				; the shifted (shift held) ASCII char, followed by the non-shifted ASCII char.
				;
				; Flag chars (noted by *) return their scan code with most sig bit set 
				; (also their break code).
				;----------------------------------------------------------------------------;
 EB9C				KEY_SCAN_TBL	LABEL BYTE
 EB9C  0002[				DB	2 DUP(0), 2 DUP(1BH) 		; 00-01H	None, Escape
	   00			
			 ]	
       0002[			
	   1B			
			 ]	
				
 EBA0  21 31 40 32 23 33		DB	'!1@2#3$4%5^6' 			; 02-		(Top row keys)
       24 34 25 35 5E 36	
 EBAC  26 37 2A 38 28 39		DB	'&7*8(9)0_-+='			;   -0DH
       29 30 5F 2D 2B 3D	
 EBB8  08 08 00 09			DB	8, 8, 0, 9 				; 0E-0FH	Backspace, Tab
 EBBC  51 71 57 77 45 65		DB	'QqWwEeRrTtYy' 			; 10-		(Second row keys)
       52 72 54 74 59 79	
 EBC8  55 75 49 69 4F 6F		DB	'UuIiOoPp{[}]' 			;    1BH
       50 70 7B 5B 7D 5D	
 EBD4  0002[				DB	2 DUP(0DH) 				; 1C		Enter
	   0D			
			 ]	
				
 EBD6  0002[				DB	2 DUP(01DH OR 80H) 		; 1D		*Ctrl
	   9D			
			 ]	
				
 EBD8  41 61 53 73 44 64		DB	'AaSsDdFfGgHh'			; 1E-		(Third row keys)
       46 66 47 67 48 68	
 EBE4  4A 6A 4B 6B 4C 6C		DB	'JjKkLl:;"', "'", '~`'		;   -29H
       3A 3B 22 27 7E 60	
 EBF0  0002[				DB	2 DUP(02AH OR 80H)  		; 2A		*Left shift
	   AA			
			 ]	
				
 EBF2  7C 5C 5A 7A 58 78		DB	'|\ZzXxCcVvBb' 			; 2B-		(Fourth row keys)
       43 63 56 76 42 62	
 EBFE  4E 6E 4D 6D 3C 2C		DB	'NnMm<,>.?/' 			;   -35H
       3E 2E 3F 2F		
 EC08  0002[				DB	2 DUP(36H OR 80H)			; 36H		*Right Shift
	   B6			
			 ]	
				
 EC0A  00 2A				DB	0, '*' 				; 37H		PrtSc/'*'
 EC0C  0002[				DB	2 DUP(38H OR 80H)			; 38H		*Alt
	   B8			
			 ]	
				
 EC0E  0002[				DB	2 DUP(' ')				; 39H		Space
	   20			
			 ]	
				
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-113


 EC10  0002[				DB	2 DUP(3AH OR 80H) 		; 3AH		*Caps Lock
	   BA			
			 ]	
				
				
				;----------------------------------------------------------------------------;
				; IMPORTANT NOTE: these next two tables are placed here to fill the "hole"
				; for the F1-F10 keys since those scan codes are handled separately.
				; This space can be used as long as exactly 20 bytes is left to maintain the
				; table index. Left commented-out below for reference:
				;	DW	10 DUP(0) 				; 3B-44H	F1-F10
				
				;----------------------------------------------------------------------------;
				; Table for scan codes that are keys that set flags.
				; The byte's index corresponds to the flag bit position in BDA's KB_FLAGS1.
				; Length: 8 bytes
				;
 EC12				KEY_FLAG_ON_TBL	LABEL BYTE	;                            ICNSATLR
 EC12  36				DB	36H			; Right shift on	0110110 -> 00000001
 EC13  2A				DB	2AH			; Left shift on	0101010 -> 00000010
 EC14  1D				DB	1DH			; cTrl on		0011101 -> 00000100
 EC15  38				DB	38H			; Alt on		0111000 -> 00001000
 EC16  46				DB	46H			; Scroll lock on 	1000110 -> 00010000
 EC17  45				DB	45H			; Num lock on	1000101 -> 00100000
 EC18  3A				DB	3AH			; Caps lock on	0111010 -> 01000000
 EC19  52				DB	52H			; Insert on		1010010 -> 10000000
 = 0008				L_KEY_FLAG_ON_TBL	EQU $-KEY_FLAG_ON_TBL
				
				;----------------------------------------------------------------------------;
				; Alt keys that are "skipped" and return no scan codes
				; Length: 10 bytes
				;
 EC1A				INT_KB_ALT_SKIP	LABEL BYTE
 EC1A  0F				DB	0FH					; Tab
 EC1B  1C				DB	1CH					; Enter
 EC1C  27				DB	27H					; ;
 EC1D  28				DB	28H					; '
 EC1E  29				DB	29H					; `
 EC1F  2B				DB	2BH					; \
 EC20  33				DB	33H					; ,
 EC21  34				DB	34H					; .
 EC22  35				DB	35H					; /
 EC23  37				DB	37H					; * PrcSc
 = 000A				L_INT_KB_ALT_SKIP	EQU $-INT_KB_ALT_SKIP
				
				;----------------------------------------------------------------------------;
				; Resume scancode table at 45H (word aligned)
				;
 EC26						ORG	KEY_SCAN_TBL + 45H * 2
 EC26				KEY_SCAN_TBL_HIGH	LABEL BYTE
 EC26  0002[				DB	2 DUP(45H OR 80H)			; 45H		*Num Lock
	   C5			
			 ]	
				
 EC28  0002[				DB	2 DUP(46H OR 80H)			; 46H		*Scroll Lock
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-114


	   C6			
			 ]	
				
 EC2A  37 00				DB	'7', 0				; 47H		Home/7
 EC2C  38 00				DB	'8', 0				; 48H		Up/8
 EC2E  39 00				DB	'9', 0				; 49H		PgUp/9
 EC30  0002[				DB	2 DUP('-')				; 4AH		Keypad '-'
	   2D			
			 ]	
				
 EC32  34 00				DB	'4', 0				; 4BH		Left/4
 EC34  35 00				DB	'5', 0				; 4CH		Center/5
 EC36  36 00				DB	'6', 0				; 4DH		Right/6
 EC38  0002[				DB	2 DUP('+')				; 4EH		Keypad '+'
	   2B			
			 ]	
				
 EC3A  31 00				DB	'1', 0				; 4FH		End/1
 EC3C  32 00				DB	'2', 0				; 50H		Down/2
 EC3E  33 00				DB	'3', 0				; 51H		PgDn/3
 EC40  30 D2				DB	'0', 52H OR 80H			; 52H		*Ins/0
 EC42  2E 00				DB	'.', 0				; 53H		Del
 EC44  0002[				DB	2 DUP(0)				; 54H		SysReq
	   00			
			 ]	
				
 = 00AA				L_KEY_SCAN_TBL EQU $-KEY_SCAN_TBL
				
 EC46				INT_09 ENDP
				
				
				;
				; 7 BYTES HERE / 6 BYTES HERE 5150
				;
				BYTES_HERE	INT_13
 = 0013                      1	BYTES_HERE_INT_13 = INT_13-$ 
			     1			IFDEF BYTES_HERE_INT_13 
			     1			IF2 
			     1			ENDIF 
			     1			ENDIF 
				
				;----------------------------------------------------------------------------;
				; INT 13H - Diskette BIOS Services
				;----------------------------------------------------------------------------;
				;	INT 13,0  Reset disk system
				;	INT 13,1  Get disk status
				;	INT 13,2  Read disk sectors
				;	INT 13,3  Write disk sectors
				;	INT 13,4  Verify disk sectors
				;	INT 13,5  Format disk track
				;
				;  Typical params:
				;	AH = function request number
				;	AL = number of sectors	(1-128)
				;	CH = cylinder number	(0-1023)
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-115


				;	CL = sector number	(1-17)
				;	DH = head number		(0-15)
				;	DL = drive number		(0=A:, 1=B:, 80H=C:, 81H=D:) (for AH=2-5)
				;	ES:BX = address of user buffer
				;
				;  Output:
				;	CF = 0 if successful
				;	   = 1 if error
				;	AH = status of operation (https://stanislavs.org/helppc/int_13-1.html)
				;
				;----------------------------------------------------------------------------;
				;  All functions:
				;	- return FD_LAST_OP ([41H]) in AH
				;	- set CF if error
				;	- reset motor shutoff counter
				;
				;  Reference:
				;	https://stanislavs.org/helppc/int_13.html
				;	https://stanislavs.org/helppc/765.html
				;	NEC Microcomputers, Inc. PD765C Application Note 8 (Mar 1979)
				;
				;  Ports:
				;	3F0-3F7 Floppy disk controller (except PCjr)
				;	3F0 Diskette controller status A
				;	3F1 Diskette controller status B
				;	3F2 controller control port
				;	3F4 controller status register
				;	3F5 data register (write 1-9 byte command, see INT 13)
				;	3F6 Diskette controller data
				;	3F7 Diskette digital input
				;
				;----------------------------------------------------------------------------;
				
				;----------------------------------------------------------------------------;
				; Use indexed addressing to DI = FD_LAST_OP for byte savings.
				;
 = BYTE PTR [DI]		_FD_LAST_OP		EQU	BYTE PTR [DI]				; FD_LAST_OP
 = BYTE PTR [DI][FD_MOTOR_ST	_FD_MOTOR_ST	EQU	_FD_LAST_OP[FD_MOTOR_ST-FD_LAST_OP]	; FD_MOTOR_ST
   -FD_LAST_OP]			
 = BYTE PTR [DI][FD_CAL_ST-F	_FD_CAL_ST		EQU	_FD_LAST_OP[FD_CAL_ST-FD_LAST_OP]	; FD_CAL_ST
   D_LAST_OP]			
 = BYTE PTR [DI][FD_TRACK-FD	_FD_TRACK		EQU	_FD_LAST_OP[FD_TRACK-FD_LAST_OP]	; FD_TRACK
   _LAST_OP]			
 = BYTE PTR [DI][FD_MEDIA_ST	_FD_MEDIA_ST	EQU	_FD_LAST_OP[FD_MEDIA_ST-FD_LAST_OP]	; FD_MEDIA_ST
   -FD_LAST_OP]			
 = BYTE PTR [DI][TIMER-FD_LA	_FD_TIMER		EQU	_FD_LAST_OP[TIMER-FD_LAST_OP]		; TIMER
   ST_OP]			
 = [DI][FDC_LAST_ST-FD_LAST_	_FDC_LAST_ST	EQU	[DI][FDC_LAST_ST-FD_LAST_OP]		; FDC_LAST_ST
   OP]				
				
 EC59						ORG 0EC59H
 EC59				INT_13 PROC
						ASSUME DS:_BDA
 EC59  FB				STI 						; enable interrupts
 EC5A  FC				CLD
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-116


					PUSHX	DS, DI				; save caller registers
			     1				IFNB <DS>			; exit if last reg 
 EC5B  1E                    1		PUSH	DS 					; push register and repeat 
			     1		PUSHX	DI, , , , , ,  
			     2				IFNB <DI>			; exit if last reg 
 EC5C  57                    2		PUSH	DI 					; push register and repeat 
			     2		PUSHX	, , , , , ,  
			     2				ENDIF 
			     1				ENDIF 
 EC5D  BF ---- R			MOV	DI, SEG _BDA			; DS = BDA
 EC60  8E DF				MOV	DS, DI
 EC62  47				INC	DI					; DI = FD_LAST_OP throughout
 EC63  80 65 FE 7F			AND	_FD_MOTOR_ST, NOT MASK FWRT	; clear write operation flag
 EC67  80 FC 01				CMP	AH, 1 				; AH = 1?
 EC6A  74 77				JE	INT_13_1 				; AH = 1, jump to Status
					PUSHX	DX, CX, BX				; save caller registers
			     1				IFNB <DX>			; exit if last reg 
 EC6C  52                    1		PUSH	DX 					; push register and repeat 
			     1		PUSHX	CX, BX, , , , ,  
			     2				IFNB <CX>			; exit if last reg 
 EC6D  51                    2		PUSH	CX 					; push register and repeat 
			     2		PUSHX	BX, , , , , ,  
			     3				IFNB <BX>			; exit if last reg 
 EC6E  53                    3		PUSH	BX 					; push register and repeat 
			     3		PUSHX	, , , , , ,  
			     3				ENDIF 
			     2				ENDIF 
			     1				ENDIF 
 EC6F  C6 05 00				MOV	_FD_LAST_OP, FDC_ST_OK		; clear last operation
 EC72  72 24				JB	INT_13_0 				; AH = 0, jump to Reset
 EC74  80 FA 03				CMP	DL, 3 				; is drive number > 3?
 EC77  77 05				JA	INT_13_BAD_CMD 			; if so, exit
 EC79  80 FC 06				CMP	AH, 6 				; AH = 2 through 5?
 EC7C  72 71				JB	INT_13_2_5 				; jump to FDC RWVF command
 EC7E				INT_13_BAD_CMD:
 EC7E  FE 05				INC	_FD_LAST_OP				; otherwise return "bad command" (1)
 EC80				INT_13_DONE:
 EC80  8A 25				MOV	AH, _FD_LAST_OP 			; AH = last operation status
 EC82				INT_13_SET_MOTOR_CT:
 EC82  93				XCHG	AX, BX				; save AL
 EC83  B0 02				MOV	AL, DBT.FMCT 			; INT_1E[2] = motor shutoff counter
 EC85  E8 EF48 R			CALL	INT_1E_PARAM 			; AL = shutoff counter value (37)
 EC88  A2 0040 R			MOV	FD_MOTOR_CT, AL 			; update in BDA
 EC8B  93				XCHG	AX, BX				; restore AL
 EC8C				INT_13_EXIT:
					POPX	BX, CX, DX				; restore caller registers
			     1				IFNB <BX>			; exit if last reg 
 EC8C  5B                    1		POP	BX 					; pop register and repeat 
			     1		POPX	CX, DX, , , , ,  
			     2				IFNB <CX>			; exit if last reg 
 EC8D  59                    2		POP	CX 					; pop register and repeat 
			     2		POPX	DX, , , , , ,  
			     3				IFNB <DX>			; exit if last reg 
 EC8E  5A                    3		POP	DX 					; pop register and repeat 
			     3		POPX	, , , , , ,  
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-117


			     3				ENDIF 
			     2				ENDIF 
			     1				ENDIF 
 EC8F				INT_13_EXIT_1:
					POPX	DI, DS				; restore caller registers
			     1				IFNB <DI>			; exit if last reg 
 EC8F  5F                    1		POP	DI 					; pop register and repeat 
			     1		POPX	DS, , , , , ,  
			     2				IFNB <DS>			; exit if last reg 
 EC90  1F                    2		POP	DS 					; pop register and repeat 
			     2		POPX	, , , , , ,  
			     2				ENDIF 
			     1				ENDIF 
 EC91  80 FC 01				CMP	AH, FDC_ST_OK+1			; check AH for error (CF = AH < 1)
 EC94  F5				CMC   					; invert CF for return (CF = ! CF)
					IRET_F 					; return from int with current flags
 EC95  CA 0002               1		RETF	2 
				
				;----------------------------------------------------------------------------;
				; INT 13, 0: Reset disk system
				;----------------------------------------------------------------------------;
				; Performs hard reset on FDC controller
				;
				; Input:
				;	AH = 00
				;	DL = drive number (0=A:, 1=2nd floppy, 80h=drive 0, 81h=drive 1)
				;		(unused - drive is determined by BDA motor status)
				;
				; Output:
				;	AH = disk operation status  (see INT 13,STATUS)
				;	CF = 0 if successful
				;	   = 1 if error
				;
				; To Convert FD_MOTOR_ST to FDC byte use the following table/formula:
				;	Motors On 	Drive #
				;	0 0 0 0	 	- 			AND with 1111, jump if AL = 0
				;	1 x x x		3			TEST bit 1000, if non-zero then AL = 3
				;	0 1 0 x		2 			Shift right once and AL will be correct
				;	0 0 1 x		1 			"
				;	0 0 0 x	 	0			"
				;
				;----------------------------------------------------------------------------;
				; Things you must do:
				;
				;	- if a motor flag is on in BDA, turn it on in the FDC also
				;	- clear reset flag in controller and pull heads to track 0
				;	- set ALL disks need recalibration on next seek (Why all drives?)
				;	- setting the controller reset flag causes the disk to recalibrate
				;	  	on the next disk operation
				;	- if bit 7 is set, the diskette drive indicated by the lower 7 bits
				;		will reset then the hard disk will follow; return code in AH is
				;		for the drive requested (this is done by HD BIOS)
				;----------------------------------------------------------------------------;
 EC98				INT_13_0 PROC
 EC98  BA 03F2				MOV	DX, FDC_CTRL			; port 3F2H, FDC Digital Output
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-118


 EC9B  FA				CLI 						; disable interrupts
 EC9C  A0 003F R			MOV	AL, FD_MOTOR_ST 			; 3FH - Diskette motor status
 EC9F  8A E8				MOV	CH, AL 				; save to CH
 ECA1  24 0F				AND	AL, MASK FMOT			; isolate motor status flags
 ECA3  74 0E				JZ	INT_13_0_2				; jump if no motors are on, default to 0
				
				;----------------------------------------------------------------------------;
				; One motor is on (according to BDA). Convert motor run flags to binary number
				; since FDC requires a drive index for the reset.
				;
 ECA5  D0 E8				SHR	AL, 1					; disregard low bit (will be 0 either way)
 ECA7  A8 04				TEST	AL, MASK FMOT3 SHR 1		; test for drive 3?
 ECA9  74 02				JZ	INT_13_0_1				; if not drive 3, AL is now correct
 ECAB  B0 03				MOV	AL, 3 				; otherwise set AL to drive 3
 ECAD				INT_13_0_1:
							ELSE
 ECAD  B1 04				MOV	CL, 4 				; move low nibble of FD_MOTOR_ST
 ECAF  D2 E5				SHL	CH, CL				;  into high nibble of CH
 ECB1  0A C5				OR	AL, CH 				; combine nibbles with AL
							ENDIF
				
				;----------------------------------------------------------------------------;
				; Reset the controller by holding FDC reset (bit 2) at 0.
				; Perform the following memory operations here to satisfy reset timing for FDC:
				; - Flag all drives for recalibration (not just the drive in DL)
				;
 ECB3				INT_13_0_2:
 ECB3  0C 08				OR	AL, MASK FDDMA			; enable DMA & I/O interface, FDC reset
 ECB5  EE				OUT	DX, AL				; send to FDC
 ECB6  88 65 FD				MOV	_FD_CAL_ST, AH 			; flag all drives for recalibration
				
				;----------------------------------------------------------------------------;
				; Re-enable FDC by setting bit 2 to 1.
				; Wait for Interrupt (WIF) from FDC
				;
 ECB9  0C 04				OR	AL, MASK FDCEN			; set FDC enable
 ECBB  EE				OUT	DX, AL				; send to FDC
 ECBC  FB				STI 						; enable interrupts
 ECBD  E8 EEDD R			CALL	FDC_WAIT_SENSE			; wait for FDC to signal interrupt
 ECC0  72 04				JC	INT_13_0_RESET_BAD		; jump if FDC read/sense error
 ECC2  3C C0				CMP	AL, FDC_ST0 < 11B >		; was successful reset?
 ECC4  74 02				JZ	INT_13_0_RESET_DONE		; jump if success, AH = 0
 ECC6				INT_13_0_RESET_BAD:
 ECC6  B4 20				MOV	AH, FDC_ST_ERR_FDC		; otherwise, controller failure
 ECC8				INT_13_0_RESET_DONE:
 ECC8  88 25				MOV	_FD_LAST_OP, AH			; set last result
 ECCA  75 B6				JNZ	INT_13_SET_MOTOR_CT		; exit on error with AH already set
				
				;----------------------------------------------------------------------------;
				; (Re)send Specify bytes to FDC
				;
 ECCC  B0 03				MOV	AL, FDC_CMD_SPEC 			; [0] FDC Specify command
 ECCE  E8 EE9A R			CALL	FDC_SEND 				; send command in AL, CF if error
 ECD1  72 0C				JC	INT_13_0_DONE
 ECD3  B0 00				MOV	AL, DBT.SRT				; [1] step rate time, head unload time
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-119


 ECD5  E8 EE97 R			CALL	FDC_SEND_PARAM
 ECD8  72 05				JC	INT_13_0_DONE
 ECDA  B0 01				MOV	AL, DBT.HLT_ND			; [2] head load time (01H), DMA mode (ND)
 ECDC  E8 EE97 R			CALL	FDC_SEND_PARAM
				
				;----------------------------------------------------------------------------;
				; Exit and return with AL = 0
				;
 ECDF				INT_13_0_DONE:
 ECDF  B0 00				MOV	AL, 0					; 0 sectors read
 ECE1  EB 9D				JMP	SHORT INT_13_DONE
 ECE3				INT_13_0 ENDP
				
				;----------------------------------------------------------------------------;
				; INT 13, 1: Get disk status
				;----------------------------------------------------------------------------;
				; Output: AL and AH = status of last operation
				;----------------------------------------------------------------------------;
 ECE3				INT_13_1 PROC
 ECE3  8A 05				MOV	AL, _FD_LAST_OP 			; AL = last operation status
 ECE5  8A E0				MOV	AH, AL				; AH = last operation status
 ECE7  EB A6				JMP	SHORT INT_13_EXIT_1
 ECE9				INT_13_1 ENDP
				
				;----------------------------------------------------------------------------;
				; DMA page boundary overrun
				;
 ECE9				FDC_DMA_BOUND:
 ECE9  80 0D 09				OR	_FD_LAST_OP, FDC_ST_DMA_64K	; DMA boundary error
 ECEC  F9				STC						; re-set CF
 ECED  EB 5E				JMP	SHORT FDC_INIT_DMA_EXIT		; rebalance stack and exit
				
				;----------------------------------------------------------------------------;
				; INT 13, AH=2-5: FDC read/write operations
				;----------------------------------------------------------------------------;
				; All commands:
				;
				; 	AL = number of sectors to read  (1-128 dec.)
				;	AH = function number
				;	CH = track/cylinder number  (0-1023 dec., see below)
				;	CL = sector number  (1-17 dec.)
				;	DH = head number  (0-15 dec.)
				;	DL = drive number (0=A:, 1=2nd floppy, 80h=drive 0, 81h=drive 1)
				;	ES:BX = pointer to buffer
				;----------------------------------------------------------------------------;
				; Things you must do:
				;
				;	1. Set FD_MOTOR_ST read/write flag for operation
				;	2. Motor ON (update BDA)
				;		- is motor already on? Skip wait for spin up
				;		- wait only for writes?
				;		- check if recalibration is necessary
				;	3. Set up DMA
				;	4. seek drive DL to cylinder CH, head DH
				; 	5. send command
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-120


				;	6. wait for interrupt
				;	7. fetch results
				;	8. Check FDC status bytes for result
				;
				; Things you should do:
				;	- Check if drive is valid? Check if exists in BDA and not a hard drive
				;----------------------------------------------------------------------------;
 ECEF				INT_13_2_5 PROC
 ECEF  86 C4				XCHG	AL, AH				; AL = function, AH = sectors to read
 ECF1  50				PUSH	AX					; save function, sector count
 ECF2  52				PUSH	DX					; save head, drive
 ECF3  B6 46				MOV	DH, DMA_MR <1,0,0,1,2> 		; set DMA read mode 1 (AH = 2)
 ECF5  3C 02				CMP	AL, 2					; is read?
 ECF7  74 0C				JE	INT_13_2_5_SETUP_DMA		; if so, proceed to setup
 ECF9  B6 42				MOV	DH, DMA_MR <1,0,0,0,2> 		; set DMA verify mode 0 (AH = 4)
 ECFB  3C 04				CMP	AL, 4					; is verify?
 ECFD  74 06				JE	INT_13_2_5_SETUP_DMA		; if so, proceed to setup
 ECFF  B6 4A				MOV	DH, DMA_MR <1,0,0,2,2> 		; else DMA write/format mode 2 (AH = 3,5)
 ED01  80 4D FE 80			OR	_FD_MOTOR_ST, MASK FWRT		; turn on write flag
 ED05				INT_13_2_5_SETUP_DMA:
 ED05  8A C6				MOV	AL, DH				; AL = DMA mode, AH = sectors to read
 ED07  E8 EDE8 R			CALL	FDC_SEEK 				; Turn on motor, CH = track, DL = drive
 ED0A  72 42				JC	INT_13_2_5_SEEK_ERR		; exit if seek error
											; fall through to set up DMA
				
				;----------------------------------------------------------------------------;
				; FDC_INIT_DMA: Configure DMA channel 2 for FDC operation
				;----------------------------------------------------------------------------;
				; Input:
				;  AH = sectors to read
				;  AL = DMA mode:
				;	01000110 (46H) - Read
				;	01000010 (42H) - Verify
				;	01001010 (4AH) - Write
				; 	01 			; Mode: Single mode select
				; 	  0  			; Address increment
				;	   0 			; Auto-initialization disable
				;	    xx		; 00=verify, 01=write, 10=read, 11=unused
				;	      10		; Channel 2 select
				;  ES:BX = pointer to buffer
				;
				; Output:
				;  CF = 0 success, 1 if error DMA exceeds segment
				;----------------------------------------------------------------------------;
				; Things you must do:
				;	- Calculate # of bytes to transfer by multiplying AL (sectors) by
				;		sector size in INT 1E Disk Base Table.
				;	- Calculate physical memory address from ES:BX and normalize to
				;		Paragraph:Offset (P:FFFFH).
				;	- Verify that Offset + Byte Count does not exceed the remaining
				;		space in that paragraph. The DMA controller can only select one
				;		paragraph bank at a time, so writes will NOT wrap to next para.
				;		Exit with DMA Boundary error if segment is exceeded.
				;	- Reset the high/low byte flip-flop (send any value to I/O port 0CH)
				;	- Set DMA mode for Channel 2 to either Verify, Read or Write/Format
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-121


				;	- Disable interrupts while programming DMA
				;	- Set the DMA Page (memory paragraph) for DMA channel 2 (I/O port 81H)
				;	- Set the DMA Byte Counter to size of transfer minus 1 (since
				;		DMA's counter is 0-indexed)
				;	- Set the DMA Address register to beginning of DMA buffer from ES:BX
				;	- Enable interrupts and unmask DMA Channel 2
				;
				;----------------------------------------------------------------------------;
				; References:
				;  https://pdf1.alldatasheet.com/datasheet-pdf/view/127822/AMD/8237A.html
				;  https://wiki.osdev.org/ISA_DMA#Floppy_Disk_DMA_Initialization
				;  https://stackoverflow.com/questions/52396915/how-to-write-assembly-language-to-make-dma-works
				;  https://userpages.umbc.edu/~squire/intel_book.pdf
				;----------------------------------------------------------------------------;
 ED0C				FDC_INIT_DMA:
 ED0C  51				PUSH	CX					; save track / sector
 ED0D  8C C2				MOV	DX, ES 				; get and shift ES by one nibble
							ELSE
 ED0F  B1 04				MOV	CL, 4					; DL = lowest and highest nibble of ES
 ED11  D3 C2				ROL	DX, CL				; DH = middle nibbles
							ENDIF
 ED13  E6 0B				OUT	DMA_MODE, AL			; write to DMA mode reg (port 0BH)
 ED15  32 C0				XOR	AL, AL				; AX = sectors to read << 8
 ED17  91				XCHG	AX, CX				; CX = sectors, AX = scratch
 ED18  B0 03				MOV	AL, DBT.FBPS			; get bytes/sector param (0=128, 1=256, 2=512, 3=102
				4)
 ED1A  E8 EF48 R			CALL	INT_1E_PARAM			; AL = shift count (default 2 => 512)
 ED1D  91				XCHG	AX, CX				; AX = sectors, CL = bytes per sector shifts
 ED1E  D1 E8				SHR	AX, 1					; adjust shift for bytes/sector * 128
 ED20  D3 E0				SHL	AX, CL				; AX = bytes to transfer (AX * 2^CL)
 ED22  48				DEC	AX					; AX = bytes to transfer - 1
 ED23  91				XCHG	AX, CX				; CX = bytes to transfer - 1
 ED24  8A C2				MOV	AL, DL				; AL = lowest and highest nibble of ES
 ED26  24 0F				AND	AL, 0FH				; AL = only high nibble of ES
 ED28  80 E2 F0				AND	DL, 0F0H				; DX = low three nibbles of ES (shifted left
				 1 nibble)
 ED2B  03 DA				ADD	BX, DX				; BX = DMA start offset for transfer
 ED2D  14 00				ADC	AL, 0					; AL = DMA page
 ED2F  8B D3				MOV	DX, BX				; check that buffer offset + length does not exceed 
				segment
 ED31  03 D1				ADD	DX, CX				; DX = DMA end offset, test for boundary overflow
 ED33  72 B4				JC	FDC_DMA_BOUND			; error if DMA access across 64k boundary
 ED35  FA				CLI						; Disable interrupts
 ED36  E6 0C				OUT	DMA_FF, AL				; DMA clear flip-flop (port 0CH) (any value)
 ED38  E6 81				OUT	DMA_P_C2, AL 			; set DMA Channel 2 Page Address Register (port 81H)
 ED3A  93				XCHG	AX, BX				; AL = address low byte, AH = high byte
 ED3B  E6 04				OUT	DMA_2_A, AL				;
 ED3D  86 C4				XCHG	AL, AH 				; AH = address low byte, AL = high byte
 ED3F  E6 04				OUT	DMA_2_A, AL				;
 ED41  91				XCHG	AX, CX				; AL = byte/count low byte, AH = high byte
 ED42  E6 05				OUT	DMA_2_C, AL				;
 ED44  86 C4				XCHG	AL, AH				; AH = byte/count low byte, AL = high byte
 ED46  E6 05				OUT	DMA_2_C, AL
 ED48  FB				STI						; Enable interrupts
 ED49  B0 02				MOV	AL, DMA_SMR <0, 2>		; DMA clear single channel 2 mask bit
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-122


 ED4B  E6 0A				OUT	DMA_MASK, AL			; Unmask DMA Channel 2 (port 0AH)
 ED4D				FDC_INIT_DMA_EXIT:
 ED4D  59				POP	CX					; CL = sector, CH = track
 ED4E				INT_13_2_5_SEEK_ERR:
 ED4E  5A				POP	DX 					; DL = drive, DH = head
 ED4F  58				POP	AX					; AL = function, AH = sectors to read
 ED50  72 8D				JC	INT_13_0_DONE			; exit if DMA error with AL = 0
				
				;----------------------------------------------------------------------------;
				; Set FDC command byte
				;
 ED52  B3 C5				MOV	BL, FDC_CB <1,,0,FDC_CMD_WR>	; FDC Write Data - Multi-Track, MFM
 ED54  3C 03				CMP	AL, 3 				; is write (AH=3)?
 ED56  74 08				JE	FDC_RWVF				; jump if write
 ED58  B3 4D				MOV	BL, FDC_CB <0,,0,FDC_CMD_FMT>	; FDC Format Track - Single-Track, MFM
 ED5A  3C 05				CMP	AL, 5 				; is format (AH=5)?
 ED5C  74 02				JE	FDC_RWVF 				; jump if format
 ED5E  B3 E6				MOV	BL, FDC_CB <1,,1,FDC_CMD_RD>	; FDC Read/Verify - MT, MFM, Skip deleted
											; else read (AH=2,4)
 ED60				FDC_RWVF:
 ED60  93				XCHG	AX, BX				; AL = FDC cmd byte, BL = function
				
				;----------------------------------------------------------------------------;
				; FDC_RWVF: read, write, verify or format sectors
				;----------------------------------------------------------------------------;
				; Input:
				;	AL = FDC command byte
				;	BL = INT 13h function number
				;	BH = sectors to read
				;	DL = drive (0-3)
				;	DH = head (0-1)
				;----------------------------------------------------------------------------;
 ED61  E8 EE9A R			CALL	FDC_SEND 				; [0] send command in AL, CF if error
 ED64  72 64				JC	FDC_RWV_ERR
 ED66  8A C6				MOV	AL, DH				; AL/DH = head, DL=drive
 ED68  D0 E0				SHL	AL, 1					; [1] head / drive byte: 
 ED6A  D0 E0				SHL	AL, 1					;  xxxxx     ; unused
 ED6C  0A C2				OR	AL, DL 				;       h    ; head number (bit 3)
 ED6E  24 07				AND	AL, MASK FC1HD OR MASK FC1DS	;        dd  ; drive number (bit 1,2)
 ED70  E8 EE9A R			CALL	FDC_SEND 				; send command in AL, CF if error
 ED73  72 55				JC	FDC_RWV_ERR
 ED75  80 FB 05				CMP	BL, 5					; is format?
 ED78  74 53				JE	FDC_FORMAT
				
				;----------------------------------------------------------------------------;
				; FDC_RWV: read, write or verify sectors
				;----------------------------------------------------------------------------;
				; Input:
				;	CH = track/cylinder number (0-39)
				;	CL = sector number (1-17)
				;	DH = head number (0-1) (bounds not checked)
				;
				; Output:
				;	AL = number of sectors read, written or verified
				;----------------------------------------------------------------------------;
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-123


 ED7A				FDC_RWV PROC
 ED7A  8A C5				MOV	AL, CH 				; [2] cylinder number
 ED7C  E8 EE9A R			CALL	FDC_SEND 				; send command in AL, CF if error
 ED7F  72 49				JC	FDC_RWV_ERR
 ED81  8A C6				MOV	AL, DH 				; [3] head number
 ED83  E8 EE9A R			CALL	FDC_SEND 				; send command in AL, CF if error
 ED86  72 42				JC	FDC_RWV_ERR
 ED88  8A C1				MOV	AL, CL 				; [4] sector number
 ED8A  E8 EE9A R			CALL	FDC_SEND 				; send command in AL, CF if error
 ED8D  72 3B				JC	FDC_RWV_ERR
 ED8F  B0 03				MOV	AL, DBT.FBPS			; [5] bytes per sector
 ED91  E8 EE97 R			CALL	FDC_SEND_PARAM			; 2 = 512 bytes
 ED94  72 34				JC	FDC_RWV_ERR
 ED96  B0 04				MOV	AL, DBT.SPT				; [6] end of track (last sector in track)
 ED98  E8 EE97 R			CALL	FDC_SEND_PARAM
 ED9B  72 2D				JC	FDC_RWV_ERR
 ED9D  8A D8				MOV	BL, AL				; BL = sectors per track
 ED9F  B0 05				MOV	AL, DBT.SGAP			; [7] sector gap length
 EDA1  E8 EE97 R			CALL	FDC_SEND_PARAM
 EDA4  72 24				JC	FDC_RWV_ERR
 EDA6  B0 06				MOV	AL, DBT.LSEC			; [8] data length (if cmd byte 5==0)
				
				;----------------------------------------------------------------------------;
				; Send last param and wait for status
				;
 EDA8				FDC_RWV_SEND_WAIT:
 EDA8  E8 EE97 R			CALL	FDC_SEND_PARAM
 EDAB  72 1D				JC	FDC_RWV_ERR
 EDAD  E8 EF1B R			CALL	FDC_WAIT_STATUS			; wait for WIF and get status
							IF FDC_ERR_SEC_CT NE 1
 EDB0  72 18				JC	FDC_RWV_ERR				; if error, report 0 sectors read
							ENDIF
											; fall through for FDC SEC COUNT
				
				;----------------------------------------------------------------------------;
				; FDC_SEC_COUNT: get the number of sectors read/verified/written
				;----------------------------------------------------------------------------;
				; Input:
				;	BL = sectors per track (1-9)
				;	BH = number of sectors to read
				;	CH = start track/cylinder number (0-39)
				;	CL = start sector number (1-17)
				;	DH = head number (0-1)
				; Output:
				;	AL = sectors transferred
				;	AH = preserved
				;
				; Note: If the operation finishes at the last head/sector of a track, 
				;	FDC will report the head/track/sector position to be the beginning 
				;	of the next track.
				;----------------------------------------------------------------------------;
 EDB2				FDC_SEC_COUNT:
 EDB2  A0 0047 R			MOV	AL, FDC_LAST_ST.SEC		; AL = FDC reported end sector
 EDB5  8A D5				MOV	DL, CH				; DL = start track
 EDB7  3B 55 04				CMP	DX, WORD PTR _FDC_LAST_ST.CYL	; rolled to next head or track?
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-124


 EDBA  74 09				JE	FDC_SEC_COUNT_SAME		; if not, ended on the same head/track
				
				;----------------------------------------------------------------------------;
				; Command has ended on a different head or track. Calculate the correct
				; number of sectors spanned.
				;
 EDBC  3A 75 05				CMP	DH, _FDC_LAST_ST.HEAD		; end on same head but different track?
 EDBF  75 02				JNE	FDC_SEC_COUNT_SAME_CYL		; if so, has spanned a full head
 EDC1  02 C3				ADD	AL, BL				; add two tracks worth of sectors
 EDC3				FDC_SEC_COUNT_SAME_CYL:
 EDC3  02 C3				ADD	AL, BL				; add ending sector
 EDC5				FDC_SEC_COUNT_SAME:
 EDC5  2A C1				SUB	AL, CL				; AL = ending - starting = sec read
					;CMP	AL, BH				; verify requested # of sectors was
											; # actually read (not necessary).
				
 EDC7				FDC_RWV ENDP					; fall through for exit
				
				;----------------------------------------------------------------------------;
				; Done with all disk operations and return AL
				;
 EDC7				INT_13_2_5_EXIT:
 EDC7  E9 EC80 R			JMP	INT_13_DONE
				
				;----------------------------------------------------------------------------;
				; Clear AL and exit on any read/write error
				;
 EDCA				FDC_RWV_ERR:
 EDCA				FDC_FORMAT_ERR:
 EDCA  E9 ECDF R			JMP	INT_13_0_DONE			; on error: exit with sectors read = 0
				
				;----------------------------------------------------------------------------;
				; INT 13, 5: Format Track
				;----------------------------------------------------------------------------;
				; Input:
				;	AH = 05
				;	AL = interleave value (XT only) / sectors per track
				;	CX = track/cylinder number (see below for format)
				;	DL = head number  (0-15 dec.)
				;	ES:BX = pointer to block of "track address fields" (provided by DOS)
				;----------------------------------------------------------------------------;
 EDCD				FDC_FORMAT PROC
 EDCD  B0 03				MOV	AL, DBT.FBPS			; [2] bytes per sector
 EDCF  E8 EE97 R			CALL	FDC_SEND_PARAM
 EDD2  72 F6				JC	FDC_FORMAT_ERR
 EDD4  B0 04				MOV	AL, DBT.SPT				; [3] sectors per track
 EDD6  E8 EE97 R			CALL	FDC_SEND_PARAM
 EDD9  72 EF				JC	FDC_FORMAT_ERR
 EDDB  B0 07				MOV	AL, DBT.FGAP			; [4] format gap length
 EDDD  E8 EE97 R			CALL	FDC_SEND_PARAM
 EDE0  72 E8				JC	FDC_FORMAT_ERR
 EDE2  B0 08				MOV	AL, DBT.FFILL			; [5] format fill byte
 EDE4  B1 01				MOV	CL, 1					; format always starts at sector 1
 EDE6  EB C0				JMP	SHORT FDC_RWV_SEND_WAIT		; send, wait for WIF and get status
 EDE8				FDC_FORMAT ENDP
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-125


				
 EDE8				INT_13_2_5 ENDP
				
				;----------------------------------------------------------------------------;
				; FDC_SEEK: Seek to track
				;----------------------------------------------------------------------------;
				; Input:
				;	CH = track
				;	DL = drive (0-3) (bounds not checked)
				;	DI = OFFSET FD_LAST_OP
				;----------------------------------------------------------------------------;
 EDE8				FDC_SEEK PROC
 EDE8  50				PUSH	AX
 EDE9  53				PUSH	BX
 EDEA  E8 EE34 R			CALL	FDC_RECAL 				; recalibrate if needed
 EDED  72 3F				JC	FDC_SEEK_RECAL_ERR		; exit if recal error
				
							IF FDC_ADV_SEEK EQ 1
				;----------------------------------------------------------------------------;
				; If FDC_ADV_SEEK, the current track where the head is positioned is saved in
				; the BDA so that a subsequent operation on the same track will not require
				; another seek. This may result in performance improvements on sequential reads.
				;
 EDEF  75 04				JNZ	FDC_CHECK_SEEK			; recal not needed, check if seek
				
				;----------------------------------------------------------------------------;
				; Recal was executed and now on track 0. Just do a head settle if it was
				; the destination track.
				;
 EDF1  84 ED				TEST	CH, CH				; destination track 0?
 EDF3  74 2C				JZ	FDC_SEEK_SETTLE			; if so, skip to head settle time
				
				;----------------------------------------------------------------------------;
				; Check BDA to see if head is already positioned at the destination track.
				;
 EDF5				FDC_CHECK_SEEK:
 EDF5  32 FF				XOR	BH, BH
 EDF7  8A DA				MOV	BL, DL				; BX = drive #
 EDF9  38 69 53				CMP	_FD_TRACK[BX], CH			; compare last track seek to dest
 EDFC  74 2D				JE	FDC_SEEK_DONE			; already on track - nothing to do
							ENDIF				; end IF FDC_ADV_SEEK
				
 EDFE  B0 0F				MOV	AL, FDC_CMD_SEEK			; seek command (0FH)
 EE00  E8 EE9A R			CALL	FDC_SEND 				; send command, CF if error
 EE03  72 29				JC	FDC_SEEK_ERR
 EE05  8A C2				MOV	AL, DL 				; AL = drive number
 EE07  E8 EE9A R			CALL	FDC_SEND 				; send command, CF if error
 EE0A  72 22				JC	FDC_SEEK_ERR			; necessary?
 EE0C  8A C5				MOV	AL, CH 				; AL = track number
 EE0E  E8 EE9A R			CALL	FDC_SEND 				; send command, CF if error
 EE11  72 1B				JC	FDC_SEEK_ERR
 EE13  E8 EEDD R			CALL	FDC_WAIT_SENSE			; wait for WIF, sense and get status
 EE16  72 16				JC	FDC_SEEK_ERR
 EE18  34 60				XOR	AL, FDC_ST0 <01B, 1>		; select abnormal term, seek complete
 EE1A  24 60				AND	AL, FDC_ST0 <01B, 1>		; ZF = abnormal term AND seek complete
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-126


 EE1C  74 10				JZ	FDC_SEEK_ERR
							IF FDC_ADV_SEEK EQ 1
 EE1E  88 69 53				MOV	_FD_TRACK[BX], CH			; save last seeked track (BX = drv #)
							ENDIF
				
				;----------------------------------------------------------------------------;
				; Allow time for heads to settle after seek. This may be skipped on emulators.
				;
 EE21				FDC_SEEK_SETTLE:
							IF ARCH_TYPE NE ARCH_EMU
 EE21  B8 0009				MOV	AX, DBT.HDST			; AH=0 JIC (AH=0 from FDC_WAIT_SENSE)
 EE24  E8 EF48 R			CALL	INT_1E_PARAM			; AL = head settle time (ms)
 EE27  E8 E647 R			CALL	IO_DELAY_MS_FDC			; delay AX ms
							ENDIF
 EE2A  F8				CLC						; no error
 EE2B				FDC_SEEK_DONE:
 EE2B  5B				POP	BX
 EE2C  58				POP	AX
 EE2D  C3				RET
				
 EE2E				FDC_SEEK_RECAL_ERR:
 EE2E				FDC_SEEK_ERR:
 EE2E  80 0D 40				OR	_FD_LAST_OP, FDC_ST_ERR_SEEK
 EE31  F9				STC
 EE32  EB F7				JMP	SHORT FDC_SEEK_DONE
 EE34				FDC_SEEK ENDP
				
				;----------------------------------------------------------------------------;
				; FDC_RECAL: recalibrate drive, if necessary
				;----------------------------------------------------------------------------;
				; Input:
				;	DL = drive to recalibrate (0-3) (bounds not checked)
				;	DI = OFFSET FD_LAST_OP
				; Output:
				;	CF if error
				;
				; Clobbers: AX, BX (if ADV_SEEK)
				;----------------------------------------------------------------------------;
 EE34				FDC_RECAL PROC
 EE34  51				PUSH	CX
				
				;----------------------------------------------------------------------------;
				; FDC_MOTOR_ON: Turn on motor
				;----------------------------------------------------------------------------;
				; Input:
				; 	DL = drive number (0-3) (bounds not checked)
				;----------------------------------------------------------------------------;
				; Things you must do:
				;	- is motor already on? Skip wait for spin up
				;	- wait only for writes?
				;	- check if recalibration is necessary
				;----------------------------------------------------------------------------;
 EE35				FDC_MOTOR_ON:
 EE35  8A CA				MOV	CL, DL 				; move to CL for shift
				
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-127


				;----------------------------------------------------------------------------;
				; Convert drive number to motor run format
				;
 EE37  B8 0110				MOV	AX, 110H 				; AH -> RUN_ST, AL -> FDC byte
 EE3A  D3 E0				SHL	AX, CL 				; shift drive flags
 EE3C  FA				CLI 						; disable interrupts
 EE3D  8A 6D FE				MOV	CH, _FD_MOTOR_ST			; get current RUN_ST
 EE40  84 EC				TEST	CH, AH 				; is drive already running?
 EE42  75 21				JNZ	FDC_DRIVE_STARTED			; skip startup if so
 EE44  0A C1				OR	AL, CL 				; combine drive number to FDC byte
 EE46  0C 0C				OR	AL, MASK FDDMA OR MASK FDCEN	; set DMA and controller enable flags
 EE48  52				PUSH	DX					; preserve DX
 EE49  BA 03F2				MOV	DX, FDC_CTRL			; turn on motor
 EE4C  EE				OUT	DX, AL				; port 3F2H, FDC Digital Output
 EE4D  5A				POP	DX
 EE4E  8A C5				MOV	AL, CH 				; AL = FD_MOTOR_ST
 EE50  8A EC				MOV	CH, AH				; CH = RUN_ST drive bit field
 EE52  24 F0				AND	AL, NOT MASK FMOT 		; clear motor status of FD_MOTOR_ST
 EE54  0A C4				OR	AL, AH				; combine nibbles, SF if write
 EE56  98				CBW						; restart timer to max for operation
 EE57  A3 003F R			MOV	WORD PTR FD_MOTOR_ST, AX	; write to motor status and timer
 EE5A  79 09				JNS	FDC_DRIVE_STARTED 		; delay for motor spinup if write op
				
				;----------------------------------------------------------------------------;
				; Delay using timer tick counter
				;
 EE5C  FB				STI 						; enable interrupts
 EE5D  B0 0A				MOV	AL, DBT.FMST			; AL = INT_1E[10]
 EE5F  E8 EF48 R			CALL	INT_1E_PARAM 			; AL = motor startup time (in 125ms)
 EE62  E8 E643 R			CALL	IO_WAIT_MS_125			; wait AL * 125ms
				
 EE65				FDC_DRIVE_STARTED:
 EE65  80 E5 0F				AND	CH, MASK FMOT			; isolate drives, remove write flag
 EE68  FB				STI 						; ensure interrupts enabled
				
				;----------------------------------------------------------------------------;
				; Calibrate drive if necessary
				;
 EE69  84 6D FD				TEST	CH, _FD_CAL_ST 			; 0 means drive is uncalibrated
 EE6C  75 22				JNZ	FDC_RECAL_DONE 			; if drive is calibrated, exit
 EE6E  B0 07				MOV	AL, FDC_CMD_RECAL 		; recalibrate command (07H)
 EE70  E8 EE9A R			CALL	FDC_SEND 				; send command, CF if error
 EE73  72 1B				JC	FDC_RECAL_ERR
 EE75  8A C1				MOV	AL, CL 				; AL = drive number
 EE77  E8 EE9A R			CALL	FDC_SEND 				; send command, CF if error
					;JC	FDC_RECAL_ERR			; (necessary?)
 EE7A  E8 EEDD R			CALL	FDC_WAIT_SENSE 			; wait for WIF, sense and get status in AL
 EE7D  72 11				JC	FDC_RECAL_ERR
 EE7F  34 60				XOR 	AL, FDC_ST0 <01B, 1>		; select abnormal term, seek complete
 EE81  24 60				AND	AL, FDC_ST0 <01B, 1>		; ZF = abnormal term AND seek complete
 EE83  F9				STC						; presume failure
 EE84  74 0A				JZ	FDC_RECAL_ERR			; jump if error
 EE86  08 6D FD				OR	_FD_CAL_ST, CH 			; mark drive as calibrated and CLC
				
							IF FDC_ADV_SEEK EQ 1
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-128


				;----------------------------------------------------------------------------;
				; Save track 0 to BDA FD_TRACK
				;
 EE89  32 FF				XOR	BH, BH				; track 0 and set ZF
 EE8B  8A DA				MOV	BL, DL				; BX = drive index
 EE8D  88 79 53				MOV	_FD_TRACK[BX], BH			; save last track seek 0
							ENDIF
				
 EE90				FDC_RECAL_ERR:
 EE90				FDC_RECAL_DONE:
 EE90  59				POP	CX
 EE91  C3				RET
 EE92				FDC_RECAL ENDP
				
				;----------------------------------------------------------------------------;
				; FDC_RECV: Wait for FDC ready to send and read next FDC Status byte into AL
				;----------------------------------------------------------------------------;
				; Timeout is 5 timer ticks = ~275ms.
				;
				; Input: None
				; Output:
				;	AL = top of FDC status stack
				;	AH = 80H if error, 0 if success
				;	CF if timeout or error
				;----------------------------------------------------------------------------;
 EE92				FDC_RECV PROC
 EE92  53				PUSH	BX
 EE93  33 DB				XOR	BX, BX				; flag is 0 if RECV operation
 EE95  EB 06				JMP	SHORT FDC_SEND_RECV
				
				;----------------------------------------------------------------------------;
				; FDC_SEND_PARAM: Wait for FDC ready and send a floppy param in AL
				;----------------------------------------------------------------------------;
				; Same as below except AL input is INT_1E param index
				;----------------------------------------------------------------------------;
 EE97				FDC_SEND_PARAM PROC
 EE97  E8 EF48 R			CALL	INT_1E_PARAM 			; AL = INT_1E[AL] param
				
				;----------------------------------------------------------------------------;
				; FDC_SEND: Wait for FDC ready to receive and send a single command
				;----------------------------------------------------------------------------;
				; Timeout is 5 timer ticks = ~275ms.
				;
				; Input:
				;	AL = byte to send to FDC
				;
				; Output:
				;	AL = status register
				;	AH = 80H if error, 0 if success
				;	CF and ZF if error
				;----------------------------------------------------------------------------;
 EE9A				FDC_SEND PROC
 EE9A  53				PUSH	BX
 EE9B  B3 01				MOV	BL, 1					; flag is 1 if SEND operation
				
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-129


 EE9D				FDC_SEND_RECV:
 EE9D  8A F8				MOV	BH, AL				; save byte to send
 EE9F  51				PUSH	CX
 EEA0  52				PUSH	DX 					; call-preserve used registers
				
				;----------------------------------------------------------------------------;
				; Wait for FDC I/O direction = CPU to FDC and Data Reg Ready
				;
 EEA1  BA 03F4				MOV	DX, FDC_STAT 			; port 3F4H - FDC Main Status Register
 EEA4  B9 0005				MOV	CX, 5					; CX = # of ticks to wait
 EEA7  8A 26 006C R			MOV	AH, BYTE PTR TIMER.LW		; get starting tick counter low byte
				
 EEAB				FDC_SEND_WAIT_POLL:
 EEAB  EC				IN	AL, DX				; AL = FDC status register
 EEAC  84 C0				TEST	AL, AL				; is DRR = I/O to/from CPU?
 EEAE  79 19				JNS	FDC_SEND_WAIT_TIMER		; if not, check if timeout has elapsed
				
				;----------------------------------------------------------------------------;
				; FDC is ready for I/O
				;
 EEB0  42				INC	DX 					; port 3F5H - FDC Command Status Register
 EEB1  84 DB				TEST	BL, BL				; is send or receive?
 EEB3  74 09				JZ	FDC_RECV_WAIT_POLL		; jump if receive
				
				;----------------------------------------------------------------------------;
				; SEND operation
				;----------------------------------------------------------------------------;
 EEB5				FDC_SEND_WAIT_POLL_1:
 EEB5  A8 40				TEST	AL, MASK FIOD			; is I/O direction = CPU to FDC (0)?
 EEB7  75 10				JNZ	FDC_SEND_WAIT_TIMER		; if not, check if timeout has elapsed
				
				;----------------------------------------------------------------------------;
				; Status is ready to send
				;
 EEB9				FDC_SEND_READY:
 EEB9  8A C7				MOV	AL, BH				; restore AL byte to send
 EEBB  EE				OUT	DX, AL				; send command
 EEBC  EB 05				JMP	SHORT FDC_WAIT_DONE		; status = success (0), CF = 0 and done
				
				;----------------------------------------------------------------------------;
				; RECEIVE operation
				;----------------------------------------------------------------------------;
 EEBE				FDC_RECV_WAIT_POLL:
 EEBE  A8 40				TEST	AL, MASK FIOD			; is I/O direction = FDC to CPU (1)?
 EEC0  74 07				JZ	FDC_SEND_WAIT_TIMER		; if not, check if timeout has elapsed
				
				;----------------------------------------------------------------------------;
				; Data is ready to read
				;
 EEC2				FDC_RECV_READY:
 EEC2  EC				IN	AL, DX				; read from FDC
				
				;----------------------------------------------------------------------------;
				; Completed with success
				;
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-130


 EEC3				FDC_WAIT_DONE:
 EEC3  32 E4				XOR	AH, AH 				; status = success (0), CF = 0
				
 EEC5				FDC_WAIT_EXIT:
 EEC5  5A				POP	DX
 EEC6  59				POP	CX
 EEC7  5B				POP	BX
 EEC8  C3				RET
				
				;----------------------------------------------------------------------------;
				; Check if timeout has expired
				;
 EEC9				FDC_SEND_WAIT_TIMER:
 EEC9  A0 006C R			MOV	AL, BYTE PTR TIMER.LW		; get current tick counter
 EECC  3A C4				CMP	AL, AH				; still the same?
 EECE  74 DB				JZ	FDC_SEND_WAIT_POLL		; loop if the same
 EED0  8A E0				MOV	AH, AL				; otherwise, save new tick value to AH
 EED2  E0 D7				LOOPNZ FDC_SEND_WAIT_POLL		; loop until # of ticks (CX) has elapsed
				
 EED4				FDC_WAIT_TIMEOUT:
 EED4  B4 80				MOV	AH, FDC_ST_TIMEOUT 		; time out, drive not ready error
 EED6  08 26 0041 R			OR	FD_LAST_OP, AH			; set flag in BDA
 EEDA  F9				STC						; set error
 EEDB  EB E8				JMP	SHORT	FDC_WAIT_EXIT
				
 EEDD				FDC_SEND ENDP
 EEDD				FDC_SEND_PARAM ENDP
 EEDD				FDC_RECV ENDP
				
				;----------------------------------------------------------------------------;
				; FDC_WAIT_SENSE: wait for WIF, sense status and get status bytes
				;----------------------------------------------------------------------------;
				; Output:
				;	CF if FDC read/timeout error
				;	NZ if result status error
				;	AL = FDC_LAST_ST (BDA Floppy drive status)
				;	AH = 0 if success, 80H if failure
				;----------------------------------------------------------------------------;
 EEDD				FDC_WAIT_SENSE PROC
 EEDD  E8 EF6A R			CALL	FDC_WAIT_INT 			; wait for WIF
 EEE0  72 2F				JC	FDC_WAIT_SENSE_EXIT
 EEE2  B0 08				MOV	AL, FDC_CMD_SENSE			; sense Interrupt status
 EEE4  E8 EE9A R			CALL	FDC_SEND
				
				;----------------------------------------------------------------------------;
				; FDC_RECV_STATUS:
				;----------------------------------------------------------------------------;
				; Output:
				;	CF if FDC read/timeout error
				;	NZ if result status error
				;
				;	AL = FDC_LAST_ST (BDA Floppy drive status), if success
				;	AH = 0 if success, 80H if failure
				;----------------------------------------------------------------------------;
 EEE7				FDC_RECV_STATUS PROC
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-131


 EEE7  72 28				JC	FDC_WAIT_SENSE_EXIT		; return if timeout error
											; fall through to FDC_RECV_ALL
				
				;----------------------------------------------------------------------------;
				; FDC_RECV_ALL: Pop all status bytes from FDC to BDA
				;----------------------------------------------------------------------------;
				; Check for FDC errors and set FD_LAST_OP if necessary
				; Input: DS = BDA (40H), DI = FD_LAST_OP (41H)
				; Output: AH = 0 if success, 80H if failure
				;----------------------------------------------------------------------------;
 EEE9				FDC_RECV_ALL PROC
 EEE9  06				PUSH	ES
 EEEA  51				PUSH	CX
 EEEB  57				PUSH	DI					; preserve DI (FD_LAST_OP)
 EEEC  52				PUSH	DX
 EEED  BA 03F4				MOV	DX, FDC_STAT
 EEF0  1E				PUSH	DS					; ES = BDA segment
 EEF1  07				POP	ES
 EEF2  47				INC	DI					; DI = FDC_LAST_ST (FDC Last Result)
 EEF3  B9 0007				MOV	CX, 7					; loop up to 7 FDC bytes
 EEF6				FDC_RECV_ALL_LOOP:
 EEF6  E8 EE92 R			CALL	FDC_RECV				; AL = next byte, AH = 0 if success
 EEF9  72 12				JC	FDC_RECV_ALL_DONE			; CF if failure
 EEFB  AA				STOSB						; write to BDA
				
				;----------------------------------------------------------------------------;
				; Additional delay for FDC to settle
				;
						IF IS_TURBO AND UNSAFE_FLOPPY NE 1
 EEFC  B0 14				MOV	AL, 20				; delay 372 clocks (~31us at 12MHz,
						ENDIF
 EEFE				FDC_RECV_DELAY:					; [7+19(AX-1)] clocks
 EEFE  48				DEC	AX					; [3]
 EEFF  75 FD				JNZ	FDC_RECV_DELAY			; [4+16(AX-1)]
				
				;----------------------------------------------------------------------------;
				; Check for additional bytes to be read from FDC registers
				;
 EF01  EC				IN	AL, DX				; DX = 03F4H
 EF02  24 10				AND	AL, MASK FDRW 			; is FDC R/W command in progress flag?
 EF04  E0 F0				LOOPNZ FDC_RECV_ALL_LOOP		; loop until no flag or 7 bytes read
 EF06  75 0A				JNZ	FDC_RECV_FDC_ERR			; command still in progress?
											; AL = 0 (no command in progress) or CX = 0
 EF08				FDC_RECV_CHECK_ERR:
 EF08  A0 0042 R			MOV	AL, FDC_LAST_ST.SB0 		; AL = last FDC status byte 0
 EF0B  A8 C0				TEST	AL, MASK ST0CS			; check Last Command Status
 EF0D				FDC_RECV_ALL_DONE:
 EF0D  5A				POP	DX
 EF0E  5F				POP	DI					; DI = FD_LAST_OP
 EF0F  59				POP	CX
 EF10  07				POP	ES
 EF11				FDC_WAIT_SENSE_EXIT:
 EF11  C3				RET
				
				;----------------------------------------------------------------------------;
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-132


				; Command still in progress after reading 7 bytes. Return FDC error.
				;
 EF12				FDC_RECV_FDC_ERR:
 EF12  B4 20				MOV	AH, FDC_ST_ERR_FDC		; controller still busy after
 EF14  08 26 0041 R			OR	FD_LAST_OP, AH			;  reading max bytes
 EF18  F9				STC
 EF19  EB F2				JMP	SHORT FDC_RECV_ALL_DONE
 EF1B				FDC_RECV_ALL ENDP
 EF1B				FDC_RECV_STATUS ENDP
 EF1B				FDC_WAIT_SENSE ENDP
				
				;----------------------------------------------------------------------------;
				; FDC_WAIT_STATUS: Wait for WIF, get status bytes and check for error
				;----------------------------------------------------------------------------;
 EF1B				FDC_WAIT_STATUS PROC
 EF1B  E8 EF6A R			CALL	FDC_WAIT_INT 			; wait for WIF
 EF1E  E8 EEE7 R			CALL	FDC_RECV_STATUS			; read FDC status into BDA
											; CF if FDC error, NZ if status error
 EF21  76 1C				JBE	FDC_WAIT_ERR_EXIT_OK		; exit if ZF or CF error
				
				;----------------------------------------------------------------------------;
				; FDC_WAIT_STATUS_ERR: Map FDC Command Status Register 1 to BDA error codes
				;----------------------------------------------------------------------------;
				; Input:
				;	AL = Last result from FDC_LAST_ST
				; Output:
				;	CF if error
				;	AH/AL = BDA Floppy drive status
				;----------------------------------------------------------------------------;
 EF23				FDC_WAIT_STATUS_ERR PROC
 EF23  A8 40				TEST	AL, FDC_ST0 < 01B >		; command terminated abnormally?
 EF25  B0 20				MOV	AL, FDC_ST_ERR_FDC		; if not, FDC error
 EF27  74 11				JZ	FDC_WAIT_STATUS_ERR_DONE
 EF29  98				CBW						; AH = 0
 EF2A  0A 65 02				OR	AH, _FDC_LAST_ST.SB1		; AH = last status byte 1, ZF if 0
 EF2D  74 0B				JZ	FDC_WAIT_STATUS_ERR_DONE	; skip if AH = 0
 EF2F  56				PUSH	SI
 EF30  BE EF40 R			MOV	SI, OFFSET FDC_ERR1_MAP
 EF33				FDC_ERR_MAP_LOOP:
 EF33  2E: AC				LODS	BYTE PTR CS:[SI]			; fetch next error byte
 EF35  D0 E4				SHL	AH, 1					; CF if this status flag
 EF37  77 FA				JA	FDC_ERR_MAP_LOOP			; loop if NC (not this flag)
 EF39  5E				POP	SI					;  and NZ (more flags to check)
 EF3A				FDC_WAIT_STATUS_ERR_DONE:
 EF3A  8A E0				MOV	AH, AL				; AH = last result
 EF3C				FDC_WAIT_ERR_EXIT:
 EF3C  08 25				OR	_FD_LAST_OP, AH			; BDA 40:41H
 EF3E  F9				STC
 EF3F				FDC_WAIT_ERR_EXIT_OK:
 EF3F  C3				RET
				
				;----------------------------------------------------------------------------;
				; FDC Status register to INT 13h error map
				; Note: Must check from most sig bit to lowest since higher
				; bits are more meaningful.
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-133


				;
 EF40				FDC_ERR1_MAP LABEL BYTE
 EF40  04				DB	FDC_ST_ERR_SEC			; 80 end of cylinder
 EF41  20				DB	FDC_ST_ERR_FDC			; 40 unused (always zero)
 EF42  10				DB	FDC_ST_ERR_CRC			; 20 data error CRC
 EF43  08				DB	FDC_ST_DMA_OVR			; 10 DMA timeout/overrun
 EF44  20				DB	FDC_ST_ERR_FDC			; 08 unused (always zero)
 EF45  04				DB	FDC_ST_ERR_SEC			; 04 Sector Not Found
 EF46  03				DB	FDC_ST_ERR_WP			; 02 Write Protect
 EF47  02				DB	FDC_ST_ERR_MARK			; 01 Address mark not found or bad sector
				
 EF48				FDC_WAIT_STATUS_ERR ENDP
 EF48				FDC_WAIT_STATUS ENDP
				
				;----------------------------------------------------------------------------;
				; Retrieve a parameter value from the DBT by index
				;----------------------------------------------------------------------------;
				; Input:
				;	AL = parameter index (bounds not checked)
				; Output:
				;	AL = byte
				;
				; Size: 14 bytes
				;----------------------------------------------------------------------------;
 EF48				INT_1E_PARAM PROC
 EF48  1E				PUSH	DS
 EF49  53				PUSH	BX
 EF4A  33 DB				XOR	BX, BX 				; BX = IVT
 EF4C  8E DB				MOV	DS, BX 				; DS = IVT
							ASSUME DS:_IVT
 EF4E  C5 1E 0078 R			LDS	BX, IVT_1E				; DS:BX = INT 1EH in IVT
 EF52  D7				XLAT 						; AL = byte
 EF53  5B				POP	BX
 EF54  1F				POP	DS
							ASSUME DS:NOTHING
 EF55  C3				RET
 EF56				INT_1E_PARAM ENDP
				
				;
				; 2 BYTES HERE
				;
				BYTES_HERE	INT_0E
 = 0001                      1	BYTES_HERE_INT_0E = INT_0E-$ 
			     1			IFDEF BYTES_HERE_INT_0E 
			     1			IF2 
			     1			ENDIF 
			     1			ENDIF 
				
				;----------------------------------------------------------------------------;
				; INT 0EH - Floppy Disk Interrupt IRQ6
				;----------------------------------------------------------------------------;
				; This interrupt is issued upon floppy disk I/O completion and sets the
				; floppy disk working interrupt flag at 40:3E, bit 7.
				;----------------------------------------------------------------------------;
 EF57						ORG 0EF57H
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-134


 EF57				INT_0E PROC
 EF57  FB				STI						; necessary?
 EF58  50				PUSH	AX
 EF59  1E				PUSH	DS
 EF5A  33 C0				XOR	AX, AX				; DS = BDA_ABS segment
 EF5C  8E D8				MOV	DS, AX
							ASSUME DS:_BDA_ABS
 EF5E  80 0E 043E R 80			OR	FD_CAL_ST_ABS, MASK FWIF	; turn on working interrupt flag
 EF63  B0 20				MOV	AL, EOI 				; End of Interrupt OCW
 EF65  E6 20				OUT	INT_P0, AL				; write EOI to port 0
 EF67  1F				POP	DS
							ASSUME DS:NOTHING
 EF68  58				POP	AX
 EF69  CF				IRET
 EF6A				INT_0E ENDP
				
				;----------------------------------------------------------------------------;
				; FDC_WAIT_INT: Wait for BDA Working Interrupt Flag from FDC
				;----------------------------------------------------------------------------;
				; Input: DS = BDA, DI = FD_LAST_OP
				; Output: CF if timeout
				;----------------------------------------------------------------------------;
 EF6A				FDC_WAIT_INT PROC
							ASSUME DS:_BDA
 EF6A  FB				STI						; ensure interrupts are on
 EF6B  50				PUSH	AX 					; call preserve regs
 EF6C  51				PUSH	CX
 EF6D  B9 0025				MOV	CX, 2 * (1000/55) + 1		; timeout ~2 sec (37 ticks)
 EF70				FDC_WAIT_INT_LOOP1:
 EF70  A1 006C R			MOV	AX, TIMER.LW			; AX = time ticks
 EF73				FDC_WAIT_INT_LOOP2:
 EF73  F6 45 FD 80			TEST	_FD_CAL_ST, MASK FWIF 		; check for WIF in FD_CAL_ST (3EH)
 EF77  75 0F				JNZ	FDC_WAIT_INT_OK			; if so, exit
							IF FDC_HLT_WAIT GT 0
 EF79  F4				HLT						; wait for any INT
							ENDIF
 EF7A  3B 06 006C R			CMP	AX, TIMER.LW			; has timer tick changed?
 EF7E  74 F3				JZ	FDC_WAIT_INT_LOOP2		; if not, wait for next INT
 EF80  E2 EE				LOOP	FDC_WAIT_INT_LOOP1		; decrement tick counter and resume loop
 EF82  80 0D 80				OR	_FD_LAST_OP, FDC_ST_TIMEOUT 	; FDC result set time out, drive not ready
 EF85  F9				STC
 EF86  EB 04				JMP	SHORT FDC_WAIT_INT_DONE
 EF88				FDC_WAIT_INT_OK:
 EF88  80 65 FD 7F			AND	_FD_CAL_ST, NOT MASK FWIF 	; clear working interrupt flag
 EF8C				FDC_WAIT_INT_DONE:
 EF8C  59				POP	CX
 EF8D  58				POP	AX
 EF8E  C3				RET
 EF8F				FDC_WAIT_INT ENDP
				
 EF8F				INT_13 ENDP
				
				
				;
				; 20 BYTES HERE
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-135


				;
				BYTES_HERE	INT_1E
 = 0038                      1	BYTES_HERE_INT_1E = INT_1E-$ 
			     1			IFDEF BYTES_HERE_INT_1E 
			     1			IF2 
			     1			ENDIF 
			     1			ENDIF 
				
				;----------------------------------------------------------------------------;
				; INT 1E - Disk Initialization Parameter Table Vector
				;----------------------------------------------------------------------------;
				; Provides a "pluggable" method to allow additional disk ROMs or DOS to 
				; replace this table.
				;
				;  00  Head Step Rate (SRT) = 0CH = 12ms
				;      Head Unload Time (HUT) = 15 x (16ms increments) = 240ms(?)
				;  01  Head Load Time = 2 (2ms increments) = 1, DMA flag (0 = use DMA)
				;  02  timer ticks to wait before disk motor shutoff = 37
				;  03  512 bytes per sector (0=128, 1=256, 2=512, 3=1024) = 2
				;  04  sectors per track (last sector number) = 8
				;  05  inter-block gap length/gap between sectors (mills) 42
				;  06  data length, if sector length not specified = 0FFH
				;  07  gap length between sectors for format (mills) 80
				;  08  fill byte for formatted sectors = 0F6H
				;  09  head settle time in milliseconds = 25
				;  0A  motor startup time in eighths of a second = 4
				;  MFM = 2
				;
				; https://stanislavs.org/helppc/dbt.html
				; https://stanislavs.org/helppc/765.html
				; https://stanislavs.org/helppc/int_1e.html
				;----------------------------------------------------------------------------;
 EFC7						ORG 	0EFC7H
 EFC7  CF			INT_1E	DBT 	<DNB <12, 15>, 0010B, 37, 2, 8, 42, 0FFH, 80, 0F6H, 25, 4>
 EFC8  02			
 EFC9  25			
 EFCA  02			
 EFCB  08			
 EFCC  2A			
 EFCD  FF			
 EFCE  50			
 EFCF  F6			
 EFD0  19			
 EFD1  04			
				
				
				;----------------------------------------------------------------------------;
				; INT 17 - Printer BIOS Services
				;----------------------------------------------------------------------------;
				;	INT 17,0   Print character
				;	INT 17,1   Initialize printer port
				;	INT 17,2   Read printer port status
				;
				; https://www.stanislavs.org/helppc/ports.html
				; https://en.wikipedia.org/wiki/Parallel_port#IBM_PC_implementation
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-136


				; http://www.techhelpmanual.com/907-parallel_printer_adapter_ports.html
				;----------------------------------------------------------------------------;
				; Things you must do (on all calls):
				; - Verify printer is within range 0-2.
				; - Verify printer index is detected and get I/O address.
				; - Return AH = 0 if any of the above are not met.
				; - Do the function call
				; - Get port status and return in AH for any valid calls.
				;----------------------------------------------------------------------------;
 EFD2						ORG 0EFD2H
 EFD2				INT_17 PROC
						ASSUME DS:_BDA
 EFD2  FB				STI 						; enable interrupts
 EFD3  83 FA 03				CMP	DX, LENGTH LPT_ADDR		; is port number valid?
 EFD6  73 4A				JAE	INT_17_IRET 			; if not, exit
					PUSHX	DX, DI, CX, AX, DS		; call-preserve working regs
			     1				IFNB <DX>			; exit if last reg 
 EFD8  52                    1		PUSH	DX 					; push register and repeat 
			     1		PUSHX	DI, CX, AX, DS, , ,  
			     2				IFNB <DI>			; exit if last reg 
 EFD9  57                    2		PUSH	DI 					; push register and repeat 
			     2		PUSHX	CX, AX, DS, , , ,  
			     3				IFNB <CX>			; exit if last reg 
 EFDA  51                    3		PUSH	CX 					; push register and repeat 
			     3		PUSHX	AX, DS, , , , ,  
			     4				IFNB <AX>			; exit if last reg 
 EFDB  50                    4		PUSH	AX 					; push register and repeat 
			     4		PUSHX	DS, , , , , ,  
			     5				IFNB <DS>			; exit if last reg 
 EFDC  1E                    5		PUSH	DS 					; push register and repeat 
			     5		PUSHX	, , , , , ,  
			     5				ENDIF 
			     4				ENDIF 
			     3				ENDIF 
			     2				ENDIF 
			     1				ENDIF 
 EFDD  B9 ---- R			MOV	CX, SEG _BDA 			; CH = 0, CL = 40H
 EFE0  8E D9				MOV	DS, CX				; DS = BDA
 EFE2  8B FA				MOV	DI, DX 				; DI = LPT port index (0-2)
 EFE4  8A 4D 78				MOV	CL, LPT_TIME_B[DI]		; CX = port timeout
 EFE7  D1 E7				SHL	DI, 1 				; convert to word-aligned index
 EFE9  8B 55 08				MOV	DX, LPT_ADDR_B[DI]		; DX = data port address
 EFEC  1F				POP	DS 					; restore DS
 EFED  85 D2				TEST	DX, DX 				; is port index valid (detected)?
 EFEF  74 2B				JZ	INT_17_DONE 			; if not, exit
 EFF1  FE CC				DEC	AH
 EFF3  74 2E				JZ	INT_17_1				; AH = 1 then init
 EFF5  7F 1D				JG	INT_17_2	 			; AH = 2 then status
											; AH = 0 fall through to print
				
				;----------------------------------------------------------------------------;
				; AH = 0 - Print Character
				;----------------------------------------------------------------------------;
				; Write character and returns status
				;
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-137


				; Input:
				;	AH = -1 (not 0)
				;	AL = character to print
				;	CX = timeout "value" (the number of 64k loops)
				;	DX = LPT data port (278, 378, 3BC)
				;
				; Output:
				;	AH = printer status, see AH = 2
				;
				;----------------------------------------------------------------------------;
				; 765	    |			- LCX		unused
				;    4    |			- LCIRQ	0 = IRQ disable, 1=IRQ enable for ACK
				;     3   |			- LCDR	1 = printer reads output,  (pin 17)
				;      2  |			- LCINI	0 = initialize printer,  (pin 16)
				;       1 |			- LCLF	1 = auto line feed,  (pin 14)
				;        0|			- LCOUT	1 = output data to printer,  (pin 1)
				; PRN_CTRL RECORD	LCX:3,LCIRQ:1,LCDR:1,LCINI:1,LCLF:1,LCOUT:1
				;----------------------------------------------------------------------------;
 EFF7				INT_17_0:
 EFF7  EE				OUT	DX, AL			; write the character to data port
 EFF8  42				INC	DX				; DX to status port
 EFF9				INT_17_0_TIMEOUT_LOOP:
 EFF9  33 FF				XOR	DI, DI			; set abitrary timeout counter
 EFFB				INT_17_0_BUSY_LOOP:
 EFFB  EC				IN	AL, DX			; read status port
 EFFC  A8 80				TEST	AL, MASK LPBZ 		; printer busy?
 EFFE  75 09				JNZ	INT_17_0_OK			; if not, toggle strobe pin and exit
 F000  4F				DEC	DI
 F001  75 F8				JNZ	INT_17_0_BUSY_LOOP
 F003  E2 F4				LOOP	INT_17_0_TIMEOUT_LOOP 	; loop BDA/LPT timeout value
 F005  0C 01				OR	AL, MASK LPTO		; printer timed out - set flag
 F007  EB 0F				JMP	SHORT INT_17_2_STATUS_2	; exit with status in AL
 F009				INT_17_0_OK:
 F009  B0 0D				MOV	AL, MASK LCDR OR MASK LCINI OR MASK LCOUT ; /strobe pin HIGH
 F00B  42				INC	DX 				; DX = control port
 F00C  52				PUSH	DX				; I/O delay
 F00D  EE				OUT	DX, AL
 F00E  5A				POP	DX				; I/O delay
 F00F  B0 0C				MOV	AL, MASK LCDR OR MASK LCINI	; /strobe pin LOW
 F011  EE				OUT	DX, AL
 F012  4A				DEC	DX 				; reset to data port
 F013  4A				DEC	DX				; and fall through to status
				
				;----------------------------------------------------------------------------;
				; AH = 2 - Read printer port status
				;----------------------------------------------------------------------------;
				; Return status of specified printer port
				;
				; Input:
				;	AH = 1 (not 2)
				;	DX = LPT data port (278, 378, 3BC)
				;
				; Output:
				;	AH = status:
				;
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-138


				;		|7|6|5|4|3|2|1|0|  Printer status bits
				;		 | | | | | | | `---- time out		(always 0)
				;		 | | | | | `------- unused
				;		 | | | | `-------- I/O error		Pin 15
				;		 | | | `--------- selected		Pin 13
				;		 | | `---------- out of paper		Pin 12
				;		 | `----------- acknowledge		Pin 10
				;		 `------------ not busy			/Pin 11
				;
				; PRN_STAT RECORD	LPBZ:1,LPACK:1,LPOP:1,LPSEL:1,LPIO:1,LPX:2,LPTO:1
				;----------------------------------------------------------------------------;
 F014				INT_17_2:
 F014  42				INC	DX 				; DX to status port
 F015				INT_17_2_STATUS:
 F015  EC				IN	AL, DX			; AL = status
 F016  24 F8				AND	AL, NOT (MASK LPX OR MASK LPTO)	; mask time-out pins
 F018				INT_17_2_STATUS_2:
 F018  34 48				XOR	AL, MASK LPACK OR MASK LPIO ; acknowledge and error are active low
 F01A  8A E8				MOV	CH, AL			; save status to CH so AL can be restored
 F01C				INT_17_DONE:
 F01C  58				POP	AX				; restore AL
 F01D  8A E5				MOV	AH, CH			; AH = status
 F01F  59				POP	CX
 F020  5F				POP	DI
 F021  5A				POP	DX
 F022				INT_17_IRET:
 F022  CF				IRET
				
				;----------------------------------------------------------------------------;
				; AH = 1 - Initialize printer port
				;----------------------------------------------------------------------------;
				; Input:
				;	AH = 0 (not 1)
				;	DX = LPT data port (278, 378, 3BC)
				;
				; Output:
				;	AH = status, see AH = 2
				;----------------------------------------------------------------------------;
 F023				INT_17_1:
 F023  B0 08				MOV	AL, MASK LCDR		; printer reads output = 1
 F025  42				INC	DX
 F026  42				INC	DX				; DX = control port
 F027  EE				OUT	DX, AL			; send to control port
 F028  B5 08				MOV	CH, HIGH 800H		; delay 800H-ish loops
					IO_DELAY 				; wait, then CX = 0
 F02A                        1	??0028: 
 F02A  E2 FE                 1		LOOP	??0028					; long delay for I/O 
 F02C  0C 04				OR	AL, MASK LCINI		; initialize printer = 1
 F02E  EE				OUT	DX, AL			; send to control port
 F02F  4A				DEC	DX				; DX = status port
 F030  EB E3				JMP	SHORT INT_17_2_STATUS	; small delay, read status and return
 F032				INT_17 ENDP
				
 F032				CRLF_SHOW_CURSOR PROC
				;----------------------------------------------------------------------------;
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-139


				; CRLF then show cursor display (this exists to utilize the free bytes here)
				;----------------------------------------------------------------------------;
 F032  E8 F757 R			CALL	CRLF
				
				;----------------------------------------------------------------------------;
				; Show cursor display - restores saved cursor in CURSOR_DEFAULT
				;----------------------------------------------------------------------------;
				; Input:
				; 	DS = BDA
				; Clobbers CX
				;----------------------------------------------------------------------------;
 F035				SHOW_CURSOR PROC
							ASSUME DS:_BDA
 F035  8B 0E 00E8 R			MOV	CX, CURSOR_DEFAULT	; reset to original
 F039  EB 03				JMP	SHORT SET_CURSOR
				
				;----------------------------------------------------------------------------;
				; Hide cursor display
				;----------------------------------------------------------------------------;
				; Clobbers CX
				;----------------------------------------------------------------------------;
 F03B				HIDE_CURSOR PROC
 F03B  B9 2000				MOV	CX, DBW < 00100000b >	; hide cursor (CH bit 5 = 1)
				
				;----------------------------------------------------------------------------;
				; Set Video Cursor type
				;----------------------------------------------------------------------------;
				; Input:
				;	CX = cursor type
				;----------------------------------------------------------------------------;
 F03E				SET_CURSOR PROC
 F03E  50				PUSH	AX				; (not necessary)
 F03F  B4 01				MOV	AH, 1
 F041  CD 10				INT	10H
 F043  58				POP	AX
 F044  C3				RET
 F045				SET_CURSOR ENDP
				
 F045				HIDE_CURSOR ENDP
 F045				SHOW_CURSOR ENDP
 F045				CRLF_SHOW_CURSOR ENDP
				
				;
				; 0 BYTES HERE
				;
				BYTES_HERE	INT_10_JMP
 = 0000                      1	BYTES_HERE_INT_10_JMP = INT_10_JMP-$ 
			     1			IFDEF BYTES_HERE_INT_10_JMP 
			     1			IF2 
			     1			ENDIF 
			     1			ENDIF 
				
				;----------------------------------------------------------------------------;
				; INT 10h - Function Jump Table
				;----------------------------------------------------------------------------;
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-140


 F045						ORG 0F045H
 F045				INT_10_JMP LABEL WORD
 F045  F0E4 R				DW	OFFSET INT_10_0		; AH = 0 - Set video mode
 F047  F1A0 R				DW	OFFSET INT_10_1		; AH = 1 - Set cursor type
 F049  F1B6 R				DW	OFFSET INT_10_2		; AH = 2 - Set cursor position
 F04B  F1FC R				DW	OFFSET INT_10_3		; AH = 3 - Read cursor position
							IF LIGHT_PEN EQ 1
 F04D  F99F R				DW	OFFSET INT_10_4		; AH = 4 - Read light pen
							ENDIF
 F04F  F20D R				DW	OFFSET INT_10_5		; AH = 5 - Select active display page
 F051  F235 R				DW	OFFSET INT_10_6		; AH = 6 - Scroll active page up
 F053  F234 R				DW	OFFSET INT_10_7		; AH = 7 - Scroll active page down
 F055  F344 R				DW	OFFSET INT_10_8		; AH = 8 - Read character and attribute at cursor
 F057  F3DF R				DW	OFFSET INT_10_9		; AH = 9 - Write character and attribute at cursor
 F059  F3DF R				DW	OFFSET INT_10_A		; AH = A - Write character at current cursor
 F05B  F4C3 R				DW	OFFSET INT_10_B		; AH = B - Set color palette
 F05D  F4EE R				DW	OFFSET INT_10_C		; AH = C - Write graphics pixel at coordinate
 F05F  F50F R				DW	OFFSET INT_10_D		; AH = D - Read graphics pixel at coordinate
 F061  F55F R				DW	OFFSET INT_10_E		; AH = E - Write text in teletype mode
 F063  F5C9 R				DW	OFFSET INT_10_F		; AH = F - Get current video state
 = 0010				L_INT_10_JMP	EQU	($-INT_10_JMP)/2
				
				;----------------------------------------------------------------------------;
				; INT 10h - Video BIOS Services
				;----------------------------------------------------------------------------;
				; BIOS Interface to CGA/MDA display adapters.
				;----------------------------------------------------------------------------;
				; References and Info Sources:
				;  "PC System Programming", Tischer
				;  "Programmer's Guide to PC Video Systems", Second Edition, Wilton
				;  https://github.com/joncampbell123/dosbox-x/blob/master/src/ints/int10_char.cpp
				;  https://github.com/joncampbell123/dosbox-x/issues/256
				;  https://www.seasip.info/VintagePC/cga.html
				;  https://www.reenigne.org/blog/crtc-emulation-for-mess/
				;  (many other posts and articles...)
				;
				; Thx to @Raffzahn for "clean room" specs for various display routines.
				;----------------------------------------------------------------------------;
 F065						ORG 0F065H
 F065				INT_10 PROC
 F065  FB				STI					; enable interrupts
 F066  80 FC 0F				CMP	AH, L_INT_10_JMP-1	; function valid?
 F069  77 19				JA	INT_10_IRET			; exit if function not valid
					PUSHX	ES, DS, DI			; always preserve these registers
			     1				IFNB <ES>			; exit if last reg 
 F06B  06                    1		PUSH	ES 					; push register and repeat 
			     1		PUSHX	DS, DI, , , , ,  
			     2				IFNB <DS>			; exit if last reg 
 F06C  1E                    2		PUSH	DS 					; push register and repeat 
			     2		PUSHX	DI, , , , , ,  
			     3				IFNB <DI>			; exit if last reg 
 F06D  57                    3		PUSH	DI 					; push register and repeat 
			     3		PUSHX	, , , , , ,  
			     3				ENDIF 
			     2				ENDIF 
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-141


			     1				ENDIF 
 F06E  FC				CLD					; string instructions forward direction
 F06F  BF ---- R			MOV	DI, SEG _BDA		; DS = BDA segment
 F072  8E DF				MOV	DS, DI
 F074  8B F8				MOV	DI, AX			; save AX
 F076  86 E0				XCHG	AH, AL			; AL = function, AH = video mode
 F078  D0 E0				SHL	AL, 1				; word align index
 F07A  98				CBW					; AX = jump index
 F07B  97				XCHG	AX, DI			; restore AX, DI = jump offset
 F07C  2E: FF 95 F045 R			CALL	CS:INT_10_JMP[DI]
 F081				INT_10_DONE:
					POPX	DI, DS, ES
			     1				IFNB <DI>			; exit if last reg 
 F081  5F                    1		POP	DI 					; pop register and repeat 
			     1		POPX	DS, ES, , , , ,  
			     2				IFNB <DS>			; exit if last reg 
 F082  1F                    2		POP	DS 					; pop register and repeat 
			     2		POPX	ES, , , , , ,  
			     3				IFNB <ES>			; exit if last reg 
 F083  07                    3		POP	ES 					; pop register and repeat 
			     3		POPX	, , , , , ,  
			     3				ENDIF 
			     2				ENDIF 
			     1				ENDIF 
 F084				INT_10_IRET:
 F084  CF				IRET
				
				;----------------------------------------------------------------------------;
				; Is Current video mode text or GFX?
				;----------------------------------------------------------------------------;
				; Input:
				; 	DS = BDA (040h)
				; Output:
				;	AL = current video mode
				; 	ZF = 0 if CGA GFX (modes 4-6)
				;	ZF = 1 if CGA/MDA Text (modes 0-3 and 7)
				;	CF = 1 if MDA
				;----------------------------------------------------------------------------;
 F085				INT_10_IS_TXT PROC
 F085  A0 0049 R			MOV	AL, VID_MODE
 F088  3C 07				CMP	AL, 7				; ZF if mode MDA
 F08A  F5				CMC					; CF if MDA
 F08B  74 02				JZ	INT_10_IS_TXT_DONE
 F08D  A8 04				TEST	AL, 4 AND 5 AND 6		; NZ if GFX modes 4,5,6?
 F08F				INT_10_IS_TXT_DONE:
 F08F  C3				RET
 F090				INT_10_IS_TXT ENDP
				
				;----------------------------------------------------------------------------;
				; Is Current video CGA 80 col?
				;----------------------------------------------------------------------------;
				; Output:
				;	ZF = 1 if mode is 2 or 3
				;	ZF = 0 all others
				;----------------------------------------------------------------------------;
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-142


 F090				INT_10_IS_CGA80 PROC
 F090  50				PUSH	AX
 F091  1E				PUSH	DS
 F092  B8 ---- R			MOV	AX, SEG _BDA
 F095  8E D8				MOV	DS, AX
 F097  A0 0049 R			MOV	AL, VID_MODE
 F09A  3C 02				CMP	AL, 2				; is mode 2?
 F09C  74 02				JZ	INT_10_IS_CGA80_DONE
 F09E  3C 03				CMP	AL, 3				; is mode 3?
 F0A0				INT_10_IS_CGA80_DONE:
 F0A0  1F				POP	DS
 F0A1  58				POP	AX
 F0A2  C3				RET
 F0A3				INT_10_IS_CGA80 ENDP
				
				;
				; 1 BYTE HERE
				;
				BYTES_HERE	INT_1D
 = 0001                      1	BYTES_HERE_INT_1D = INT_1D-$ 
			     1			IFDEF BYTES_HERE_INT_1D 
			     1			IF2 
			     1			ENDIF 
			     1			ENDIF 
				
				;----------------------------------------------------------------------------;
				; INT 1D - Video mode register value table 
				;----------------------------------------------------------------------------;
				; https://stanislavs.org/helppc/6845.html
				;----------------------------------------------------------------------------;
 F0A4						ORG 0F0A4H					; 116 bytes
 F0A4				INT_1D PROC
				
				; 40x25 CGA text
 F0A4  38			INT_1D_40		CRTC	<38H,28H,2DH,0AH,1FH,06H,19H,1CH,02H,07H,06H,07H>
 F0A5  28			
 F0A6  2D			
 F0A7  0A			
 F0A8  1F			
 F0A9  06			
 F0AA  19			
 F0AB  1C			
 F0AC  02			
 F0AD  07			
 F0AE  06			
 F0AF  07			
 F0B0  00			
 F0B1  00			
 F0B2  00			
 F0B3  00			
				
 = 0000				O_INT_1D_40		EQU	INT_1D_40-INT_1D		; 40x25 mode data offset
				
				; 80x25 CGA text
						ELSE
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-143


 F0B4  71			INT_1D_80		CRTC	<71H,50H,5AH,0AH,1FH,06H,19H,1CH,02H,07H,06H,07H>
 F0B5  50			
 F0B6  5A			
 F0B7  0A			
 F0B8  1F			
 F0B9  06			
 F0BA  19			
 F0BB  1C			
 F0BC  02			
 F0BD  07			
 F0BE  06			
 F0BF  07			
 F0C0  00			
 F0C1  00			
 F0C2  00			
 F0C3  00			
				
						ENDIF
 = 0010				O_INT_1D_80		EQU	INT_1D_80-INT_1D		; 80x25 mode data offset
				
				; 320x200 CGA graphics
 F0C4  38			INT_1D_GFX		CRTC	<38H,28H,2DH,0AH,7FH,06H,64H,70H,02H,01H,06H,07H>
 F0C5  28			
 F0C6  2D			
 F0C7  0A			
 F0C8  7F			
 F0C9  06			
 F0CA  64			
 F0CB  70			
 F0CC  02			
 F0CD  01			
 F0CE  06			
 F0CF  07			
 F0D0  00			
 F0D1  00			
 F0D2  00			
 F0D3  00			
				
 = 0020				O_INT_1D_GFX	EQU	INT_1D_GFX-INT_1D		; 320x200 mode data offset
				
				; MDA text
 F0D4  61			INT_1D_MDA		CRTC	<61H,50H,52H,0FH,19H,06H,19H,19H,02H,0DH,0BH,0CH>
 F0D5  50			
 F0D6  52			
 F0D7  0F			
 F0D8  19			
 F0D9  06			
 F0DA  19			
 F0DB  19			
 F0DC  02			
 F0DD  0D			
 F0DE  0B			
 F0DF  0C			
 F0E0  00			
 F0E1  00			
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-144


 F0E2  00			
 F0E3  00			
				
 = 0030				O_INT_1D_MDA	EQU	INT_1D_MDA-INT_1D		; MDA mode data offset
				
 F0E4				INT_1D ENDP
				
				;----------------------------------------------------------------------------;
				; INT 10,0 - Set video mode
				;----------------------------------------------------------------------------;
				; AL = video mode:
				;   0000  00  M 40x25 B/W text (CGA)
				;   0001  01  C 40x25 16 color text (CGA)
				;   0010  02  M 80x25 16 shades of gray text (CGA)
				;   0011  03  C 80x25 16 color text (CGA)
				;   0100  04  C 320x200 4 color graphics (CGA)
				;   0101  05  C 320x200 4 color graphics (CGA)
				;   0110  06  M 640x200 B/W graphics (CGA)
				;   0111  07  M 80x25 Monochrome text (MDA,HERC)
				;
				; Clobbers: ES
				;----------------------------------------------------------------------------;
				; Things you must do:
				; 	1. Check that the new video mode is valid: 0-7. For MDA, the mode
				;		will always be 7. If CGA mode > 6, reset in current mode.
				;	2. Clear the video BDA block data
				;	3. Determine the type of adapter from motherboard switches
				;	4. Disable the adapter to reprogram it.
				;	5. Based on new input mode and MB switches, determine:
				;		- Adapter base I/O port (03B4H for MDA, 03D4H for CGA)
				;		- RAM base segment (0B000H for MDA, 0B800H for CGA)
				;		- RAM size (16K for CGA gfx, 4K for 80x25 text, 2K for 40x25 text)
				;		- RAM fill data (0 for gfx, space char with attribute 7 for text)
				;		- Corresponding entry from INT 1DH CRTD table for new video mode
				;		- Corresponding mode byte from CRT_MODE table
				;	6. Clear regen RAM by filling with data from above
				;	7. Write data from CRTD table to adapter registers to set mode
				;	8. Write CGA palette register
				;	9. Enable adapter with new mode byte
				;
				;----------------------------------------------------------------------------;
 F0E4				INT_10_0 PROC
							ELSE
					PUSHX	BX, DX, BP, CX, SI
			     1				IFNB <BX>			; exit if last reg 
 F0E4  53                    1		PUSH	BX 					; push register and repeat 
			     1		PUSHX	DX, BP, CX, SI, , ,  
			     2				IFNB <DX>			; exit if last reg 
 F0E5  52                    2		PUSH	DX 					; push register and repeat 
			     2		PUSHX	BP, CX, SI, , , ,  
			     3				IFNB <BP>			; exit if last reg 
 F0E6  55                    3		PUSH	BP 					; push register and repeat 
			     3		PUSHX	CX, SI, , , , ,  
			     4				IFNB <CX>			; exit if last reg 
 F0E7  51                    4		PUSH	CX 					; push register and repeat 
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-145


			     4		PUSHX	SI, , , , , ,  
			     5				IFNB <SI>			; exit if last reg 
 F0E8  56                    5		PUSH	SI 					; push register and repeat 
			     5		PUSHX	, , , , , ,  
			     5				ENDIF 
			     4				ENDIF 
			     3				ENDIF 
			     2				ENDIF 
			     1				ENDIF 
							ENDIF
 F0E9  BF 0049 R			MOV	DI, OFFSET VID_MODE		; start with VID_MODE (49H)
 F0EC  3C 07				CMP	AL, 7					; is new video mode > 7?
 F0EE  72 02				JB	INT_10_0_1				; if not, is valid mode
 F0F0  8A 05				MOV	AL, [DI]				; otherwise use current mode
 F0F2				INT_10_0_1:
 F0F2  93				XCHG	AX, BX				; BL = new video mode
				
				;----------------------------------------------------------------------------;
				; Clear all video data in BDA
				;
 F0F3  33 C0				XOR	AX, AX
 F0F5  B9 000F				MOV	CX, L_VID_BDA / 2			; Video data in BDA (in WORDs)
 F0F8  1E				PUSH	DS
 F0F9  07				POP	ES					; ES = BDA
 F0FA  F3/ AB				REP	STOSW					; clear data, set CX = 0
				
				;----------------------------------------------------------------------------;
				; Determine video adapter type and new mode and re-program 6845
				;
					CMP_EFLAG VID, VID_MDA			; is switch MDA (ON, ON)?
			     1	;----------------------------------------------------------------------------; 
			     1	; Shift if flag is in high byte to low for byte operations 
			     1	; 
			     1				IF VID LT 8		; is in low byte? 
 = 0030                      1	??002B	= MASK VID 
 = 0004                      1	??002C	= VID AND 0111B 
 = 0010                      1	??002D	= EQUIP_FLAGS[0]			; low BDA flags byte 
			     1				ENDIF 
 F0FC  A0 0010 R             1		MOV	AL, BYTE PTR ??002D 
 F0FF  24 30                 1		AND	AL, ??002B 
 F101  3C 30                 1		CMP	AL, VID_MDA SHL ??002C 
 F103  8A C1				MOV	AL, CL				; 0 = CGA disable video signal
 F105  BE 0010				MOV	SI, O_INT_1D_80			; SI = CGA 80 CRTD offset
 F108  B7 50				MOV	BH, VID_DEF_COLS			; default 80 columns
 F10A  B5 10				MOV	CH, HIGH SIZE MDA_MEM		; Total MDA video memory = 1000H (4K)
 F10C  8A E5				MOV	AH, CH				; MDA/CGA 80x25 page size = 1000H (4K)
 F10E  BF 0720				MOV	DI, DBW <VID_ATTR<>, VID_SP>	; fill memory with attr and space
 F111  75 0E				JNE	INT_10_0_IS_CGA			; jump if not MDA
 F113  40				INC	AX					; 1 = MDA disable video signal value
 F114  BD ---- R			MOV	BP, SEG _MDA_MEM			; BP = MDA memory segment (0B000H)
 F117  BA 03B8				MOV	DX, MDA_CTRL			; MDA Mode Select Register (03B8H)
 F11A  B3 07				MOV	BL, 7					; only valid MDA display mode is 7
 F11C  BE 0030				MOV	SI, O_INT_1D_MDA			; SI = MDA CRTD offset
 F11F  EB 26				JMP	SHORT INT_10_0_DETECT_DONE	; MDA mode selected, continue
 F121				INT_10_0_IS_CGA:
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-146


 F121  B5 40				MOV	CH, HIGH CGA_MEM_SZ		; Total CGA video memory = 4000H (16K)
 F123  BA 03D8				MOV	DX, CGA_CTRL			; CGA Mode Select Register (3D8H)
 F126  BD ---- R			MOV	BP, SEG _CGA_MEM			; BP = CGA memory segment (0B800H)
 F129  F6 C3 04				TEST	BL, 0100B				; text or gfx mode?
 F12C  74 0E				JZ	INT_10_0_IS_CGA_TEXT		; jump if text
 F12E				INT_10_0_IS_CGA_GFX:
 F12E  BE 0020				MOV	SI, O_INT_1D_GFX			; SI = CGA GFX CRTD offset
 F131  B4 40				MOV	AH, HIGH CGA_MEM_SZ		; CGA gfx page size = 4000H (16K)
 F133  33 FF				XOR	DI, DI				; DI = memory fill 0's
 F135  F6 C3 02				TEST	BL, 0010B				; is 80 or 40 col text?
 F138  75 0D				JNZ	INT_10_0_DETECT_DONE		; jump if 80
 F13A  EB 09				JMP	SHORT INT_10_0_IS_40_COL	; else set 40 columns
 F13C				INT_10_0_IS_CGA_TEXT:
 F13C  F6 C3 02				TEST	BL, 0010B				; is 80 or 40 col text?
 F13F  75 06				JNZ	INT_10_0_DETECT_DONE		; jump if 80
 F141  B4 08				MOV	AH, HIGH SIZE CGA_MEM_40	; CGA 40x25 page size = 800H (2K)
 F143  33 F6				XOR	SI, SI				; SI = CGA 40 CRTD offset (00H)
 F145				INT_10_0_IS_40_COL:
 F145  D0 EF				SHR	BH, 1					; BH = 40 columns
 F147				INT_10_0_DETECT_DONE:
 F147  89 1E 0049 R			MOV	WORD PTR VID_MODE, BX		; write BDA video mode and columns
 F14B  8E C5				MOV	ES, BP				; ES = video memory segment
 F14D  89 2E 00EA R			MOV	VID_MEM_SEG, BP			; write video segment for later
 F151  EE				OUT	DX, AL				; disable video
 F152  88 26 004D R			MOV	BYTE PTR VID_BUF_SZ[1], AH	; write BDA video page size
 F156  83 EA 04				SUB	DX, CGA_CTRL-CGA_IDX		; DX = 6845 index register port
 F159  89 16 0063 R			MOV	VID_PORT, DX			; write BDA video I/O port
 F15D  8B EB				MOV	BP, BX				; save video mode to BP
				
				;----------------------------------------------------------------------------;
				; Fill video regen/memory
				;
 F15F  97				XCHG	AX, DI				; AX = fill byte
 F160  33 FF				XOR	DI, DI				; start at offset 0
 F162  D1 E9				SHR	CX, 1					; WORD size counter
 F164  F3/ AB				REP	STOSW
				
				;----------------------------------------------------------------------------;
				; Write CRTC data to 6845 registers
				;
 F166  1E				PUSH	DS					; save DS = BDA
 F167  8B C1				MOV	AX, CX				; AX = 0
 F169  A2 0062 R			MOV	VID_PAGE, AL			; video page 1 = 0
 F16C  8E D8				MOV	DS, AX				; DS = IVT
							ASSUME DS:_IVT
 F16E  C5 1E 0074 R			LDS	BX, IVT_1D				; DS:BX = BIOS:INT_1D
							ASSUME DS:NOTHING
 F172  8B 78 0A				MOV	DI, WORD PTR [BX][SI].CSL	; DI = cursor type (start and end)
 F175  B1 10				MOV	CL, SIZE CRTC			; size of CRTC data
 F177				INT_10_0_CRTC_LOOP:
 F177  8A 20				MOV	AH, [BX][SI]			; AH = next byte from table
 F179  EF				OUT	DX, AX				; write AH to register index AL
 F17A  40				INC	AX					; next register index
 F17B  46				INC	SI					; next byte in table
 F17C  E2 F9				LOOP	INT_10_0_CRTC_LOOP
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-147


				
				;----------------------------------------------------------------------------;
				; Send mode and color bytes to display adapter
				;
 F17E  95				XCHG	AX, BP				; AL = new video mode
 F17F  3C 06				CMP	AL, 6					; is CGA color gfx mode?
 F181  B4 3F				MOV	AH, VID_CSGFX <>			; use for 640x200 mode 6
 F183  74 02				JE	INT_10_0_COLOR_BYTE		; jump if so
 F185  B4 30				MOV	AH, VID_CSTXT <>			; otherwise use for text/low gfx
 F187				INT_10_0_COLOR_BYTE:
 F187  BB F5F5 R			MOV	BX, OFFSET CRT_MODE
 F18A  2E: D7				XLAT	CS:[BX]				; AL = control byte data
 F18C  1F				POP	DS					; DS = BDA
							ASSUME DS:_BDA
 F18D  83 C2 04				ADD	DX, CGA_CTRL-CGA_IDX		; DX = control reg port (3D8H)
 F190  A3 0065 R			MOV	WORD PTR VID_MODE_REG, AX	; write mode and color to BDA
 F193  EF				OUT	DX, AX				; write mode and color to adapter
 F194  97				XCHG	AX, DI				; AX = cursor bytes from CRTC table
 F195  86 E0				XCHG	AH, AL				; convert endian for cursor bytes
 F197  A3 0060 R			MOV	VID_CURS_TYPE, AX			; write cursor type to BDA
							ELSE
					POPX	SI, CX, BP, DX, BX
			     1				IFNB <SI>			; exit if last reg 
 F19A  5E                    1		POP	SI 					; pop register and repeat 
			     1		POPX	CX, BP, DX, BX, , ,  
			     2				IFNB <CX>			; exit if last reg 
 F19B  59                    2		POP	CX 					; pop register and repeat 
			     2		POPX	BP, DX, BX, , , ,  
			     3				IFNB <BP>			; exit if last reg 
 F19C  5D                    3		POP	BP 					; pop register and repeat 
			     3		POPX	DX, BX, , , , ,  
			     4				IFNB <DX>			; exit if last reg 
 F19D  5A                    4		POP	DX 					; pop register and repeat 
			     4		POPX	BX, , , , , ,  
			     5				IFNB <BX>			; exit if last reg 
 F19E  5B                    5		POP	BX 					; pop register and repeat 
			     5		POPX	, , , , , ,  
			     5				ENDIF 
			     4				ENDIF 
			     3				ENDIF 
			     2				ENDIF 
			     1				ENDIF 
							ENDIF
 F19F				INT_10_RET:
 F19F  C3				RET
 F1A0				INT_10_0 ENDP
				
				;----------------------------------------------------------------------------;
				; INT 10,1 - Set cursor type
				;----------------------------------------------------------------------------;
				; Input:
				;	CH = cursor starting scan line (cursor top) (low order 5 bits)
				;	CL = cursor ending scan line (cursor bottom) (low order 5 bits)
				;----------------------------------------------------------------------------;
 F1A0				INT_10_1 PROC
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-148


 F1A0  52				PUSH	DX
 F1A1  97				XCHG	AX, DI			; save AX
 F1A2  89 0E 0060 R			MOV	VID_CURS_TYPE, CX		; write new cursor to BDA
 F1A6  B0 0A				MOV	AL, CRTC.CSL		; AL = cursor start index (scan line)
 F1A8  8A E5				MOV	AH, CH			; CH = cursor starting scan line (top)
 F1AA  8B 16 0063 R			MOV	DX, VID_PORT		; DX = 6845 index register port
 F1AE  EF				OUT	DX, AX			; write AH to 6845 reg index in AL
 F1AF  40				INC	AX				; AL = cursor end index (scan line)
 F1B0  8A E1				MOV	AH, CL			; CL = cursor ending scan line (bottom)
 F1B2  EF				OUT	DX, AX			; write AH to 6845 reg index in AL
 F1B3  97				XCHG	AX, DI			; restore AX
 F1B4  5A				POP	DX
 F1B5  C3				RET
 F1B6				INT_10_1 ENDP
				
				;----------------------------------------------------------------------------;
				; INT 10,2 - Set cursor position
				;----------------------------------------------------------------------------;
				; Input:
				;	AH = 02
				;	BH = page number (0 for graphics modes)
				;	DH = row
				;	DL = column
				;----------------------------------------------------------------------------;	
				; Things you must do:
				;	1. Update the BDA Cursor position (50H-5FH) with the new video page
				;		with the new cursor position
				;	2. Calculate the memory address of the cursor's position, and set it
				;		to the 6845 Cursor address register
				;
				; Things you should do:
				;	- Make sure page number is valid for adapter type and current mode
				;
				;----------------------------------------------------------------------------;	
 F1B6				INT_10_2 PROC
 F1B6  50				PUSH	AX
 F1B7  8A C7				MOV	AL, BH			; AL = new video page
 F1B9  3C 07				CMP	AL, 7				; is new video page > 7?
 F1BB  77 30				JA	INT_10_2_DONE		; if so, not valid, return
				
				;----------------------------------------------------------------------------;
				; 1. Set cursor position in BDA
				;
 F1BD  98				CBW					; AX = page number
 F1BE  97				XCHG	AX, DI			; DI = page number
 F1BF  D1 E7				SHL	DI, 1				; word align index
 F1C1  89 95 0050 R			MOV	VID_CURS_POS[DI], DX	; write to page cursor position in BDA
 F1C5  38 3E 0062 R			CMP	VID_PAGE, BH		; is this the current page?
				
 F1C9  75 22				JNE	INT_10_2_DONE		; if not, do nothing and exit
 F1CB  53				PUSH	BX
 F1CC  52				PUSH	DX
				
				;----------------------------------------------------------------------------;
				; 2. Set cursor position in 6845 Cursor address register
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-149


				;
 F1CD				INT_10_SET_CUR_OFFSET:
 F1CD  A0 004A R			MOV	AL, BYTE PTR VID_COLS	; AL = screen cols
 F1D0  F6 E6				MUL	DH				; AX = row * screen cols
 F1D2  32 F6				XOR	DH, DH			; DX = col
 F1D4  03 C2				ADD	AX, DX			; AX = ( row * screen cols ) + col
										; AX = byte offset for cursor position to page memor
				y
 F1D6  8B 1E 004E R			MOV	BX, VID_SEG
 F1DA  D1 EB				SHR	BX, 1				; byte align
 F1DC  03 D8				ADD	BX, AX
 F1DE  B0 0E				MOV	AL, CRTC.CA_H		; 6845 Cursor address high reg (0EH)
 F1E0  8A E7				MOV	AH, BH			; Cursor address (MSB)
 F1E2  8B 16 0063 R			MOV	DX, VID_PORT
 F1E6  EF				OUT	DX, AX			; write AH to index AL
 F1E7  40				INC	AX				; AL = CA_L (0FH)
 F1E8  8A E3				MOV	AH, BL			; Cursor address (LSB)
 F1EA  EF				OUT	DX, AX			; write AH to index AL
 F1EB  5A				POP	DX
 F1EC  5B				POP	BX
 F1ED				INT_10_2_DONE:
 F1ED  58				POP	AX
 F1EE  C3				RET
 F1EF				INT_10_2 ENDP
				
				;----------------------------------------------------------------------------;
				; INT 10,3 - Read cursor position and Size for current page
				;----------------------------------------------------------------------------;
				; Output:
				;	ZF = 0 and BH = 0 if MDA/CGA GFX
				;  	ZF = 1 and BH = VID_PAGE if CGA text
				;----------------------------------------------------------------------------;
 F1EF				INT_10_3_CUR_PAGE PROC
 F1EF  32 FF				XOR	BH, BH			; BH = 0
 F1F1  F6 06 0049 R 04			TEST	VID_MODE, 0100B		; is >= 4?
 F1F6  75 04				JNZ	INT_10_3			; jump if not MDA or GFX
 F1F8  8A 3E 0062 R			MOV	BH, VID_PAGE		; otherwise BH = VID_PAGE
				
				;----------------------------------------------------------------------------;
				; INT 10,3 - Read cursor position and Size
				;----------------------------------------------------------------------------;
				; Input:
				;	AH = 03
				;	BH = video page
				; Output:
				;	CH = cursor starting scan line (low order 5 bits)
				;	CL = cursor ending scan line (low order 5 bits)
				;	DH = row
				;	DL = column
				;----------------------------------------------------------------------------;
 F1FC				INT_10_3 PROC
 F1FC  50				PUSH	AX
 F1FD  8A C7				MOV	AL, BH			; AL = video page
 F1FF  98				CBW					; AX = video page
 F200  97				XCHG	AX, DI			; DI = video page
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-150


 F201  D1 E7				SHL	DI, 1				; word align index
 F203  8B 95 0050 R			MOV	DX, VID_CURS_POS[DI]
 F207  8B 0E 0060 R			MOV	CX, VID_CURS_TYPE
 F20B  58				POP	AX
 F20C  C3				RET
 F20D				INT_10_3 ENDP
 F20D				INT_10_3_CUR_PAGE ENDP
				
				;----------------------------------------------------------------------------;
				; INT 10,5 - Select active display page
				;----------------------------------------------------------------------------;
				; Input:
				;	AH = 05
				;	AL = new page number
				;----------------------------------------------------------------------------;
				; Things you must do:
				;	1. Write the new page number to BDA (40:62H)
				;	2. Calculate new regen buffer page offset and update BDA and
				;		6845 Start address register
				;	3. Calculate the memory address of the cursor's position, and set it
				;		to the 6845 Cursor address register
				;
				; Things you should do:
				;	- Bounds check that page number is valid for adapter and current mode?
				;----------------------------------------------------------------------------;
 F20D				INT_10_5 PROC
					PUSHX	AX, BX, DX			; call-preserve working registers
			     1				IFNB <AX>			; exit if last reg 
 F20D  50                    1		PUSH	AX 					; push register and repeat 
			     1		PUSHX	BX, DX, , , , ,  
			     2				IFNB <BX>			; exit if last reg 
 F20E  53                    2		PUSH	BX 					; push register and repeat 
			     2		PUSHX	DX, , , , , ,  
			     3				IFNB <DX>			; exit if last reg 
 F20F  52                    3		PUSH	DX 					; push register and repeat 
			     3		PUSHX	, , , , , ,  
			     3				ENDIF 
			     2				ENDIF 
			     1				ENDIF 
				
				;----------------------------------------------------------------------------;
				; 1. Write the new page number to BDA (40:62H).
				;
 F210  A2 0062 R			MOV	VID_PAGE, AL
 F213  98				CBW					; AX = video page
 F214  97				XCHG	AX, DI			; DI = page number (save for later)
				
				;----------------------------------------------------------------------------;
				; 2. Calculate new regen buffer page offset and update BDA and 
				;	6845 Start address register
				;
 F215  A1 004C R			MOV	AX, VID_BUF_SZ		; AX = Size of video regen buffer (bytes)
 F218  F7 E7				MUL	DI				; AX = offset of start of page regen buffer
 F21A  A3 004E R			MOV	VID_SEG, AX			; write to BDA
 F21D  D1 E8				SHR	AX, 1				; video segment byte-indexed
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-151


 F21F  8A D8				MOV	BL, AL			; AH = Start address (MSB), BL = (LSB)
 F221  B0 0C				MOV	AL, CRTC.SA_H		; 6845 Start address register
 F223  8B 16 0063 R			MOV	DX, VID_PORT		; 6845 I/O port address
 F227  EF				OUT	DX, AX			; write AH (MSB) to index AL
 F228  40				INC	AX				; AL = 0DH
 F229  8A E3				MOV	AH, BL			; AH = Start address (LSB)
 F22B  EF				OUT	DX, AX			; write AH (LSB) to index AL
				
				;----------------------------------------------------------------------------;
				; 3. Set cursor position in 6845 Cursor address register
				;
 F22C  D1 E7				SHL	DI, 1				; get the current cursor position
 F22E  8B 95 0050 R			MOV	DX, VID_CURS_POS[DI]	; DH/DL = cursor position on current page
 F232  EB 99				JMP	INT_10_SET_CUR_OFFSET	; write it to the new page's offset on 6845
				
 F234				INT_10_5 ENDP
				
				;----------------------------------------------------------------------------;
				; INT 10,7 - Scroll active page down
				;----------------------------------------------------------------------------;
				; Input:
				;	AL = number of lines to scroll, previous lines are
				;	     blanked, if 0 or AL > screen size, window is blanked
				;	BH = attribute to be used on blank line
				;	CH = row of upper left corner of scroll window
				;	CL = column of upper left corner of scroll window
				;	DH = row of lower right corner of scroll window
				;	DL = column of lower right corner of scroll window
				;----------------------------------------------------------------------------;
				;
				;   0000  00  M 40x25 B/W text (CGA)
				;   0001  01  C 40x25 16 color text (CGA)
				;   0010  02  M 80x25 16 shades of gray text (CGA)
				;   0011  03  C 80x25 16 color text (CGA)
				;   0100  04  C 320x200 4 color graphics (CGA)
				;   0101  05  C 320x200 4 color graphics (CGA)
				;   0110  06  M 640x200 B/W graphics (CGA)
				;   0111  07  M 80x25 Monochrome text (MDA)
				;----------------------------------------------------------------------------;
				; Things you must do:
				; 	1. Calculate coordinates of existing rectangle and new rectangle.
				;	2. Convert to memory video RAM addresses
				;	3. If CGA 80 col, disable video during video RAM operations
				;	4. If rows to scroll > 0, copy each row, starting at the left column.
				;	   If scroll up, start from the top of the overlapping area and copy
				;	   downward. If scroll down, start at the bottom and copy upward.
				;	5. If rows to scroll > height of rectangle, fill the remaining rows
				;	   with spaces.
				;
				;----------------------------------------------------------------------------;
				; NOTE: The original XT BIOS (and maybe clones) appear to have a bug where
				; if the lines to scroll (AL) is greater than the height of the rectangle
				; it will scroll incorrectly. This behavior has been preserved.
				;----------------------------------------------------------------------------;
 F234				INT_10_7 PROC
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-152


 F234  FD				STD					; Set direction flag
				
				;----------------------------------------------------------------------------;
				; INT 10,6 - Scroll active page up
				;----------------------------------------------------------------------------;
				; Input: same as INT 10,7 above
				;----------------------------------------------------------------------------;
 F235				INT_10_6 PROC
					PUSHX	AX, BX, SI			; call-preserve these registers
			     1				IFNB <AX>			; exit if last reg 
 F235  50                    1		PUSH	AX 					; push register and repeat 
			     1		PUSHX	BX, SI, , , , ,  
			     2				IFNB <BX>			; exit if last reg 
 F236  53                    2		PUSH	BX 					; push register and repeat 
			     2		PUSHX	SI, , , , , ,  
			     3				IFNB <SI>			; exit if last reg 
 F237  56                    3		PUSH	SI 					; push register and repeat 
			     3		PUSHX	, , , , , ,  
			     3				ENDIF 
			     2				ENDIF 
			     1				ENDIF 
 F238  C4 36 00E8 R			LES	SI, VID_MEM_SEG_DW	; ES = video/regen RAM segment (B800 or B000)
 F23C  55				PUSH	BP
				
				;----------------------------------------------------------------------------;
				; Register Check:
				;	AH = saved flags - ZF if scroll up
				;	AL = number of rows to scroll
				;	BH = attribute to be used on blank line
				;	BL = scratch
				;	CH = row of upper left corner of scroll window
				;	CL = column of upper left corner of scroll window
				;	DH = row of lower right corner of scroll window
				;	DL = column of lower right corner of scroll window
				;
 F23D  80 FC 06				CMP	AH, 6				; is scroll up?
 F240  9F				LAHF					; save ZF if scroll up
 F241  8B E8				MOV	BP, AX			; save original AL / AH flags
 F243  8B FA				MOV	DI, DX			; save original DX
 F245  75 02				JNZ	INT_10_CHECK_BOUNDS	; jump if scroll down
				
				;----------------------------------------------------------------------------;
				; On scroll up, the new rectangle to scroll is above the old one so start the
				; bottom left of the new rectangle at the top left of the old one. This 
				; will be later adjusted by the number of rows to scroll.
				;
 F247  8B D1				MOV	DX, CX			; if scroll up, DX becomes "top"
				
				;----------------------------------------------------------------------------;
				; Make sure lower right column does not exceed screen width
				;
 F249				INT_10_CHECK_BOUNDS:
 F249  A0 004A R			MOV	AL, BYTE PTR VID_COLS	; AL = video mode columns
 F24C  3A D0				CMP	DL, AL			; is rect right column > screen columns?
 F24E  72 03				JB	INT_10_BOUNDS_OK
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-153


 F250  8A D0				MOV	DL, AL			; number of screen columns (80 or 40)
 F252  4A				DEC	DX				; fixup for 0-based column index (0-79, etc)
 F253				INT_10_BOUNDS_OK:
 F253  F6 E6				MUL	DH				; AX = memory offset of col 0 of new bottom row
 F255  8A F0				MOV	DH, AL			; save AL
				
				;----------------------------------------------------------------------------;
				; Is graphics mode?
				;
 F257  E8 F085 R			CALL	INT_10_IS_TXT		; NZ if CGA GFX, ZR if CGA/MDA Text
 F25A  8A C6				MOV	AL, DH			; restore AL
 F25C  B6 00				MOV	DH, 0				; DX = lower right column position
 F25E  1E				PUSH	DS				; save BDA data SEG
 F25F  75 5D				JNZ	INT_10_SCR_GFX
				
				;----------------------------------------------------------------------------;
				; Scroll in text mode
				;----------------------------------------------------------------------------;
				; To calculate scroll memory offsets:
				;
				;  rect_height = rect_height + 1
				;  next_row = screen_cols - rect_width
				;
				;  if scroll down:
				; 	rect_height = - rect_height
				;	next_row = - next_row
				;
				;  new_top = old_top - rect_height
				;  new_bottom = old_bottom - rect_height
				;
 F261				INT_10_SCR_TXT:
 F261  03 D0				ADD	DX, AX			; DX = byte offset of new bottom row and col
 F263  D1 E2				SHL	DX, 1				; WORD-align memory offset
 F265  03 16 004E R			ADD	DX, VID_SEG			; DX = memory offset bottom row/col in video page
 F269  8B F2				MOV	SI, DX			; SI = memory offset of new rect bottom (midpoint)
 F26B  87 FA				XCHG	DI, DX			; DI = new rect bottom, DX = row/col pos.
 F26D  2B D1				SUB	DX, CX			; DH = rect height (rows), DL = rect width (cols)
 F26F  8B 0E 004A R			MOV	CX, VID_COLS		; CL = current video mode cols (80 or 40), CH = 0
 F273  8C C0				MOV	AX, ES			; source and destination is video/regen RAM
 F275  8E D8				MOV	DS, AX
 F277  8B C5				MOV	AX, BP			; AL = # of rows to scroll
 F279  D0 E1				SHL	CL, 1				; WORD-align bytes per full row (now 160 or 80)
 F27B  F6 E1				MUL	CL				; AX = size in WORDs of full rows to scroll
 F27D  95				XCHG	AX, BP			; AL = # rows, AH = func, BP = WORD size of rect. rows
 F27E  42				INC	DX				; convert 0-based indexes to 1-based loop counters
 F27F  FE C6				INC	DH
 F281  9E				SAHF					; set ZF if scroll up
 F282  8A E7				MOV	AH, BH			; AH = fill attribute byte
 F284  9C				PUSHF					; save scroll direction flag (out of registers!)
 F285  8B D9				MOV	BX, CX			; BX = WORD size of one screen row (80 or 160)
 F287  8A CA				MOV	CL, DL			; CX = BYTE size of one rectangle row
 F289  2B D9				SUB	BX, CX			; BX = WORD offset btwn end of rect. col and start col
 F28B  2B D9				SUB	BX, CX			;  on next row (subtract twice to WORD align)
 F28D  9D				POPF					; set ZF if scroll up
 F28E  74 04				JZ	INT_10_CGA_CHECK		; jump if scroll up
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-154


				
				;----------------------------------------------------------------------------;
				; On scroll down, subtract (instead of add) the difference between the end 
				; of the current rectangle and the next row start.
				;
				; The start address of source rectangle will also be above (instead of below)
				; the destination rectangle.
				;
				; These offsets are then added the top/bottom of current rectangle to get the
				; new rectangle coords, either above or below depending on scroll direction.
				;
 F290  F7 DB				NEG	BX				; BX = - WORD size offset to start of next row
 F292  F7 DD				NEG	BP				; BP = - WORD size of region of rows to scroll
				
 F294				INT_10_CGA_CHECK:
				
 F294				INT_10_6_CHECK_CLS:
 F294  84 C0				TEST	AL, AL			; is number of lines to scroll 0?
 F296  74 14				JZ	INT_10_6_TXT_CLR		; if so, skip move and only clear
				
				;----------------------------------------------------------------------------;
				; Move scrolled window rectangle to new location in video memory 
				;
 F298  2A F0				SUB	DH, AL			; DH = rect height - lines to scroll
 F29A  74 0E				JZ	INT_10_6_TXT_CLR_1	; is number of lines to move 0?
 F29C  03 F5				ADD	SI, BP			; SI = source row starting address
 F29E				INT_10_6_TXT_MOVE_LOOP:
 F29E  8A CA				MOV	CL, DL			; CX = number of columns (chars) to move
 F2A0  F3/ A5				REP	MOVSW				; copy row from [DS:SI] to [ES:DI]
 F2A2  03 FB				ADD	DI, BX			; move to start of next row
 F2A4  03 F3				ADD	SI, BX
 F2A6  FE CE				DEC	DH
 F2A8  75 F4				JNZ	INT_10_6_TXT_MOVE_LOOP	; loop through all rows
 F2AA				INT_10_6_TXT_CLR_1:
 F2AA  8A F0				MOV	DH, AL			; DH = remaining lines to clear
				
				;----------------------------------------------------------------------------;
				; Clear (fill with spaces) the newly cleared area
				;
 F2AC				INT_10_6_TXT_CLR:
 F2AC  B0 20				MOV	AL, VID_SP			; fill blank lines with spaces
 F2AE				INT_10_6_TXT_CLR_LOOP:
 F2AE  8A CA				MOV	CL, DL			; write rect width number of blank chars
 F2B0  F3/ AB				REP	STOSW				; write attribute and space to col
 F2B2  03 FB				ADD	DI, BX			; move to start of next row
 F2B4  FE CE				DEC	DH
 F2B6  75 F6				JNZ	INT_10_6_TXT_CLR_LOOP	; loop through all rows
 F2B8  1F				POP	DS				; restore BDA SEG
				
				
 F2B9				INT_10_6_DONE:
					POPX	BP, SI, BX, AX
			     1				IFNB <BP>			; exit if last reg 
 F2B9  5D                    1		POP	BP 					; pop register and repeat 
			     1		POPX	SI, BX, AX, , , ,  
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-155


			     2				IFNB <SI>			; exit if last reg 
 F2BA  5E                    2		POP	SI 					; pop register and repeat 
			     2		POPX	BX, AX, , , , ,  
			     3				IFNB <BX>			; exit if last reg 
 F2BB  5B                    3		POP	BX 					; pop register and repeat 
			     3		POPX	AX, , , , , ,  
			     4				IFNB <AX>			; exit if last reg 
 F2BC  58                    4		POP	AX 					; pop register and repeat 
			     4		POPX	, , , , , ,  
			     4				ENDIF 
			     3				ENDIF 
			     2				ENDIF 
			     1				ENDIF 
 F2BD  C3				RET
				
				;----------------------------------------------------------------------------;
				; INT 10,6/7 - Scroll up or down in graphics mode
				;----------------------------------------------------------------------------;
				; Input:
				;	AX = memory offset of col 0 of new bottom row
				;	BH = attribute to be used on blank line
				;	BL = (scratch)
				;	BP (high) = flags (ZF if scroll up, NZ if scroll down)
				;	CH = row/Y of upper left corner of scroll window
				;	CL = column/X of upper left corner of scroll window
				;	DX = lower right column/X position
				;	DI = original row/column parameter
				;
				; Perform BitBlt operation within video RAM.
				;----------------------------------------------------------------------------;
 F2BE				INT_10_SCR_GFX PROC
 F2BE  D1 E0				SHL	AX, 1				; BYTE (char) align memory offset for line
 F2C0  D1 E0				SHL	AX, 1				;  (default for 640x200)
 F2C2  03 D0				ADD	DX, AX
 F2C4  87 D7				XCHG	DX, DI			; DI = memory offset of new rect bottom
 F2C6  42				INC	DX				; DX = original row/col
 F2C7  FE C6				INC	DH				; use 0-based indexes for 1-based counters
 F2C9  2B D1				SUB	DX, CX			; DH = rect height, DL = rect width
 F2CB  95				XCHG	AX, BP			; restore original AL / AH = func flag
 F2CC  8A D8				MOV	BL, AL			; BL = lines to scroll
 F2CE  BD 0050				MOV	BP, 80			; 1 scanline = 80 bytes
 F2D1  B9 0002				MOV	CX, 2				; CL = 2, CH = 0 (needed later for counters)
 F2D4  D2 E6				SHL	DH, CL			; rect height * char (row) height / 2 fields
 F2D6  D2 E3				SHL	BL, CL			; lines to scroll * char height / 2 fields
 F2D8  80 3E 0049 R 06			CMP	VID_MODE, 6			; is 640x200 mode?
 F2DD  74 08				JZ	INT_10_SCR_GFX_2		; jump if so
				
				;----------------------------------------------------------------------------;
				; is 320x200/4 color - adjust to 2 bits per pixel (16 bits per glyph)
				;
 F2DF  D1 E7				SHL	DI, 1				; WORD (char) align mem offset
 F2E1  D0 E2				SHL	DL, 1				; WORD (char) align rect width
 F2E3  9E				SAHF					; set ZF if scroll up
 F2E4  74 0A				JZ	INT_10_SCR_GFX_RDY	; jump if scroll up
				
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-156


				;----------------------------------------------------------------------------;
				; is 320x200 AND scroll down
				;
 F2E6  47				INC	DI				; fixup start address for last pixel
				
 F2E7				INT_10_SCR_GFX_2:
 F2E7  9E				SAHF					; set ZF if scroll up
 F2E8  74 06				JZ	INT_10_SCR_GFX_RDY	; jump if scroll up
				
				;----------------------------------------------------------------------------;
				; is scroll down
				;
 F2EA  81 C7 00F0			ADD	DI, 240			; fixup bottom row of new rect.
 F2EE  F7 DD				NEG	BP				; if scroll down, subtract offset instead
				
				;----------------------------------------------------------------------------;
				; ready to begin
				;
 F2F0				INT_10_SCR_GFX_RDY:
 F2F0  84 C0				TEST	AL, AL			; is number of lines to scroll 0?
 F2F2  74 33				JZ	INT_10_SCR_GFX_CLR	; if so, skip move and only clear
				
				;----------------------------------------------------------------------------;
				; Bit block transfer pixel data in video memory
				;
 F2F4  8B F7				MOV	SI, DI			; SI = mem offset of new rectangle
 F2F6  8B C5				MOV	AX, BP			; AL = 1 scanline (80 if up, -80 if down)
 F2F8  F6 EB				IMUL	BL				; AX = offset of lines to scroll * +/- 80
 F2FA  03 F0				ADD	SI, AX			; SI = mem offset of old rectangle
 F2FC  8C C0				MOV	AX, ES			; set DS to video regen segment
 F2FE  8E D8				MOV	DS, AX			;  for source (old) rectangle
 F300  53				PUSH	BX				; save lines to clear and attribute
 F301  2A F3				SUB	DH, BL			; DH = # of lines to write
					;JZ	INT_10_SCR_GFX_CLR_1	; check that loop > 1 (necessary?)
 F303  8B C6				MOV	AX, SI			; save source
 F305  8B DF				MOV	BX, DI			; save destination
 F307				INT_10_SCR_GFX_MOVE_LOOP:
 F307  8A CA				MOV	CL, DL			; # of pixels to copy
 F309  F3/ A4				REP	MOVSB				; copy odd field
 F30B  BE 2000				MOV	SI, CGA_MEM_FLD		; vid mem offset for interlaced field
 F30E  8B FE				MOV	DI, SI
 F310  03 F0				ADD	SI, AX			; add to line offset
 F312  03 FB				ADD	DI, BX
 F314  8A CA				MOV	CL, DL			; # of pixels to copy
 F316  F3/ A4				REP	MOVSB				; copy even field
 F318  03 C5				ADD	AX, BP			; move to next line
 F31A  03 DD				ADD	BX, BP
 F31C  8B F0				MOV	SI, AX			; reset source
 F31E  8B FB				MOV	DI, BX			; reset dest
 F320  FE CE				DEC	DH
 F322  75 E3				JNZ	INT_10_SCR_GFX_MOVE_LOOP
 F324  5B				POP	BX
				
				;----------------------------------------------------------------------------;
				; Clear old window rectangle
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-157


				;
 F325				INT_10_SCR_GFX_CLR_1:
 F325  8A F3				MOV	DH, BL			; # of lines to clear
 F327				INT_10_SCR_GFX_CLR:
 F327  8A C7				MOV	AL, BH			; AL = attribute/color byte to write
 F329  8B F7				MOV	SI, DI			; save destination
 F32B				INT_10_SCR_GFX_CLR_LOOP:
 F32B  8A CA				MOV	CL, DL			; # of pixels to clear
 F32D  F3/ AA				REP	STOSB				; clear odd field
 F32F  BF 2000				MOV	DI, CGA_MEM_FLD		; vid mem offset for interlaced field
 F332  03 FE				ADD	DI, SI
 F334  8A CA				MOV	CL, DL			; # of pixels to clear
 F336  F3/ AA				REP	STOSB				; clear even field
 F338  03 F5				ADD	SI, BP			; move to next line
 F33A  8B FE				MOV	DI, SI			; reset dest
 F33C  FE CE				DEC	DH
 F33E  75 EB				JNZ	INT_10_SCR_GFX_CLR_LOOP
 F340  1F				POP	DS
 F341  E9 F2B9 R			JMP	INT_10_6_DONE
				
 F344				INT_10_SCR_GFX ENDP
				
 F344				INT_10_6 ENDP
 F344				INT_10_7 ENDP
				
				;----------------------------------------------------------------------------;
				; INT 10,8 - Read character and attribute at cursor
				;----------------------------------------------------------------------------;
				; Input:
				;	BH = display page
				; Output:
				;	AH = attribute of character (alpha modes only)
				;	AL = character at cursor position
				;
				; http://www.techhelpmanual.com/92-cga_video_snow_and_cls_flash.html
				;----------------------------------------------------------------------------;
 F344				INT_10_8 PROC
 F344  E8 F5D1 R			CALL	INT_10_GET_CUR_ADDR	; ES:DI = video RAM offset of cursor
 F347  A0 0049 R			MOV	AL, VID_MODE		; AL = current video mode (0-7)
 F34A  3C 07				CMP	AL, 7				; is MDA mode 7?
 F34C  75 04				JNZ	INT_10_8_CHK_CGA		; if not, jump to check CGA or gfx
				
				;----------------------------------------------------------------------------;
				; Standard, fast routine
				;
 F34E				INT_10_8_FAST:
 F34E  26: 8B 05			MOV	AX, ES:[DI]			; just read from memory and return
 F351  C3				RET
				
 F352				INT_10_8_CHK_CGA:
 F352  D0 E8				SHR	AL, 1				; Video modes: 0=40,1=80,2=low-gfx,3=hi-gfx
 F354  3C 01				CMP	AL, 1				; is CGA modes 2,3?
				
 F356  76 F6				JBE	INT_10_8_FAST		; if not GFX modes 4,5,6 jump to fast text
										; fall through to graphics
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-158


				
				;----------------------------------------------------------------------------;
				; INT 10,8 - Read character and attribute at cursor in CGA graphic mode
				;----------------------------------------------------------------------------;
				; Input:
				;	AL = 3 if high res, 2 if low-res
				;	ES = video mem segment
				; Output:
				;	AH = 0
				;	AL = character at cursor position, 0 if not found
				;----------------------------------------------------------------------------;
 F358				INT_10_8_MODE_GFX PROC
					PUSHX	BX, CX, DX, SI
			     1				IFNB <BX>			; exit if last reg 
 F358  53                    1		PUSH	BX 					; push register and repeat 
			     1		PUSHX	CX, DX, SI, , , ,  
			     2				IFNB <CX>			; exit if last reg 
 F359  51                    2		PUSH	CX 					; push register and repeat 
			     2		PUSHX	DX, SI, , , , ,  
			     3				IFNB <DX>			; exit if last reg 
 F35A  52                    3		PUSH	DX 					; push register and repeat 
			     3		PUSHX	SI, , , , , ,  
			     4				IFNB <SI>			; exit if last reg 
 F35B  56                    4		PUSH	SI 					; push register and repeat 
			     4		PUSHX	, , , , , ,  
			     4				ENDIF 
			     3				ENDIF 
			     2				ENDIF 
			     1				ENDIF 
 F35C  83 EC 08				SUB	SP, 8				; reserve 8 bytes for target bitmap
				
				;----------------------------------------------------------------------------;
				; Lookup page, calculate charpos and set up data segments
				;
 F35F  E8 F4AE R			CALL	INT_10_GFX_CHARPOS	; DI = memory offset of curr. cursor
 F362  8B F7				MOV	SI, DI			; SI = memory offset of curr. cursor
 F364  8B FC				MOV	DI, SP			; DI = start of temp space
 F366  06				PUSH	ES				; DS = ES
 F367  1F				POP	DS
 F368  16				PUSH	SS				; ES = SS
 F369  07				POP	ES
 F36A  B9 0004				MOV	CX, 4				; loop counter for high and low res
 F36D  BA 2000				MOV	DX, CGA_MEM_FLD		; CGA memory interlace field offset
 F370  3C 03				CMP	AL, 3				; is high-res graphics mode?
 F372  74 5D				JZ	INT_10_8_GFX_HIGH		; jump to handle high-res 1 bpp spacing
				
				;----------------------------------------------------------------------------;
				; Low-res - Load and pack 8 character bytes from video mem into [DS:BP]
				;----------------------------------------------------------------------------;
 F374				INT_10_8_MODE_GFX_LOW:
 F374  D1 E6				SHL	SI, 1				; align for two bytes/char in 320x200
				
 F376				INT_10_8_GFX_LOW_1:
 F376  8B 04				MOV	AX, [SI]			; AX = next two chars from video mem
 F378  86 C4				XCHG	AL, AH			; convert endian from WORD read
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-159


				
				;----------------------------------------------------------------------------;
				; Shift and OR the color bits together so that non-zero value will produce 1
				;
 F37A  8B D8				MOV	BX, AX			; copy bit pattern
 F37C  D1 E0				SHL	AX, 1				; shift low bit into high bit
 F37E  0B D8				OR	BX, AX			; make high bit a 1 if either bit is 1
				
				;----------------------------------------------------------------------------;
				; Copy the only odd bits from the WORD value into a BYTE value.
				;
 F380  B4 08				MOV	AH, 8				; loop through the eight 2 bpp values
 F382				INT_10_8_GFX_LOW_2:
 F382  D1 E3				SHL	BX, 1				; even bit into CF
 F384  12 C0				ADC	AL, AL			; shift CF onto low order bit
 F386  D1 E3				SHL	BX, 1				; discard pixel odd bit
 F388  FE CC				DEC	AH				; dec loop counter
 F38A  75 F6				JNZ	INT_10_8_GFX_LOW_2
 F38C  AA				STOSB					; save byte to local storage
 F38D  33 F2				XOR	SI, DX			; toggle video field memory offset
 F38F  85 F2				TEST	SI, DX			; is next field even?
 F391  75 E3				JNZ	INT_10_8_GFX_LOW_1	; jump if next field is even
 F393  83 C6 50				ADD	SI, 80			; if next field is odd, move to next line
 F396  E2 DE				LOOP	INT_10_8_GFX_LOW_1	; loop all 8 bitmap bytes and fall through
				
				;----------------------------------------------------------------------------;
				; Do a linear search (uh, time complexity anyone?) of ROM BIOS and INT 1Fh 
				; for the 8x8 1 bpp bitmap at the cursor position.
				;
 F398				INT_10_8_GFX_SEARCH:
 F398  8B FC				MOV	DI, SP			; DI = char bitmap from video mem
 F39A  BE FA6E R			MOV	SI, OFFSET GFX_CHARSET	; SI = BIOS ROM table
 F39D  8C CB				MOV	BX, CS			; DS = CS
 F39F  8E DB				MOV	DS, BX
 F3A1  33 C0				XOR	AX, AX			; start codepoint counter at 0
 F3A3				INT_10_8_GFX_SEARCH_TBL:
 F3A3  BB 0080				MOV	BX, 128			; loop counter for each charset table
 F3A6				INT_10_8_GFX_SEARCH_CHR:
 F3A6  56				PUSH	SI				; save target bitmap and ROM table offsets
 F3A7  57				PUSH	DI
 F3A8  B1 04				MOV	CL, 4				; compare [CS:SI] (ROM table) to
 F3AA  F3/ A7				REPE	CMPSW				;  [ES:DI] (char bitmap from vid mem)
 F3AC  5F				POP	DI				; restart target bitmap at beginning 
 F3AD  5E				POP	SI				; ROM table always advanced by 8 
 F3AE  74 19				JE	INT_10_8_GFX_DONE		; end search if match found
 F3B0  83 C6 08				ADD	SI, 8				; next char in table
 F3B3  FE C0				INC	AL				; next codepoint to try
 F3B5  74 12				JZ	INT_10_8_GFX_DONE		; if AL > 255, char not found
 F3B7  4B				DEC	BX				; dec charset loop counter
 F3B8  75 EC				JNZ	INT_10_8_GFX_SEARCH_CHR	; loop until end of table set
				
				;----------------------------------------------------------------------------;
				; Search again in user charset at 0000:007C (INT 1Fh).
				;
 F3BA  99				CWD					; DX = 0000h
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-160


 F3BB  8E DA				MOV	DS, DX			; DS = IVT
							ASSUME DS:_IVT
 F3BD  C5 36 007C R			LDS	SI, IVT_1F			; DS:SI = user charset
							ASSUME DS:_BDA
 F3C1  8C DA				MOV	DX, DS			; see if custom table has been vectored
 F3C3  0B D6				OR	DX, SI			;  and not the default of 0000:0000
 F3C5  75 DC				JNZ	INT_10_8_GFX_SEARCH_TBL	; if so, continue search
 F3C7  33 C0				XOR	AX, AX			; otherwise return not found (0)
 F3C9				INT_10_8_GFX_DONE:
 F3C9  83 C4 08				ADD	SP, 8				; restore stack pointer
					POPX	SI, DX, CX, BX
			     1				IFNB <SI>			; exit if last reg 
 F3CC  5E                    1		POP	SI 					; pop register and repeat 
			     1		POPX	DX, CX, BX, , , ,  
			     2				IFNB <DX>			; exit if last reg 
 F3CD  5A                    2		POP	DX 					; pop register and repeat 
			     2		POPX	CX, BX, , , , ,  
			     3				IFNB <CX>			; exit if last reg 
 F3CE  59                    3		POP	CX 					; pop register and repeat 
			     3		POPX	BX, , , , , ,  
			     4				IFNB <BX>			; exit if last reg 
 F3CF  5B                    4		POP	BX 					; pop register and repeat 
			     4		POPX	, , , , , ,  
			     4				ENDIF 
			     3				ENDIF 
			     2				ENDIF 
			     1				ENDIF 
 F3D0  C3				RET
				
				;----------------------------------------------------------------------------;
				; High-res - Load 8 character bytes from video mem into [DS:BP]
				;----------------------------------------------------------------------------;
 F3D1				INT_10_8_GFX_HIGH:
 F3D1  A4				MOVSB					; copy odd field
 F3D2  4E				DEC	SI				; undo MOVSB source inc
 F3D3  33 F2				XOR	SI, DX			; toggle video field memory offset
 F3D5  A4				MOVSB					; copy even field
 F3D6  33 F2				XOR	SI, DX			; toggle video field memory offset back
 F3D8  83 C6 4F				ADD	SI, 80-1			; move to next line (undo MOVSB inc of SI)
 F3DB  E2 F4				LOOP	INT_10_8_GFX_HIGH		; loop 8 times
 F3DD  EB B9				JMP	INT_10_8_GFX_SEARCH	; rejoin the search
				
 F3DF				INT_10_8_MODE_GFX ENDP
				
 F3DF				INT_10_8 ENDP
				
				;----------------------------------------------------------------------------;
				; INT 10,9 - Write character and attribute at cursor
				;----------------------------------------------------------------------------;
				; INT 10,A - Write character at current cursor
				;----------------------------------------------------------------------------;
				; Input:
				;	AH = 09 or 0A
				;	AL = ASCII character to write
				;	BH = display page  (or mode 13h, background pixel value)
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-161


				;	BL = foreground color (graphics mode only)
				;	CX = count of characters to write (CX >= 1)
				;
				; This code is performance sensitive, so jumps are prioritizied
				; and some code is duplicated to avoid jumps. For example, AH=0AH is used 
				; far more frequently than 09H so it gets the fall through cases.
				;----------------------------------------------------------------------------;
 F3DF				INT_10_9 PROC
 F3DF				INT_10_A PROC
 F3DF  51				PUSH	CX
 F3E0  50				PUSH	AX				; save AX
 F3E1  E8 F5D1 R			CALL	INT_10_GET_CUR_ADDR	; ES:DI = video RAM offset of cursor
 F3E4  A0 0049 R			MOV	AL, VID_MODE		; AL = current video mode (0-7)
 F3E7  3C 07				CMP	AL, 7				; is MDA mode 7?
 F3E9  75 12				JNZ	INT_10_CHK_CGA		; if not, jump to check CGA
				
				;----------------------------------------------------------------------------;
				; Use standard, fast routine for direct video memory writes
				;
 F3EB				INT_10_9A_FAST:
 F3EB  58				POP	AX				; restore AX
 F3EC  80 FC 09				CMP	AH, 9				; is function 9 (char + attribute)?
 F3EF  74 06				JZ	INT_10_9_FAST		; if so, jump
				
				;----------------------------------------------------------------------------;
				; AH = 0AH: Write Character
				;
 F3F1				INT_10_A_FAST:
 F3F1  AA				STOSB					; write char, skip attribute
 F3F2  47				INC	DI
 F3F3  E2 FC				LOOP	INT_10_A_FAST
 F3F5  59				POP	CX
 F3F6  C3				RET
				
				;----------------------------------------------------------------------------;
				; AH = 09H: Write Character and Attribute
				;
 F3F7				INT_10_9_FAST:
 F3F7  8A E3				MOV	AH, BL			; char attribute into high byte
 F3F9  F3/ AB				REP	STOSW				; write with attribute
 F3FB  59				POP	CX
 F3FC  C3				RET
				
 F3FD				INT_10_CHK_CGA:
 F3FD  D0 E8				SHR	AL, 1				; group remaining video modes
 F3FF  3C 01				CMP	AL, 1				; is CGA modes 2,3?
				
 F401  76 E8				JBE	INT_10_9A_FAST		; is not GFX modes 4,5,6 jump to fast text
 F403  58				POP	AX				; restore AX and fall through to graphics
				
				;----------------------------------------------------------------------------;
				; INT 10, 9 and A - Write character in CGA graphics mode
				;----------------------------------------------------------------------------;
 F404				INT_10_9A_MODE_GFX PROC
					PUSHX	AX, BX, DX, SI, DS
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-162


			     1				IFNB <AX>			; exit if last reg 
 F404  50                    1		PUSH	AX 					; push register and repeat 
			     1		PUSHX	BX, DX, SI, DS, , ,  
			     2				IFNB <BX>			; exit if last reg 
 F405  53                    2		PUSH	BX 					; push register and repeat 
			     2		PUSHX	DX, SI, DS, , , ,  
			     3				IFNB <DX>			; exit if last reg 
 F406  52                    3		PUSH	DX 					; push register and repeat 
			     3		PUSHX	SI, DS, , , , ,  
			     4				IFNB <SI>			; exit if last reg 
 F407  56                    4		PUSH	SI 					; push register and repeat 
			     4		PUSHX	DS, , , , , ,  
			     5				IFNB <DS>			; exit if last reg 
 F408  1E                    5		PUSH	DS 					; push register and repeat 
			     5		PUSHX	, , , , , ,  
			     5				ENDIF 
			     4				ENDIF 
			     3				ENDIF 
			     2				ENDIF 
			     1				ENDIF 
 F409  8A 3E 0049 R			MOV	BH, VID_MODE		; BH = current video mode
 F40D  E8 F4AE R			CALL	INT_10_GFX_CHARPOS	; DI = memory offset of curr. cursor
				
				;----------------------------------------------------------------------------;
				; If extended ASCII, use custom table revectored at 1Fh
				;
 F410  BE FA6E R			MOV	SI, OFFSET GFX_CHARSET	; default to lower set using BIOS table
 F413  8C CA				MOV	DX, CS			;  located in CS
 F415  8E DA				MOV	DS, DX			; DS = CS
 F417  84 C0				TEST	AL, AL			; is extended (AL > 127)?
 F419  79 0A				JNS	INT_10_9A_GFX_2		; Jump if not
 F41B  24 7F				AND	AL, 01111111b		; AL = low 7 bits of CP
 F41D  33 D2				XOR	DX, DX			; Set DS to IVT to load DS and SI from
 F41F  8E DA				MOV	DS, DX			; INT 1Fh
							ASSUME DS:_IVT
 F421  C5 36 007C R			LDS	SI, IVT_1F			; use custom font table
				
 F425				INT_10_9A_GFX_2:
 F425  98				CBW					; AH = 0
 F426  D1 E0				SHL	AX, 1				; AX = char * 8
 F428  D1 E0				SHL	AX, 1
 F42A  D1 E0				SHL	AX, 1
 F42C  03 F0				ADD	SI, AX			; SI = offset in char table
 F42E  80 FF 06				CMP	BH, 6
 F431  74 56				JE	INT_10_9A_GFX_HIGH	; jump if high res
				
				;----------------------------------------------------------------------------;
				; Low-res (320x200) graphics modes 4-5
				;----------------------------------------------------------------------------;
				; Input:
				;	AX = ASCII character to write * 8 bytes
				;	BH = video mode
				;	BL = foreground color
				;	CX = number of times to repeat character
				;	DS:SI = start of character offset in font bitmap table
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-163


				;	ES:DI = cursor location in video RAM
				;----------------------------------------------------------------------------;
				; Things you must do:
				;	1. Transform each BYTE of 1 bit glyph into 2 bpp color WORD
				;	2. If BL has high bit set, XOR new char with current char
				;	3. Write new bitmap to CGA interlaced video memory
				;----------------------------------------------------------------------------;
 F433				INT_10_9A_GFX_LOW:
 F433  8A D3				MOV	DL, BL			; DL = foreground color bits
 F435  83 E2 03				AND	DX, 0011b			; zero extend 2 bit color
				
				;----------------------------------------------------------------------------;
				; Repeat/expand 2 color bits in DL into into DX
				;
 F438				INT_10_9A_GFX_FG:
 F438  0A F2				OR	DH, DL			; copy 2 bits
 F43A  D0 E2				SHL	DL, 1				; move color bits to next position
 F43C  D0 E2				SHL	DL, 1
 F43E  75 F8				JNZ	INT_10_9A_GFX_FG		; loop until DL = 0
 F440  8A D6				MOV	DL, DH			; copy to both bytes of DX
				
				;----------------------------------------------------------------------------;
				; Repeat for number of chars to write in CX to create color mask
				;
 F442  D1 E7				SHL	DI, 1				; align for two bytes/char in 320x200
 F444				INT_10_9A_GFX_LOW_CHAR:
 F444  56				PUSH	SI				; save char glyph start offset for each loop
 F445  57				PUSH	DI				; start each char at first row of vid mem
				
				;----------------------------------------------------------------------------;
				; Transform glyph bitmap to 2 bit color and move into video memory
				;
 F446  51				PUSH	CX				; save repeat counter
 F447  B9 0008				MOV	CX, 8				; loop 8 bytes
 F44A				INT_10_9A_GFX_LOW_BYTE:
 F44A  AC				LODSB					; Load next byte
				
				;----------------------------------------------------------------------------;
				; Parallel-deposit bits of input char and transform 1 bit pixel into 2 bpp
				;
 F44B  53				PUSH	BX
 F44C  51				PUSH	CX				; save bitmap counter
 F44D  33 DB				XOR	BX, BX			; clear output
 F44F  B1 08				MOV	CL, 8				; loop 8 bits of input char
 F451				INT_10_9A_GFX_LOW_PDEP:
 F451  D0 E0				SHL	AL, 1				; CF = source pixel bit
 F453  9F				LAHF					; save CF
 F454  D1 D3				RCL	BX, 1				; shift CF into next bit
 F456  9E				SAHF					; restore CF
 F457  D1 D3				RCL	BX, 1				; shift CF into next bit again
 F459  E2 F6				LOOP	INT_10_9A_GFX_LOW_PDEP
 F45B  93				XCHG	AX, BX			; AX = result
 F45C  86 C4				XCHG	AL, AH			; convert endian
 F45E  59				POP	CX
 F45F  5B				POP	BX
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-164


 F460  23 C2				AND	AX, DX			; combine with color mask
				
				;----------------------------------------------------------------------------;
				; In gfx mode, if BL bit 7=1 then value of BL is XOR'ed with the bg color
				;
 F462  84 DB				TEST	BL, BL			; high bit set?
 F464  79 03				JNS	INT_10_9A_GFX_LOW_WR	; jump if not
 F466  26: 33 05			XOR	AX, ES:[DI]			; XOR byte for current field
 F469				INT_10_9A_GFX_LOW_WR:
 F469  26: 89 05			MOV	ES:[DI], AX			; write 2 bytes to video memory
 F46C  81 F7 2000			XOR	DI, CGA_MEM_FLD		; alternate video fields
 F470  F7 C7 2000			TEST	DI, CGA_MEM_FLD		; is an even field next?
 F474  75 03				JNZ	INT_10_9A_GFX_LOW_NEXT	; jump if even (use same offset for even)
 F476  83 C7 50				ADD	DI, 80			; if next is odd, move to next bitmap row
 F479				INT_10_9A_GFX_LOW_NEXT:
 F479  E2 CF				LOOP	INT_10_9A_GFX_LOW_BYTE	; loop 8 glyph bytes/lines
				
 F47B  59				POP	CX				; restore repeat counter
 F47C  5F				POP	DI
 F47D  5E				POP	SI
 F47E  47				INC	DI				; move to next video mem WORD offset
 F47F  47				INC	DI
 F480  E2 C2				LOOP	INT_10_9A_GFX_LOW_CHAR	; repeat for CX number of chars
				
 F482				INT_10_9A_MODE_GFX_DONE:
					POPX	DS, SI, DX, BX, AX
			     1				IFNB <DS>			; exit if last reg 
 F482  1F                    1		POP	DS 					; pop register and repeat 
			     1		POPX	SI, DX, BX, AX, , ,  
			     2				IFNB <SI>			; exit if last reg 
 F483  5E                    2		POP	SI 					; pop register and repeat 
			     2		POPX	DX, BX, AX, , , ,  
			     3				IFNB <DX>			; exit if last reg 
 F484  5A                    3		POP	DX 					; pop register and repeat 
			     3		POPX	BX, AX, , , , ,  
			     4				IFNB <BX>			; exit if last reg 
 F485  5B                    4		POP	BX 					; pop register and repeat 
			     4		POPX	AX, , , , , ,  
			     5				IFNB <AX>			; exit if last reg 
 F486  58                    5		POP	AX 					; pop register and repeat 
			     5		POPX	, , , , , ,  
			     5				ENDIF 
			     4				ENDIF 
			     3				ENDIF 
			     2				ENDIF 
			     1				ENDIF 
				
 F487				INT_10_9A_MODE_GFX_EXIT:
 F487  59				POP	CX				; restore CX and rebalance stack
 F488  C3				RET
				
				;----------------------------------------------------------------------------;
				; High-res (640x200) graphics mode 6
				;----------------------------------------------------------------------------;
				; Input:
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-165


				;	AX = ASCII character to write * 8 bytes
				;	BH = current video mode
				;	BL = foreground color
				;	CX = number of times to repeat character
				;	DS:SI = start of character offset in font bitmap table
				;	ES:DI = cursor location in video RAM
				;----------------------------------------------------------------------------;
				; Things you must do:
				;	1. If BL has high bit set, XOR new char with current char
				;	2. Write new bitmap to CGA interlaced video memory
				;----------------------------------------------------------------------------;
				
				;----------------------------------------------------------------------------;
				; Repeat for number of chars to write in CX
				;
 F489				INT_10_9A_GFX_HIGH:
 F489  56				PUSH	SI				; save char glyph start offset for each loop
 F48A  57				PUSH	DI				; start each char at first row of vid mem
				
				;----------------------------------------------------------------------------;
				; Copy glyph bitmap to interlaced video memory
				;
 F48B  B7 04				MOV	BH, 4				; loop 4 words (8 bytes)
 F48D				INT_10_9A_GFX_HIGH_WORD:
 F48D  AD				LODSW					; load next two glyph rows
				
				;----------------------------------------------------------------------------;
				; In gfx mode, if BL bit 7=1 then value of BL is XOR'ed with the bg color
				;
 F48E  84 DB				TEST	BL, BL			; high bit set?
 F490  79 08				JNS	INT_10_9A_GFX_HIGH_WR	; jump if not
 F492  26: 32 05			XOR	AL, ES:[DI]			; XOR byte on odd field
 F495  26: 32 A5 2000			XOR	AH, ES:CGA_MEM_FLD[DI]	; and even field
				
				;----------------------------------------------------------------------------;
				; Write next two bytes to each field
				;
 F49A				INT_10_9A_GFX_HIGH_WR:
 F49A  AA				STOSB					; write odd field in AL
 F49B  26: 88 A5 1FFF			MOV	ES:CGA_MEM_FLD[DI][-1], AH	; write even field in AH
 F4A0  83 C7 4F				ADD	DI, 80-1			; move to next bitmap row
 F4A3  FE CF				DEC	BH
 F4A5  75 E6				JNZ	INT_10_9A_GFX_HIGH_WORD	; loop 4 words
 F4A7  5F				POP	DI				; restore video mem cursor offset
 F4A8  5E				POP	SI				; restore start of glyph
 F4A9  47				INC	DI				; move to next video mem BYTE offset 
 F4AA  E2 DD				LOOP	INT_10_9A_GFX_HIGH	; repeat for CX number of chars
 F4AC  EB D4				JMP	INT_10_9A_MODE_GFX_DONE	; exit
				
				;----------------------------------------------------------------------------;
				; Calculate graphics memory address for current current position
				;----------------------------------------------------------------------------;
				; Input: DS = BDA
				; Output:
				;	DI = Current cursor vid mem offset
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-166


				;
				; Clobbers DX
				;----------------------------------------------------------------------------;
 F4AE				INT_10_GFX_CHARPOS PROC
							ASSUME DS:_BDA
 F4AE  8B F8				MOV	DI, AX			; save original AX
 F4B0  A0 004A R			MOV	AL, BYTE PTR VID_COLS	; AL = screen mode cols (40 or 80)
 F4B3  8B 16 0050 R			MOV	DX, VID_CURS_POS		; DH = cursor row pos, DL = column
 F4B7  F6 E6				MUL	DH				; AX = screen cols * current row
 F4B9  D1 E0				SHL	AX, 1				; AX = AX * 4
 F4BB  D1 E0				SHL	AX, 1				; (8 rows / 2 fields)
 F4BD  92				XCHG	AX, DX			; AL = current column, DX = row offset
 F4BE  98				CBW					; AX = current column
 F4BF  03 C2				ADD	AX, DX			; AX = current row/column vid mem offset
 F4C1  97				XCHG	AX, DI			; AX = original, DI = row/col vid mem offset
 F4C2  C3				RET
 F4C3				INT_10_GFX_CHARPOS ENDP
				
 F4C3				INT_10_9A_MODE_GFX ENDP
				
 F4C3				INT_10_A ENDP
 F4C3				INT_10_9 ENDP
				
				;----------------------------------------------------------------------------;
				; INT 10,B - Set color palette
				;----------------------------------------------------------------------------;
				; Input:
				;	AH = 0B
				;	BH = palette color ID
				;	   = 0 to set background and border color
				;	   = 1 to select 4 color palette
				;	BL = color value (when BH = 0)
				;	   = palette value (when BH = 1)
				;----------------------------------------------------------------------------;
				;	|7|6|5|4|3|2|1|0|  3D9 Color Select Register (Graphics)
				;	 | | | | | `-------- RGB for background
				;	 | | | | `--------- intensity
				;	 | | | `---------- unused
				;	 | | `----------- 1 = palette 1, 0=palette 0 (see below)
				;	 `-------------- unused
				;	  Palette 0 = green, red, brown
				;	  Palette 1 = cyan, magenta, white
				;
				; VID_CSGFX	RECORD	CGPH:2=11B,CGPL:1,CGX:1,CGIN:1,CGBG:3
				;----------------------------------------------------------------------------;
 F4C3				INT_10_B PROC
 F4C3  50				PUSH	AX
 F4C4  A0 0066 R			MOV	AL, VID_COLOR			; get current color byte
 F4C7  84 FF				TEST	BH, BH				; set BG/border or palette?
 F4C9  75 07				JNZ	INT_10_B_SET_PAL			; jump if set palette
 F4CB				INT_10_B_SET_COL:
 F4CB  24 E0				AND	AL, MASK CGPH OR MASK CGPL	; isolate current palette
 F4CD  80 E3 1F				AND	BL, 00011111B			; isolate color bits
 F4D0  EB 0B				JMP	SHORT INT_10_B_DONE
 F4D2				INT_10_B_SET_PAL:
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-167


 F4D2  24 DF				AND	AL, NOT MASK CGPL			; clear palette bit
 F4D4  80 E3 01				AND	BL, 00000001B			; isolate palette selector bit
							ELSE
						REPT	3
					ROR	BL, 1					; move low bit into bit 5
						ENDM
 F4D7  D0 CB                 1		ROR	BL, 1					; move low bit into bit 5 
 F4D9  D0 CB                 1		ROR	BL, 1					; move low bit into bit 5 
 F4DB  D0 CB                 1		ROR	BL, 1					; move low bit into bit 5 
							ENDIF
 F4DD				INT_10_B_DONE:
 F4DD  0A C3				OR	AL, BL				; combine bytes
 F4DF  A2 0066 R			MOV	VID_COLOR, AL			; save to BDA
 F4E2  52				PUSH	DX
 F4E3  8B 16 0063 R			MOV	DX, VID_PORT
 F4E7  83 C2 05				ADD	DX, CGA_COLOR-CGA_IDX		; DX = 6845 color select reg (3D9H)
 F4EA  EE				OUT	DX, AL				; send to CGA Color Select Register
 F4EB  5A				POP	DX
 F4EC  58				POP	AX
 F4ED  C3				RET
 F4EE				INT_10_B ENDP
				
				;----------------------------------------------------------------------------;
				; INT 10,C - Write graphics pixel at coordinate
				;----------------------------------------------------------------------------;
				; Input:
				;	AL = color value (XOR'ed with current pixel if bit 7=1)
				;	BH = page number, see VIDEO PAGES
				;	CX = column number (zero based)
				;	DX = row number (zero based)
				;----------------------------------------------------------------------------;
 F4EE				INT_10_C PROC
 F4EE  50				PUSH	AX
 F4EF  51				PUSH	CX
 F4F0  E8 F51C R			CALL	INT_10_GFX_PIXEL		; ES:DI = memory offset, AH/CL mask/counter
 F4F3  8A E8				MOV	CH, AL			; save original AL
 F4F5  22 C4				AND	AL, AH			; mask only selected pixel
 F4F7  D2 E0				SHL	AL, CL			; shift into correct bit position
 F4F9  84 ED				TEST	CH, CH			; is high bit of color value set?
 F4FB  78 0D				JS	INT_10_C_XOR		; if so, XOR byte in memory
 F4FD  D2 E4				SHL	AH, CL			; shift mask for pixel position
 F4FF  F6 D4				NOT	AH				; invert mask to clear current pixel
 F501  26: 22 25			AND	AH, ES:[DI]			; clear pixel bits
 F504  0A C4				OR	AL, AH			; replace with new pixel value
 F506  AA				STOSB					; write to video buffer
 F507				INT_10_C_DONE:
 F507  59				POP	CX
 F508  58				POP	AX
 F509  C3				RET
 F50A				INT_10_C_XOR:
 F50A  26: 30 05			XOR	ES:[DI], AL			; just XOR and 'XIT
 F50D  EB F8				JMP	SHORT INT_10_C_DONE
 F50F				INT_10_C ENDP
				
				;----------------------------------------------------------------------------;
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-168


				; INT 10,D - Read graphics pixel at coordinate
				;----------------------------------------------------------------------------;
				; Input:
				;	BH = page number
				;	CX = X / column (zero based)
				;	DX = Y / row (zero based)
				; Output:
				;	AL = color of pixel read
				;	AH clobbered
				;----------------------------------------------------------------------------;
 F50F				INT_10_D PROC
 F50F  51				PUSH	CX
 F510  E8 F51C R			CALL	INT_10_GFX_PIXEL		; ES:DI = memory offset, AH/CL mask/counter
 F513  26: 8A 05			MOV	AL, ES:[DI]			; read packed pixel byte
 F516  D2 E8				SHR	AL, CL			; shift into low order bit(s)
 F518  22 C4				AND	AL, AH			; mask only selected pixel
 F51A  59				POP	CX
 F51B  C3				RET
 F51C				INT_10_D ENDP
				
				;----------------------------------------------------------------------------;
				; Get Video Memory Pixel Offset and Pixel Byte Mask
				;----------------------------------------------------------------------------;
				; Input:
				;	CX = X / column (zero based)
				;	DX = Y / row (zero based)
				;
				; Output
				;	DI = pixel byte offset
				;	AH = pixel data mask
				;	CL = pixel right shift counter
				;	CH = pixel index (big endian)
				;	ES = VID_MEM_SEG
				;
				; Example of read:
				;	MOV	AL, PIXEL_DAT
				;	SHR	AL, CL
				;	AND	AL, AH
				;
				; http://www.techhelpmanual.com/89-video_memory_layouts.html
				;----------------------------------------------------------------------------;
 F51C				INT_10_GFX_PIXEL PROC
 F51C  C4 3E 00E8 R			LES	DI, VID_MEM_SEG_DW	; ES = video/regen RAM segment
 F520  53				PUSH	BX
 F521  52				PUSH	DX
				
				;----------------------------------------------------------------------------;
				; Calculate X offset
				;
 F522  8B F9				MOV	DI, CX			; DI = X position (zero based)
 F524  D1 EF				SHR	DI, 1
 F526  D1 EF				SHR	DI, 1				; DI = DI / 4 (two bit alignment)
				
				;----------------------------------------------------------------------------;
				; Unpack pixel bit(s)
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-169


				;
 F528  B4 03				MOV	AH, 0011B			; pixel mask = 0011B
 F52A  8A DC				MOV	BL, AH			; index mask = 0011B (bits 0-3)
 F52C  8A E9				MOV	CH, CL			; save CH = CL
 F52E  B1 01				MOV	CL, 1				; ROL multiplier = 1
 F530  80 3E 0049 R 06			CMP	VID_MODE, 6			; is 640x200 gfx mode?
 F535  72 07				JB	NOT_HI_RES			; if low-res, skip
				
				;----------------------------------------------------------------------------;
				; Is "high res" (640x200)
				;
 F537  D0 EC				SHR	AH, 1				; pixel mask = 0001B
 F539  D0 D3				RCL	BL, 1				; index mask = 0111B (bits 0-7)
 F53B  49				DEC	CX				; ROL multiplier = 0
 F53C  D1 EF				SHR	DI, 1				; DI = DI / 8 (one bit alignment)
 F53E				NOT_HI_RES:
				
				;----------------------------------------------------------------------------;
				; Calculate right-shift counter:
				; - 640x200: CL = (7 - i) * 1
				; - 320x200: CL = (3 - i) * 2
				;
 F53E  22 EB				AND	CH, BL			; CH = packed pixel index
 F540  2A DD				SUB	BL, CH			; calculate right-shift counter
 F542  D2 E3				SHL	BL, CL			; multiply by 1 (high res) or 2 (low res)
 F544  8A CB				MOV	CL, BL			; CL = shift count
				
				;----------------------------------------------------------------------------;
				; Calculate Y offset
				;
				; Y offset = (DX / 2) * 80 + 2000H[DX is odd]
				;
 F546  D1 EA				SHR	DX, 1				; DX = DX / 2
 F548  86 D6				XCHG	DL, DH			; DX = DX << 8
 F54A  73 04				JNC	FIELD_EVEN			; is odd or even field?
 F54C  81 C7 2000			ADD	DI, CGA_MEM_FLD		; odd field address offset
 F550				FIELD_EVEN:
 F550  D1 EA				SHR	DX, 1
 F552  D1 EA				SHR	DX, 1
 F554  03 FA				ADD	DI, DX			; DI += (DX / 2) * 16
 F556  D1 EA				SHR	DX, 1
 F558  D1 EA				SHR	DX, 1
 F55A  03 FA				ADD	DI, DX			; DI += (DX / 2) * 64
 F55C  5A				POP	DX
 F55D  5B				POP	BX
 F55E  C3				RET
 F55F				INT_10_GFX_PIXEL ENDP
				
				;----------------------------------------------------------------------------;
				; INT 10,E - Write text in teletype mode
				;----------------------------------------------------------------------------;
				; Input:
				;	AH = 0E
				;	AL = ASCII character to write
				;	BH = page number (text modes) - override it with BDA value though
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-170


				;	BL = foreground pixel color (graphics modes)
				;
				; Output:
				;	Character to console
				;	All registers preserved
				;----------------------------------------------------------------------------;
				; Things you must do:
				;	1. Get video page from BDA - ignore what was passed in BH (why?)
				;	2. Get cursor location (INT 10,3) and keep it handy.
				;	3. Check for the four special control codes: BELL(7), BS(8), LF(A), CR(D)
				;		- BELL: beep and exit
				;		- Backspace: if cursor column is 0, exit else DEC col and go to 6
				;		- CR: set cursor to column 0 and go to step 6
				;		- LF: increment row and go to step 5 to check if scroll is needed
				;	4. Write the char to the current position (INT 10,A)
				;	5. If new row > last row, scroll up 1 row (INT 10,8).
				;	6. Update cursor position (INT 10,6)
				;
				;----------------------------------------------------------------------------;
 F55F				INT_10_E PROC
					PUSHX	AX, BX, CX, DX
			     1				IFNB <AX>			; exit if last reg 
 F55F  50                    1		PUSH	AX 					; push register and repeat 
			     1		PUSHX	BX, CX, DX, , , ,  
			     2				IFNB <BX>			; exit if last reg 
 F560  53                    2		PUSH	BX 					; push register and repeat 
			     2		PUSHX	CX, DX, , , , ,  
			     3				IFNB <CX>			; exit if last reg 
 F561  51                    3		PUSH	CX 					; push register and repeat 
			     3		PUSHX	DX, , , , , ,  
			     4				IFNB <DX>			; exit if last reg 
 F562  52                    4		PUSH	DX 					; push register and repeat 
			     4		PUSHX	, , , , , ,  
			     4				ENDIF 
			     3				ENDIF 
			     2				ENDIF 
			     1				ENDIF 
 F563  E8 F1EF R			CALL	INT_10_3_CUR_PAGE		; Get cursor pos: DH = row, DL = column
 F566  3C 0D				CMP	AL, CR			; is maybe a control code?
 F568  76 3E				JBE	INT_10_E_CTRL		; if so, jump to handle it
				
				;----------------------------------------------------------------------------;
				; Handle a regular char
				;
 F56A				INT_10_E_CHAR:
 F56A  B9 0001				MOV	CX, 1				; repeat only once
 F56D  E8 F3DF R			CALL	INT_10_A			; write char in AL at current row/col
				
				;----------------------------------------------------------------------------;
				; Handle line wrap
				;
 F570  A0 004A R			MOV	AL, BYTE PTR VID_COLS	; get screen cols (80 or 40)
 F573  48				DEC	AX				; fix 0 index (79 or 39)
 F574  3A D0				CMP	DL, AL			; reached end of screen cols?
 F576  72 02				JB	NEXT_COL			; jump if not
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-171


 F578  B2 FF				MOV	DL, -1			; else move to first col and next row
 F57A				NEXT_COL:
 F57A  42				INC	DX				; move to next column (and maybe row)
				
				;----------------------------------------------------------------------------;
				; Scroll if necessary
				;
 F57B				INT_10_E_SCROLL:
 F57B  80 FE 18				CMP	DH, VID_DEF_ROWS		; moved past last row?
 F57E  76 20				JBE	INT_10_E_CURS		; if not, no scroll necessary
 F580  FE CE				DEC	DH				; undo row scroll
 F582  E8 F085 R			CALL	INT_10_IS_TXT		; ZF = 1 if CGA/MDA Text, ZF = 0 if gfx
 F585  98				CBW					; if gfx mode, attribute AH = 0
 F586  75 03				JNZ	INT_10_E_SCROLL_UP	; jump if graphics
 F588  E8 F344 R			CALL	INT_10_8			; Read character: AH = attribute, AL = char
				
				;----------------------------------------------------------------------------;
				; Scroll up one line
				;
 F58B				INT_10_E_SCROLL_UP:
 F58B  53				PUSH	BX				; save video page (BH)
 F58C  93				XCHG	AX, BX			; BH = attribute
 F58D  B8 0601				MOV	AX, DBW <6, 1>		; AH = 06H Scroll Window Up, AL = 1 line
 F590  33 C9				XOR	CX, CX			; scroll top left: CH = row 0, CL = col 0
 F592  52				PUSH	DX				; save cursor bottom
 F593  8A 16 004A R			MOV	DL, BYTE PTR VID_COLS	; DL = right-most column (1-indexed)
 F597  B6 18				MOV	DH, VID_DEF_ROWS		; DH = bottom row (always 24)
 F599  4A				DEC	DX				; fixup 0-indexed column
 F59A  FC				CLD
 F59B  E8 F235 R			CALL	INT_10_6			; INT 10H, 06H Scroll Window Up
 F59E  5A				POP	DX				; restore cursor bottom
 F59F  5B				POP	BX				; restore video page (BH)
				
				;----------------------------------------------------------------------------;
				; Set new cursor position
				;
 F5A0				INT_10_E_CURS:
 F5A0  E8 F1B6 R			CALL	INT_10_2			; set cursor pos: BH = page, row = DH, col = DL
				
 F5A3				INT_10_E_DONE:
					POPX	DX, CX, BX, AX		; restore caller registers
			     1				IFNB <DX>			; exit if last reg 
 F5A3  5A                    1		POP	DX 					; pop register and repeat 
			     1		POPX	CX, BX, AX, , , ,  
			     2				IFNB <CX>			; exit if last reg 
 F5A4  59                    2		POP	CX 					; pop register and repeat 
			     2		POPX	BX, AX, , , , ,  
			     3				IFNB <BX>			; exit if last reg 
 F5A5  5B                    3		POP	BX 					; pop register and repeat 
			     3		POPX	AX, , , , , ,  
			     4				IFNB <AX>			; exit if last reg 
 F5A6  58                    4		POP	AX 					; pop register and repeat 
			     4		POPX	, , , , , ,  
			     4				ENDIF 
			     3				ENDIF 
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-172


			     2				ENDIF 
			     1				ENDIF 
 F5A7  C3				RET
				
				;----------------------------------------------------------------------------;
				; Handle control codes
				;
 F5A8				INT_10_E_CTRL:
 F5A8  74 11				JE	INT_10_E_CR			; is a CR? (from above)
 F5AA  3C 0A				CMP	AL, LF			; is an LF?
 F5AC  74 11				JE	INT_10_E_LF
 F5AE  3C 08				CMP	AL, BS			; is a backspace?
 F5B0  74 11				JE	INT_10_E_BS
 F5B2  3C 07				CMP	AL, BELL			; Isabelle?
 F5B4  75 B4				JNE	INT_10_E_CHAR		; otherwise, handle as a normal char
 F5B6				INT_10_E_BELL:
 F5B6  E8 E8AE R			CALL	BEEP				; beep for ^G
 F5B9  EB E8				JMP	INT_10_E_DONE		; exit
 F5BB				INT_10_E_CR:
 F5BB  32 D2				XOR	DL, DL			; move to column 0
 F5BD  EB E1				JMP	INT_10_E_CURS		; update cursor
 F5BF				INT_10_E_LF:
 F5BF  FE C6				INC	DH				; move to next row
 F5C1  EB B8				JMP	INT_10_E_SCROLL		; maybe scroll
 F5C3				INT_10_E_BS:
 F5C3  FE CA				DEC	DL				; back space one column
 F5C5  78 DC				JS	INT_10_E_DONE		; if first column, do nothing and exit
 F5C7  EB D7				JMP	INT_10_E_CURS		; update cursor
				
 F5C9				INT_10_E ENDP
				
				;----------------------------------------------------------------------------;
				; INT 10,F - Get current video state
				;----------------------------------------------------------------------------;
				; Input:
				;	AH = 0F
				; Output
				;	AH = number of screen columns
				;	AL = mode currently set
				;	BH = current display page
				;----------------------------------------------------------------------------;
 F5C9				INT_10_F PROC
 F5C9  A1 0049 R			MOV	AX, WORD PTR VID_MODE
 F5CC  8A 3E 0062 R			MOV	BH, VID_PAGE
 F5D0  C3				RET
 F5D1				INT_10_F ENDP
				
				;----------------------------------------------------------------------------;
				; Get video memory offset for current cursor position
				;----------------------------------------------------------------------------;
				; Input:
				;	BH = current video page
				; Output:
				;	DI = memory offset of current cursor in memory
				;	ES = video RAM segment
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-173


				; Clobbers: AX
				;----------------------------------------------------------------------------;
 F5D1				INT_10_GET_CUR_ADDR PROC
 F5D1  52				PUSH	DX
 F5D2  8A C7				MOV	AL, BH			; AL = display page
 F5D4  C4 3E 00E8 R			LES	DI, VID_MEM_SEG_DW	; ES = video RAM segment
 F5D8  98				CBW					; AX = page number
 F5D9  97				XCHG	AX, DI			; DI = page number
 F5DA  A1 004C R			MOV	AX, VID_BUF_SZ		; AX = VID_BUF_SZ
 F5DD  F7 E7				MUL	DI				; AX = page size * page (base offset)
 F5DF  D1 E7				SHL	DI, 1				; word align index
 F5E1  8B 95 0050 R			MOV	DX, VID_CURS_POS[DI]	; DX = cursor position on page
 F5E5  97				XCHG	AX, DI			; DI = page base offset
 F5E6  A0 004A R			MOV	AL, BYTE PTR VID_COLS
 F5E9  F6 E6				MUL	DH				; AX = screen cols * current row
 F5EB  92				XCHG	AX, DX			; DX = rows offset, AL = current col
 F5EC  98				CBW					; AX = current col
 F5ED  03 C2				ADD	AX, DX			; AX = page relative cursor offset
 F5EF  D1 E0				SHL	AX, 1				; word align
 F5F1  03 F8				ADD	DI, AX			; DI = memory offset of cursor
 F5F3  5A				POP	DX
 F5F4  C3				RET
 F5F5				INT_10_GET_CUR_ADDR ENDP
				
				;----------------------------------------------------------------------------;
				; 6845 CRT mode control register values
				;----------------------------------------------------------------------------;
				; CGA:
				;	|7|6|5|4|3|2|1|0|  3D8H Mode Select Register
				;	     | | | | | `---- 1 = 80x25 text, 0 = 40x25 text
				;	     | | | | `----- 1 = 320x200 graphics, 0 = text (unused on MDA)
				;	     | | | `------ 1 = B/W, 0 = color (unused on MDA)
				;	     | | `------- 1 = enable video signal
				;	     | `-------- 1 = 640x200 B/W graphics (unused on MDA)
				;	     `--------- 1 = blink, 0 = no blink
				; MDA:
				;	|7|6|5|4|3|2|1|0|  3B8 CRT Control Port
				;	     | | | | | `---- 1 = 80x25 text
				;	     | | | `------- unused
				;	     | | `-------- 1 = enable video signal
				;	     | `--------- unused
				;	     `---------- 1 = blinking on
				;
				; source: https://stanislavs.org/helppc/6845.html
				;----------------------------------------------------------------------------;
 F5F5  2C			CRT_MODE	DB	101100B	; 00: 40x25 B/W text (CGA)
 F5F6  28					DB	101000B	; 01: 40x25 16 color text (CGA)
 F5F7  2D					DB 	101101B	; 02: 80x25 16 shades of gray text (CGA)
 F5F8  29					DB	101001B	; 03: 80x25 16 color text (CGA)
 F5F9  2A					DB	101010B	; 04: 320x200 4 color graphics (CGA)
 F5FA  2E					DB	101110B	; 05: 320x200 4 color graphics (CGA)
 F5FB  1E					DB	011110B	; 06: 640x200 B/W graphics (CGA)
 F5FC  29					DB	101001B	; 07: 80x25 Monochrome text (MDA, HERC)
				
 F5FD				INT_10 ENDP
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-174


				
				;----------------------------------------------------------------------------;
				; Display system hardware config
				;----------------------------------------------------------------------------;
				; Input:
				;	DS = BDA (0040)
				;
				; Clobbers: AX, BX, CX, SI
				; Size: 193 bytes
				;----------------------------------------------------------------------------;
 F5FD				POST_SYS_CONFIG PROC
							ASSUME DS:_BDA
				
							IF POST_VIDEO_TYPE EQ 1
				;----------------------------------------------------------------------------;
				; Display Video Type
				;----------------------------------------------------------------------------;
 F5FD				POST_SYS_VIDEO PROC
					POST_COL_2	POST_VIDEO, POST_CLR_VAL1 ; display "Video" left column
			     1			ELSE 
 F5FD  B3 0A                 1		MOV	BL, LOW POST_CLR_VAL1		; BL = attribute 
			     1			ENDIF 
 F5FF  BE FF46 R             1		MOV	SI, OFFSET POST_VIDEO 
 F602  E8 F6FC R             1		CALL	POST_START_COL_2 
											; default to "None"
				
				;----------------------------------------------------------------------------;
				; Check if INT 10 is using this BIOS. If so, must be CGA or MDA.
				;
 F605  1E				PUSH	DS
 F606  33 C0				XOR	AX, AX				; AX = SEG _IVT
 F608  8E D8				MOV	DS, AX				; set IVT segment for LDS
							ASSUME DS:_IVT
 F60A  C5 06 0040 R			LDS	AX, DWORD PTR IVT_10		; if BIOS, DS = 0F000H, AX = 0F065H
 F60E  3D F065 R			CMP	AX, OFFSET INT_10			; is offset the BIOS IRR for INT 10?
 F611  8C D8				MOV	AX, DS				; save for next compare
 F613  1F				POP	DS					; restore DS
							ASSUME DS:_BDA
 F614  75 13				JNE	CHECK_VGA				; if not, jump to VGA check
 F616  8C CB				MOV	BX, CS				; AX = BIOS code segment
 F618  3B C3				CMP	AX, BX				; is BIOS segment?
 F61A  75 0D				JNE	CHECK_VGA				; if not, jump to VGA check
				
				;----------------------------------------------------------------------------;
				; Read BDA for video type
				;
 F61C				BIOS_VIDEO:
 F61C  E8 F085 R			CALL	INT_10_IS_TXT			; CF = 1 if MDA mode 7
 F61F  BE E826 R			MOV	SI, OFFSET POST_MDA		; default "MDA"
 F622  72 21				JC	POST_SYS_VIDEO_DONE
 F624  BE E822 R			MOV	SI, OFFSET POST_CGA		; otherwise "CGA"
 F627  EB 1C				JMP	SHORT POST_SYS_VIDEO_DONE
				
				;----------------------------------------------------------------------------;
				; Check if VGA
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-175


				; stanislavs.org/helppc/int_10-1a.html
				;
 F629				CHECK_VGA:
 F629  B8 1A00				MOV	AX, DBW <1AH, 0>			; AH = 1AH, get video display
 F62C  CD 10				INT	10H					; BL = display type
 F62E  3C 1A				CMP	AL, 1AH				; is VGA?
 F630  75 05				JNE	CHECK_EGA				; jump if not VGA
 F632  BE E81A R			MOV	SI, OFFSET POST_VGA		; is "VGA"
 F635  EB 0E				JMP	SHORT POST_SYS_VIDEO_DONE
				
				;----------------------------------------------------------------------------;
				; Check if EGA
				; stanislavs.org/helppc/int_10-12.html
				;
 F637				CHECK_EGA:
 F637  B4 12				MOV 	AH, 12H				; AH = 12H, get video configuration
 F639  B3 10				MOV	BL, 10H				; configuration info
 F63B  CD 10				INT	10H
 F63D  80 FB 10				CMP	BL, 10H				; check if param hasn't changed
 F640  74 03				JE	POST_SYS_VIDEO_DONE		; jump if not EGA
 F642  BE E81E R			MOV	SI, OFFSET POST_EGA		; is "EGA"
				
 F645				POST_SYS_VIDEO_DONE:
 F645  E8 F72E R			CALL	OUT_SZ				; display detected video adapter
 F648  E8 F70E R			CALL	POST_END_COL_NL			; end of column with NL and RET
				
 F64B				POST_SYS_VIDEO ENDP
							ENDIF
				
				;----------------------------------------------------------------------------;
				; Display CPU type
				;
					POST_COL_1	POST_CPU, POST_CLR_VAL1	; display 'CPU' left column
			     1			ELSE 
 F64B  B3 0A                 1		MOV	BL, LOW POST_CLR_VAL1		; BL = attribute 
			     1			ENDIF 
 F64D  BE E4BC R             1		MOV	SI, OFFSET POST_CPU 
 F650  E8 F6D5 R             1		CALL	POST_START_COL_1 
											;  SI now points to '8088'
 F653				CPU_CHECK_TYPE_2:
 F653  B8 7000				MOV AX, 7000H				; Try to set flag bits 12-14 to 1's
 F656  50				PUSH AX						; Push the test value onto the stack
 F657  9D				POPF						; Pop it into the flag register
 F658  9C				PUSHF						; Push it back onto the stack
 F659  58				POP AX						; Pop it into AX for check
 F65A  25 7000				AND AX, 7000H				; if bits 12-14 are cleared then
 F65D  75 06				JNZ CPU_CHECK_TYPE_V20		; the chip is a 80286
 F65F  BE E4E2 R			MOV SI, OFFSET POST_286
 F662  EB 0B 90				JMP CPU_CHECK_TYPE_2_DONE
 F665				CPU_CHECK_TYPE_V20:
					TEST_GFLAG V20				; ZF = 0 if V20, ZF = 1 if 8088
 F665  F6 06 0012 R 04       1		TEST	GB_FLAGS, MASK V20 
 F66A  74 03				JZ CPU_CHECK_TYPE_2_DONE	; jump if 8088
 F66C  BE E4E6 R			MOV	SI, OFFSET POST_V20		; if not, is V20
 F66F				CPU_CHECK_TYPE_2_DONE:
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-176


 F66F  E8 F72E R			CALL OUT_SZ					; write CPU type
					POST_COL_END				; end first column
 F672  E8 F713 R             1		CALL	POST_END_COL 
				
				;----------------------------------------------------------------------------;
				; Display FPU/math co-processor
				;
 F675				FPU_CHECK:
					POST_COL_2  POST_FPU, POST_CLR_VAL1	; display 'FPU', SI now '8087'
			     1			ELSE 
 F675  B3 0A                 1		MOV	BL, LOW POST_CLR_VAL1		; BL = attribute 
			     1			ENDIF 
 F677  BE E4C5 R             1		MOV	SI, OFFSET POST_FPU 
 F67A  E8 F6FC R             1		CALL	POST_START_COL_2 
					TEST_EFLAG  FPU				; was FPU detected?
			     1				IF FPU LT 8 
 F67D  F6 06 0010 R 02       1		TEST	BYTE PTR EQUIP_FLAGS, LOW MASK FPU 
			     1				ENDIF 
 F682  75 03				JNZ	FPU_DISP_DONE			; jump to output if FPU
 F684  BE FF4C R			MOV	SI, OFFSET POST_NONE		; otherwise 'None'
 F687				FPU_DISP_DONE:
 F687  E8 F72E R			CALL	OUT_SZ				; display string
					POST_COL_END_NL				; end second column, move to NL
 F68A  E8 F70E R             1		CALL	POST_END_COL_NL 
				
				;----------------------------------------------------------------------------;
				; Display LPT ports
				;
					POST_COL_1	POST_LPT, POST_CLR_VAL2	; display 'LPT' in column 1
			     1			ELSE 
 F68D  B3 0E                 1		MOV	BL, LOW POST_CLR_VAL2		; BL = attribute 
			     1			ENDIF 
 F68F  BE E4EA R             1		MOV	SI, OFFSET POST_LPT 
 F692  E8 F6D5 R             1		CALL	POST_START_COL_1 
					GET_EFLAG   LPT				; AX = number of LPT ports
			     1	;----------------------------------------------------------------------------; 
			     1	; Shift if flag is in high byte to low for byte operations 
			     1	; 
			     1				ELSE				; is in high byte 
 = 00C0                      1	??002E	= HIGH MASK LPT 
 = 0006                      1	??002F	= (LPT - 8) AND 0111B 
 = 0011                      1	??0030	= EQUIP_FLAGS[1]			; high BDA flags byte 
			     1				ENDIF 
 F695  A0 0011 R             1		MOV	AL, BYTE PTR ??0030		; AL = equipment flag byte 
 F698  25 00C0               1		AND	AX, ??002E			; isolate bits, clear AH 
			     1	;----------------------------------------------------------------------------; 
			     1	; Determine optimal number of shifts based on bit position and shift 
			     1	; right or left depending on fewest. 
			     1	; 
			     1				ELSE 
			     1					IF ??002F GT 4	; optimal to roll left 
 = 0002                      1						??002F = 8-??002F 
			     1						ELSE		; 0-2 shifts use single op(s) 
			     1							REPT ??002F 
			     1		ROL	AL, 1					; shift value into position 
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-177


			     1							ENDM 
 F69B  D0 C0                 2		ROL	AL, 1					; shift value into position 
 F69D  D0 C0                 2		ROL	AL, 1					; shift value into position 
			     1						ENDIF 
			     1					ENDIF 
			     1				ENDIF 
 F69F  91				XCHG	AX, CX				; CX = number of ports
 F6A0  BE 0008 R			MOV	SI, OFFSET LPT_ADDR
 F6A3  E8 F6B9 R			CALL	SHOW_PORT_COUNT
				
				;----------------------------------------------------------------------------;
				; Display COM ports
				;
					POST_COL_2	POST_COM, POST_CLR_VAL2	; display 'COM' in column 2
			     1			ELSE 
 F6A6  B3 0E                 1		MOV	BL, LOW POST_CLR_VAL2		; BL = attribute 
			     1			ENDIF 
 F6A8  BE E4EE R             1		MOV	SI, OFFSET POST_COM 
 F6AB  E8 F6FC R             1		CALL	POST_START_COL_2 
					GET_EFLAG   COM				; AX = number of COM ports
			     1	;----------------------------------------------------------------------------; 
			     1	; Shift if flag is in high byte to low for byte operations 
			     1	; 
			     1				ELSE				; is in high byte 
 = 000E                      1	??0031	= HIGH MASK COM 
 = 0001                      1	??0032	= (COM - 8) AND 0111B 
 = 0011                      1	??0033	= EQUIP_FLAGS[1]			; high BDA flags byte 
			     1				ENDIF 
 F6AE  A0 0011 R             1		MOV	AL, BYTE PTR ??0033		; AL = equipment flag byte 
 F6B1  25 000E               1		AND	AX, ??0031			; isolate bits, clear AH 
			     1	;----------------------------------------------------------------------------; 
			     1	; Determine optimal number of shifts based on bit position and shift 
			     1	; right or left depending on fewest. 
			     1	; 
			     1				ELSE 
			     1					ELSE			; optimal to roll right 
			     1						ELSE 
			     1							REPT ??0032 
			     1		ROR	AL, 1					; shift value into position 
			     1							ENDM 
 F6B4  D0 C8                 2		ROR	AL, 1					; shift value into position 
			     1						ENDIF 
			     1					ENDIF 
			     1				ENDIF 
 F6B6  91				XCHG	AX, CX				; CX = number of ports
 F6B7  33 F6				XOR	SI, SI				; OFFSET COM_ADDR = 0000H
				
				;----------------------------------------------------------------------------;
				; Display I/O addresses of COM or LPT ports on POST
				;----------------------------------------------------------------------------;
				; Input:
				;	SI = WORD array of ports
				;	CX = number of ports to show
				;----------------------------------------------------------------------------;
 F6B9				SHOW_PORT_COUNT PROC
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-178


 F6B9  E3 0E				JCXZ	PORT_COUNT_NONE			; if no ports, display 'None'
 F6BB				PORT_COUNT_LOOP:
 F6BB  AD				LODSW	
 F6BC  E8 F78B R			CALL	WORD_HEX				; display I/O address in hex
 F6BF  E8 F760 R			CALL	SPACE					; separate ports with space
 F6C2  E2 F7				LOOP	PORT_COUNT_LOOP
 F6C4  BE E4FF R			MOV	SI, OFFSET POST_RSEP[1]		; skip leading space in right sep.
 F6C7  EB 4D				JMP	SHORT POST_END_COL_STR		; display end with sep. in SI and RET
 F6C9				PORT_COUNT_NONE:
					PRINT_SZ  POST_NONE			; display 'None'
			     1			IFDIFI <POST_NONE>,<SI>			; if SZ is not SI 
 F6C9  BE FF4C R             1		MOV	SI, OFFSET POST_NONE 
			     1			ENDIF 
 F6CC  E8 F72E R             1		CALL	OUT_SZ 
 F6CF  EB 42				JMP	SHORT POST_END_COL		; display end sep and RET
 F6D1				SHOW_PORT_COUNT ENDP
				
 F6D1				POST_SYS_CONFIG ENDP
				
				;----------------------------------------------------------------------------;
				; Write POST column label and start separator 
				;----------------------------------------------------------------------------;
				; - Start new line
				; - display column name in color 1
				; - display left separator in color 1
				; - set color for inner text to be color 2
				;----------------------------------------------------------------------------;
				; Input:
				; - SI: column name string
				; - BL: inner text color/attribute
				;
				; Output:
				; - SI: beginning of next adjacent string
				; - CX: inner text color length = POST_TAB_COL_I
				;----------------------------------------------------------------------------;
 F6D1				POST_COL PROC
				
				;----------------------------------------------------------------------------;
				; Handle 40 column mode - move to next line and fall through to col 1
				;
 F6D1				POST_START_COL_2_40:
 F6D1  E8 F757 R			CALL	CRLF				; move to next line
 F6D4  58				POP	AX				; rebalance stack
 F6D5				POST_START_COL_1 PROC
 F6D5  50				PUSH	AX
 F6D6  B0 06				MOV	AL, POST_COL_W		; column 1 tab width
 F6D8				POST_START_COL_START:
 F6D8  53				PUSH	BX				; save inner text color
 F6D9  8A E3				MOV	AH, BL			; save text color
 F6DB  B9 0009				MOV	CX, POST_COL_VT		; set attribute on next CX # of chars
 F6DE  BB 0003				MOV	BX, LOW POST_CLR_TXT	; set outer text color
 F6E1  E8 F71C R			CALL	OUT_SZ_ATTR			; write SI string with attribute
 F6E4  E8 F73D R			CALL	MOVE_COL			; move cursor to separator column
 F6E7  56				PUSH	SI				; save end of string
 F6E8  BE E4FA R			MOV	SI, OFFSET POST_LSEP	; write separator string with
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-179


 F6EB  E8 F72E R			CALL	OUT_SZ			;  existing attributes
 F6EE  8A DC				MOV	BL, AH			; restore text color
 F6F0  4E				DEC	SI				; [SI] = previous null char
 F6F1  B1 13				MOV	CL, POST_TAB_COL_I	; CX = repeat times
 F6F3  51				PUSH	CX				; save for return
 F6F4  E8 F71C R			CALL	OUT_SZ_ATTR			; set attributes, skip null string
 F6F7  59				POP	CX				; CX = inner text color length
 F6F8  5E				POP	SI				; restore string position
 F6F9  5B				POP	BX				; BL = attribute for next CX chars
 F6FA  58				POP	AX
 F6FB  C3				RET
 F6FC				POST_START_COL_1 ENDP
				
				;----------------------------------------------------------------------------;
				; Same as POST_START_COL_1 except starts at column 2
				;----------------------------------------------------------------------------;
 F6FC				POST_START_COL_2 PROC
							ASSUME DS:_BDA
 F6FC  50				PUSH	AX
 F6FD  B4 0F				MOV	AH, 0FH			; get video mode
 F6FF  CD 10				INT	10H				; AL = video mode
 F701  3C 01				CMP	AL, 1				; is 40 column mode?
 F703  7E CC				JLE	POST_START_COL_2_40
 F705  B0 20				MOV	AL, POST_TAB_COL		; move to start of column 2
 F707  E8 F73D R			CALL	MOVE_COL
 F70A  B0 26				MOV	AL, POST_TAB_COL+POST_COL_W	; set abs. position for column 2 tab
 F70C  EB CA				JMP	POST_START_COL_START
 F70E				POST_START_COL_2 ENDP
				
				;----------------------------------------------------------------------------;
				; Same as POST_END_COL and displays a CRLF
				;----------------------------------------------------------------------------;
 F70E				POST_END_COL_NL PROC
 F70E  E8 F713 R			CALL	POST_END_COL
 F711  EB 44				JMP	SHORT CRLF			; write CRLF and RET
 F713				POST_END_COL_NL ENDP
				
				;----------------------------------------------------------------------------;
				; Write POST column end separator 
				;----------------------------------------------------------------------------;
				; Display right separator in color POST_CLR_TXT
				; Clobbers: BX
				;----------------------------------------------------------------------------;
 F713				POST_END_COL PROC
 F713  BE E4FE R			MOV	SI, OFFSET POST_RSEP
				
				;----------------------------------------------------------------------------;
				; POST_END_COL_STR: Write POST column end separator
				;----------------------------------------------------------------------------;
				; Input: CS:SI
				;----------------------------------------------------------------------------;
 F716				POST_END_COL_STR PROC
 F716  B9 0002				MOV	CX, 2
 F719  BB 0003				MOV	BX, LOW POST_CLR_TXT	; Fall through to OUT_SZ_ATTR and RET
				
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-180


				;----------------------------------------------------------------------------;
				; Write a zero-terminated string to console with attributes, no cursor move
				;----------------------------------------------------------------------------;
				; Sets attribute in BL for the next CX number of characters, past end of string.
				;
				; Input: CS:SI = String, CX = length, BL = attribute, BH = video page
				; Output: SI = end of string
				;----------------------------------------------------------------------------;
 F71C				OUT_SZ_ATTR PROC
							IF POST_THEME NE 0	; enable color/attribute display
 F71C  50				PUSH	AX
				
							IF MDA_ATTR LT 2	; filter MDA attributes
				;----------------------------------------------------------------------------;
				; Filter MDA attributes - display with intensity attribute only
				;
 F71D				MDA_COLOR_FIX:
 F71D  E8 F085 R			CALL	INT_10_IS_TXT		; CF if MDA
 F720  73 06				JNC	OUT_SZ_ATTR_SET		; skip if not MDA
							IF MDA_ATTR EQ 1	; only intensity
 F722  80 E3 0F				AND	BL, MASK MDIN OR MASK MDFG ; remove MDA blink and background attr
 F725  80 CB 07				OR	BL, MASK MDFG		; remove MDA underline attr
							ENDIF
							ENDIF
 F728				OUT_SZ_ATTR_SET:
 F728  B8 0920				MOV	AX, DBW <9, VID_SP>	; write empty char with attr CX # of times
 F72B  CD 10				INT	10H
 F72D  58				POP	AX				; Fall through to OUT_SZ and RET
							ENDIF			; POST_THEME NE 0
				
				;----------------------------------------------------------------------------;
				; Display a zero-terminated string in BIOS at CS:[SI]
				;----------------------------------------------------------------------------;
				; Input: CS:SI = String, BH = video page
				; Size: 24 bytes
				;----------------------------------------------------------------------------;
 F72E				OUT_SZ PROC
 F72E  50				PUSH	AX
 F72F  B4 0E				MOV	AH, 0EH			; TTY output
 F731				OUT_SZ_LOOP:
 F731  2E: AC				LODS	BYTE PTR CS:[SI]		; AL = CS:[SI++]
 F733  84 C0				TEST	AL, AL			; is zero terminator?
 F735  74 04				JZ	OUT_SZ_DONE			; if so, exit
 F737  CD 10				INT	10H
 F739  EB F6				JMP	SHORT OUT_SZ_LOOP
 F73B				OUT_SZ_DONE:
 F73B  58				POP	AX
 F73C  C3				RET
 F73D				OUT_SZ ENDP
 F73D				OUT_SZ_ATTR ENDP
 F73D				POST_END_COL_STR ENDP
 F73D				POST_END_COL ENDP
				
				;----------------------------------------------------------------------------;
				; Locate cursor to column on current line
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-181


				;----------------------------------------------------------------------------;
				; Input:
				; - AL = new col
				;
				; Size: 23 bytes
				;----------------------------------------------------------------------------;
 F73D				MOVE_COL PROC
							ELSE
					PUSHX	AX, BX, CX, DX		; must preserve all of these
			     1				IFNB <AX>			; exit if last reg 
 F73D  50                    1		PUSH	AX 					; push register and repeat 
			     1		PUSHX	BX, CX, DX, , , ,  
			     2				IFNB <BX>			; exit if last reg 
 F73E  53                    2		PUSH	BX 					; push register and repeat 
			     2		PUSHX	CX, DX, , , , ,  
			     3				IFNB <CX>			; exit if last reg 
 F73F  51                    3		PUSH	CX 					; push register and repeat 
			     3		PUSHX	DX, , , , , ,  
			     4				IFNB <DX>			; exit if last reg 
 F740  52                    4		PUSH	DX 					; push register and repeat 
			     4		PUSHX	, , , , , ,  
			     4				ENDIF 
			     3				ENDIF 
			     2				ENDIF 
			     1				ENDIF 
							ENDIF
 F741  50				PUSH	AX				; preserve AL on INT 10H call
 F742  B7 00				MOV	BH, 0 			; video page 0 (flags preserved)
 F744  B4 03				MOV	AH, 3 			; get cursor position
 F746  CD 10				INT	10H 				; DH = row, DL = column
 F748  58				POP	AX
 F749				MOVE_COL_SET:
 F749  8A D0				MOV	DL, AL			; set new column
 F74B  B4 02				MOV	AH, 2 			; set cursor position
 F74D  CD 10				INT	10H 				; row = DH, column = DL
							ELSE
					POPX	DX, CX, BX, AX
			     1				IFNB <DX>			; exit if last reg 
 F74F  5A                    1		POP	DX 					; pop register and repeat 
			     1		POPX	CX, BX, AX, , , ,  
			     2				IFNB <CX>			; exit if last reg 
 F750  59                    2		POP	CX 					; pop register and repeat 
			     2		POPX	BX, AX, , , , ,  
			     3				IFNB <BX>			; exit if last reg 
 F751  5B                    3		POP	BX 					; pop register and repeat 
			     3		POPX	AX, , , , , ,  
			     4				IFNB <AX>			; exit if last reg 
 F752  58                    4		POP	AX 					; pop register and repeat 
			     4		POPX	, , , , , ,  
			     4				ENDIF 
			     3				ENDIF 
			     2				ENDIF 
			     1				ENDIF 
							ENDIF
 F753  C3				RET
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-182


 F754				MOVE_COL ENDP
 F754				POST_COL ENDP
				
				;----------------------------------------------------------------------------;
				; Display a zero-terminated string in BIOS at CS:[SI] with ending NL
				;----------------------------------------------------------------------------;
				; Input: CS:SI = String
				; Size: 12 bytes
				;----------------------------------------------------------------------------;
 F754				OUTLN_SZ PROC
 F754  E8 F72E R			CALL	OUT_SZ			; write original string in SI
										; fall through to CRLF
				
				;----------------------------------------------------------------------------;
				; Write a CRLF string to console
				;----------------------------------------------------------------------------;
 F757				CRLF PROC
					PRINT_SZ  NL_Z, 1
			     1			IFNB	<1> 
 F757  56                    1		PUSH	SI					; save SI 
			     1			ENDIF 
			     1			IFDIFI <NL_Z>,<SI>			; if SZ is not SI 
 F758  BE E485 R             1		MOV	SI, OFFSET NL_Z 
			     1			ENDIF 
 F75B  E8 F72E R             1		CALL	OUT_SZ 
			     1			IFNB	<1> 
 F75E  5E                    1		POP	SI 
			     1			ENDIF 
 F75F  C3				RET
 F760				CRLF ENDP
				
 F760				OUTLN_SZ ENDP
				
				;----------------------------------------------------------------------------;
				; Write a space char to console (8 bytes)
				;----------------------------------------------------------------------------;
 F760				SPACE PROC
 F760  50				PUSH	AX				; no clobbery AX
 F761  B8 0E20				MOV	AX, DBW <0EH, ' '>	; AH = 0Eh, AL = space char
 F764  CD 10				INT	10H				; send to console
 F766  58				POP	AX
 F767  C3				RET
 F768				SPACE ENDP
				
				;----------------------------------------------------------------------------;
				; Write Unsigned word as decimal to console
				;----------------------------------------------------------------------------;
				; Input: AX value
				; Clobbers: AX, BX
				; Size: 23 bytes
				;----------------------------------------------------------------------------;
 F768				OUT_DECU PROC
 F768  BB 000A				MOV	BX, 10			; decimal divisor = 10
 F76B				OUT_DECU_R:
 F76B  52				PUSH	DX				; save remainder digit / caller DX
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-183


 F76C  33 D2				XOR	DX, DX 			; clear high word of dividend
 F76E  F7 F3				DIV	BX				; AX = DX:AX / 10, DX = DX:AX % 10
 F770  85 C0				TEST	AX, AX			; is zero?
 F772  74 03				JZ	OUT_DECU_DONE		; loop while AX > 0
 F774  E8 F76B R			CALL	OUT_DECU_R			; recursive call to next division
 F777				OUT_DECU_DONE:
 F777  92				XCHG	AX, DX			; AL = digit, AH = 0
 F778  35 0E30				XOR	AX, DBW <0EH, '0'>	; ASCII convert digit, AH = 0EH
 F77B  CD 10				INT	10H				; write to console
 F77D  5A				POP	DX				; restore digit
 F77E  C3				RET
 F77F				OUT_DECU ENDP
				
				;----------------------------------------------------------------------------;
				; Write DWORD BX:AX as HEX to console
				;----------------------------------------------------------------------------;
				; Input: BX:AX - 32 bit value to write
				; WORDS are separated by a colon ex: 1234:ABCD
				;
				; AX clobbered
				; Size: 50 bytes
				;----------------------------------------------------------------------------;
 F77F				DWORD_HEX PROC
 F77F  50				PUSH	AX 				; save AX
 F780  8B C3				MOV	AX, BX
 F782  E8 F78B R			CALL	WORD_HEX 			; write AX to console as HEX
 F785  B0 3A				MOV	AL, ':'
 F787  E8 F7A6 R			CALL	OUT_CHAR			; Write char in AL to console
 F78A  58				POP	AX 				; restore AX
				
				;--------------------------------------------------------------------------
				; Write WORD AX as HEX to console
				;--------------------------------------------------------------------------
 F78B				WORD_HEX PROC
 F78B  50				PUSH	AX 				; save AX
 F78C  8A C4				MOV	AL, AH 			; move high byte into low byte
 F78E  E8 F792 R			CALL	BYTE_HEX 			; write byte as HEX to console
 F791  58				POP	AX 				; restore AX
				
				;--------------------------------------------------------------------------
				; Write BYTE AL as HEX to console
				;--------------------------------------------------------------------------
 F792				BYTE_HEX PROC
 F792  50				PUSH	AX 				; save AL
							ELSE
						REPT	4
					SHR	AL, 1				; shift high nibble to low nibble
						ENDM
 F793  D0 E8                 1		SHR	AL, 1				; shift high nibble to low nibble 
 F795  D0 E8                 1		SHR	AL, 1				; shift high nibble to low nibble 
 F797  D0 E8                 1		SHR	AL, 1				; shift high nibble to low nibble 
 F799  D0 E8                 1		SHR	AL, 1				; shift high nibble to low nibble 
							ENDIF
 F79B  E8 F79F R			CALL	NIB_HEX 			; write low nibble of AL as HEX to console
 F79E  58				POP	AX 				; restore AL
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-184


				
				;--------------------------------------------------------------------------
				; Write low nibble of AL as HEX to console
				;--------------------------------------------------------------------------
 F79F				NIB_HEX PROC
 F79F  24 0F				AND	AL, 0FH 			; isolate low nibble
 F7A1  3C 0A				CMP	AL, 0AH 			; if < 0Ah, CF=1 and setup a -1 for ASCII
										;  adjust since 'A'-'9' is 7 (not 6)
 F7A3  1C 69				SBB	AL, -('0'+66H+1) 		; BCD bias for ASCII (30h + 66h + CF)
										;  AF if AL < 0Ah, CF = 1
										;  if > 9, high_nibble = 0Ah
										;  if <=9, high_nibble = 09h
 F7A5  2F				DAS					; BCD adjust to ASCII
										;  if low_nibble < 0Ah, low_nibble -= 6
										;  high_nibble -= 6
				
				;--------------------------------------------------------------------------
				; Write char in AL to console
				;--------------------------------------------------------------------------
 F7A6				OUT_CHAR PROC
 F7A6  50				PUSH	AX
 F7A7  53				PUSH	BX
 F7A8  B7 00				MOV	BH, 0				; video page = 0 (preserve flags)
 F7AA  B4 0E				MOV	AH, 0EH			; Write AL to screen tty mode
 F7AC  CD 10				INT	10H				; send to console
 F7AE  5B				POP	BX
 F7AF  58				POP	AX
 F7B0  C3				RET
				
 F7B1				OUT_CHAR ENDP
 F7B1				NIB_HEX ENDP
 F7B1				BYTE_HEX ENDP
 F7B1				WORD_HEX ENDP
 F7B1				DWORD_HEX ENDP
				
				;
				; 31 BYTES HERE
				;
				BYTES_HERE	INT_12
 = 0090                      1	BYTES_HERE_INT_12 = INT_12-$ 
			     1			IFDEF BYTES_HERE_INT_12 
			     1			IF2 
			     1			ENDIF 
			     1			ENDIF 
				
				;----------------------------------------------------------------------------;
				; INT 12H - Memory Size Determination
				;----------------------------------------------------------------------------;
				; Output
				;	AX = number of contiguous 1k memory blocks found at startup
				;----------------------------------------------------------------------------;
 F841						ORG 0F841H
 F841				INT_12 PROC
						ASSUME DS:_BDA
 F841  FB				STI 					; interrupts on
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-185


 F842  1E				PUSH	DS 				; save DS
 F843  B8 ---- R			MOV	AX, SEG _BDA
 F846  8E D8				MOV	DS, AX 			; DS = BDA
 F848  A1 0013 R			MOV	AX, MEM_SZ_KB 		; AX = DS:[MEM_SZ_KB]
 F84B  1F				POP	DS
 F84C  CF				IRET
 F84D				INT_12 ENDP
				
				;----------------------------------------------------------------------------;
				; INT 11H - BIOS Equipment Determination / BIOS Equipment Flags
				;----------------------------------------------------------------------------;
				; Output
				;	AX = data stored at BIOS Data Area location 0040:0010
				;----------------------------------------------------------------------------;
 F84D						ORG 0F84DH
 F84D				INT_11 PROC
						ASSUME DS:_BDA
 F84D  FB				STI 					; interrupts on
 F84E  1E				PUSH	DS 				; save DS
 F84F  B8 ---- R			MOV	AX, SEG _BDA
 F852  8E D8				MOV	DS, AX 			; DS = BDA
 F854  A1 0010 R			MOV	AX, EQUIP_FLAGS
 F857  1F				POP	DS
 F858  CF				IRET
 F859				INT_11 ENDP
				
				;----------------------------------------------------------------------------;
				; INT 15 - System BIOS Services / Cassette
				;----------------------------------------------------------------------------;
				;	INT 15,0  Turn cassette motor on
				;	INT 15,1  Turn cassette motor off
				;	INT 15,2  Read blocks from cassette
				;	INT 15,3  Write blocks to cassette
				;
				; Output:
				;	CF = 1, AH = 86H (unsupported/no cassette present)
				;
				; https://stanislavs.org/helppc/int_15.html
				; http://www.ctyme.com/intr/int-15.htm
				; http://www.techhelpmanual.com/212-int_15h__at_extended_services___apm.html
				;----------------------------------------------------------------------------;
 F859						ORG 0F859H
 F859				INT_15 PROC
 F859  FB				STI					; return with interrupts enabled
				
 F85A  B4 86				MOV	AH, 86H 			; return with unsupported function
 F85C				INT_15_EXIT:
 F85C  80 FC 01				CMP	AH, 1				; set CF if error (AH > 0)
 F85F  F5				CMC
					IRET_F				; IRET with current flags
 F860  CA 0002               1		RETF	2 
				
 F863				INT_15 ENDP
				
				;----------------------------------------------------------------------------;
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-186


				;
				; Features not included in 5150/Cassette build go below:
				;
				;----------------------------------------------------------------------------;
				
						IF POST_HD_PARMS EQ 1
				;----------------------------------------------------------------------------;
				; Display Hard Drive Parameters
				;----------------------------------------------------------------------------;
				; Display info for POST in drive DL
				;
				; Input:
				;	DL = drive #
				;
				; Clobbers: AX, BX
				;
				; Size: 100 bytes
				;----------------------------------------------------------------------------;
 F863				SHOW_DISK_PARAMS PROC
					PUSHX	CX, DX				; call preserve working registers
			     1				IFNB <CX>			; exit if last reg 
 F863  51                    1		PUSH	CX 					; push register and repeat 
			     1		PUSHX	DX, , , , , ,  
			     2				IFNB <DX>			; exit if last reg 
 F864  52                    2		PUSH	DX 					; push register and repeat 
			     2		PUSHX	, , , , , ,  
			     2				ENDIF 
			     1				ENDIF 
 F865  52				PUSH	DX					; save drive ID
 F866  E8 E71E R			CALL	GET_DISK_PARAMS			; AL=heads, BX=cyl, CL=sec, DL=#drives
 F869  5A				POP	DX					; restore drive ID
 F86A  72 54				JC	SHOW_DISK_PARAMS_DONE		; exit if error getting drive
 F86C  51				PUSH	CX					; save sectors/track for CHS display
 F86D  50				PUSH	AX					; save heads
 F86E  53				PUSH	BX					; save cylinders
				
				;----------------------------------------------------------------------------;
				; Display Drive letter
				;
					SET_SZ_ATTR	 POST_CLR_TXT, 1, 1	; set next char to be text color
			     1				IF POST_THEME NE 0	; display color 
			     1			IFNB	<1> 
 F86F  50                    1		PUSH	AX 
 F870  53                    1		PUSH	BX 
 F871  51                    1		PUSH	CX 
			     1			ENDIF ; IFNB 
 F872  B8 0920               1		MOV	AX, DBW <9, VID_SP>	; AH = write char w/attr, AL = space 
			     1			IFDIFI <POST_CLR_TXT>,<BL>	; if ATTR is not BL 
 F875  BB 0003               1		MOV	BX, LOW POST_CLR_TXT		; BH = video page 0, BL = attribute 
			     1			ENDIF	; IFDIFI 
 F878  B9 0001               1		MOV	CX, 1			; CX = repeat times 
 F87B  CD 10                 1		INT	10H 
			     1			IFNB	<1> 
 F87D  59                    1		POP	CX 
 F87E  5B                    1		POP	BX 
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-187


 F87F  58                    1		POP	AX 
			     1			ENDIF	; IFNB 
			     1				ENDIF			; END display color 
 F880  92				XCHG	AX, DX				; AL = drive ID, DX = # of heads
 F881  24 03				AND	AL, 0011B				; only drives 0-3
 F883  04 43				ADD	AL, 'C'				; convert to drive letter
 F885  E8 F7A6 R			CALL	OUT_CHAR
				
				;----------------------------------------------------------------------------;
				; Display HD size: MiB = C*H*S*512/1024/1024 = C*H*S/2048
				;
 F888  92				XCHG	AX, DX				; AX = # of heads
 F889  F6 E1				MUL	CL					; AX = heads * sectors
 F88B  F7 E3				MUL	BX					; DX:AX = heads * sectors * cyl
 F88D  B9 0800				MOV	CX, 1024 * (1024 / 512)		; AX = DX:AX / 2048
 F890  F7 F1				DIV	CX					; (size in MB)
					POST_COL_1	POST_HD, POST_CLR_VAL1	; start column 1, SI = POST_MB
			     1			ELSE 
 F892  B3 0A                 1		MOV	BL, LOW POST_CLR_VAL1		; BL = attribute 
			     1			ENDIF 
 F894  BE E4CE R             1		MOV	SI, OFFSET POST_HD 
 F897  E8 F6D5 R             1		CALL	POST_START_COL_1 
 F89A  E8 F768 R			CALL	OUT_DECU				; print size in MB
 F89D  E8 F72E R			CALL	OUT_SZ				; 'MB' (SI = POST_MB from above)
 F8A0  58				POP	AX					; AX = cylinders
					POST_COL_END				; end column 1
 F8A1  E8 F713 R             1		CALL	POST_END_COL 
				
				;----------------------------------------------------------------------------;
				; Display HD geometry: Cylinders Heads Sectors
				;
					POST_COL_2	POST_CHS, POST_CLR_VAL1 ; start column 2
			     1			ELSE 
 F8A4  B3 0A                 1		MOV	BL, LOW POST_CLR_VAL1		; BL = attribute 
			     1			ENDIF 
 F8A6  BE F8C3 R             1		MOV	SI, OFFSET POST_CHS 
 F8A9  E8 F6FC R             1		CALL	POST_START_COL_2 
 F8AC  E8 F768 R			CALL	OUT_DECU				; print # cylinders
 F8AF  E8 F760 R			CALL	SPACE
 F8B2  58				POP	AX					; AX = heads
 F8B3  E8 F76B R			CALL	OUT_DECU_R				; print # heads
 F8B6  E8 F760 R			CALL	SPACE
 F8B9  58				POP	AX					; AX = sectors/track
 F8BA  E8 F76B R			CALL	OUT_DECU_R				; print sec/track
					POST_COL_END_NL				; end column 2
 F8BD  E8 F70E R             1		CALL	POST_END_COL_NL 
				
 F8C0				SHOW_DISK_PARAMS_DONE:
					POPX	DX, CX				; restore working registers
			     1				IFNB <DX>			; exit if last reg 
 F8C0  5A                    1		POP	DX 					; pop register and repeat 
			     1		POPX	CX, , , , , ,  
			     2				IFNB <CX>			; exit if last reg 
 F8C1  59                    2		POP	CX 					; pop register and repeat 
			     2		POPX	, , , , , ,  
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-188


			     2				ENDIF 
			     1				ENDIF 
 F8C2  C3				RET
				
 F8C3  43 48 53 00		POST_CHS	DB	'CHS', 0			; CHS column 2 label
				
 F8C7				SHOW_DISK_PARAMS ENDP
						ENDIF
				
						IF RANDOM_TAGLINE EQ 1
				;----------------------------------------------------------------------------;
				; Display BIOS name and random tagline
				;----------------------------------------------------------------------------;
				; String is chosen from low two bits of BP
				; Clobbers: AX
				; Size: 111 bytes
				;----------------------------------------------------------------------------;
 F8C7				HELLO_RAND_TAGLINE PROC
					PRINT_SZ  TOP_BANNER		; display main banner
			     1			IFDIFI <TOP_BANNER>,<SI>			; if SZ is not SI 
 F8C7  BE E000 R             1		MOV	SI, OFFSET TOP_BANNER 
			     1			ENDIF 
 F8CA  E8 F72E R             1		CALL	OUT_SZ 
 F8CD  8B C5				MOV	AX, BP			; get random bits from BP
					POST_FLAG_CLR  GRND		; clear random bits from BP
			     1				ELSE 
 = 0001                      1	??0035	EQU	1				; use CLR1 (ZF unaffected) 
			     1				ENDIF 
			     1				ELSE 
 F8CF  83 E5 FC              1		AND	BP, NOT MASK GRND			; Clear flag 
			     1				ENDIF 
 F8D2  25 0003				AND	AX, MASK GRND		; only low 2 bits
 F8D5  96				XCHG	AX, SI			; SI = string offset table
 F8D6  D1 E6				SHL	SI, 1				; word align
 F8D8  2E: 8B B4 F92E R			MOV	SI, CS:TAGS[SI]		; SI = chosen tagline offset
					PRINT_SZ  SI			; display tagline
 F8DD  E8 F72E R             1		CALL	OUT_SZ 
 F8E0  BE E031 R			MOV	SI, OFFSET COPYRIGHT	; display copyright message
 F8E3  E9 F754 R			JMP	NEAR PTR OUTLN_SZ		; write and RET
				
				;----------------------------------------------------------------------------;
				; Three additional random taglines
				;
 F8E6  52 65 61 64 79 20	TAG1		DB	'Ready to believe you', 0
       74 6F 20 62 65 6C	
       69 65 76 65 20 79	
       6F 75 00			
 F8FB  41 62 6F 72 74 2C	TAG2		DB	'Abort, Retry, Succeed', 0
       20 52 65 74 72 79	
       2C 20 53 75 63 63	
       65 65 64 00		
 F911  57 68 65 6E 20 6C	TAG3		DB	'When life gives you lemonade', 0
       69 66 65 20 67 69	
       76 65 73 20 79 6F	
       75 20 6C 65 6D 6F	
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-189


       6E 61 64 65 00		
				;		DB	'An Energy Star Foe', 0
				;		DB	'Now 97% asbestos-free', 0
				;		DB	'Ought to be enough for anybody', 0
				
				;----------------------------------------------------------------------------;
				; Offset table for taglines
				;
 F92E  E00E R F8E6 R F8FB R	TAGS		DW	OFFSET TAG0, OFFSET TAG1, OFFSET TAG2, OFFSET TAG3
       F911 R			
				
 F936				HELLO_RAND_TAGLINE ENDP
						ENDIF
				
						IF POST_OPT_ROM EQ 1
				;----------------------------------------------------------------------------;
				; ROM scan loading - display segment, size and checksum error
				;----------------------------------------------------------------------------;
				; Input:
				;	AX = BIOS size in bytes
				;	DI = Option ROM scan end segment
				;	DL = ROM checksum value
				;
				; Clobbers: BX, DX
				;
				; Size: 105 bytes
				;----------------------------------------------------------------------------;
 F936				ROM_SCAN_POST PROC
 F936  50				PUSH	AX						; must call-preserve these
 F937  56				PUSH	SI
 F938  9C				PUSHF
				
				;----------------------------------------------------------------------------;
				; Ensure this is not scanning a display option ROM - could crash if video
				; ISR not is installed
				;
 F939  81 FF C800			CMP	DI, 0C800H					; is video ROM scan?
 F93D  76 32				JBE	ROM_SCAN_POST_EXIT			; exit if so
				
				;----------------------------------------------------------------------------;
				; Display ROM column
				;
 F93F  50				PUSH	AX						; save ROM size
					POST_COL_1  S_OPT_ROM, POST_CLR_VAL2	; start ROM column label
			     1			ELSE 
 F940  B3 0E                 1		MOV	BL, LOW POST_CLR_VAL2		; BL = attribute 
			     1			ENDIF 
 F942  BE F98A R             1		MOV	SI, OFFSET S_OPT_ROM 
 F945  E8 F6D5 R             1		CALL	POST_START_COL_1 
 F948  8C D8				MOV	AX, DS					; AX = ROM segment
 F94A  E8 F78B R			CALL	WORD_HEX					; display as hex
					POST_COL_END					; end column 1
 F94D  E8 F713 R             1		CALL	POST_END_COL 
 F950  58				POP	AX
				
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-190


				;----------------------------------------------------------------------------;
				; Display Size or Checksum error column
				;
 F951  9D				POPF							; restore checksum flag
 F952  9C				PUSHF							; re-save flag
 F953  75 20				JNZ	ROM_SCAN_POST_CHK				; jump if checksum error
 F955  50				PUSH	AX						; save ROM size again
					POST_COL_2  S_OPT_SIZE, POST_CLR_VAL2	; start 'Size' column 2
			     1			ELSE 
 F956  B3 0E                 1		MOV	BL, LOW POST_CLR_VAL2		; BL = attribute 
			     1			ENDIF 
 F958  BE F98E R             1		MOV	SI, OFFSET S_OPT_SIZE 
 F95B  E8 F6FC R             1		CALL	POST_START_COL_2 
 F95E  58				POP	AX
 F95F  86 E0				XCHG	AH, AL					; convert bytes to KB
 F961  D0 E8				SHR	AL, 1
 F963  D0 E8				SHR	AL, 1
 F965  E8 F768 R			CALL	OUT_DECU					; write size as decimal
					PRINT_SZ	S_OPT_K				; display KB unit
			     1			IFDIFI <S_OPT_K>,<SI>			; if SZ is not SI 
 F968  BE F99B R             1		MOV	SI, OFFSET S_OPT_K 
			     1			ENDIF 
 F96B  E8 F72E R             1		CALL	OUT_SZ 
				
 F96E				ROM_SCAN_POST_DONE:
					POST_COL_END_NL					; end column 2
 F96E  E8 F70E R             1		CALL	POST_END_COL_NL 
				
 F971				ROM_SCAN_POST_EXIT:
 F971  9D				POPF							; restore checksum result flag
 F972  5E				POP	SI
 F973  58				POP	AX
 F974  C3				RET
				
				;----------------------------------------------------------------------------;
				; Display checksum error
				;
 F975				ROM_SCAN_POST_CHK:
					POST_COL_2  POST_ERR_ERR, RED			; 'Error' with red text
			     1			ELSE 
 F975  B3 0C                 1		MOV	BL, LOW RED		; BL = attribute 
			     1			ENDIF 
 F977  BE E90C R             1		MOV	SI, OFFSET POST_ERR_ERR 
 F97A  E8 F6FC R             1		CALL	POST_START_COL_2 
					PRINT_SZ	S_OPT_CHK				; display 'Checksum' message
			     1			IFDIFI <S_OPT_CHK>,<SI>			; if SZ is not SI 
 F97D  BE F993 R             1		MOV	SI, OFFSET S_OPT_CHK 
			     1			ENDIF 
 F980  E8 F72E R             1		CALL	OUT_SZ 
 F983  8A C2				MOV	AL, DL					; AL = computed checksum
 F985  E8 F792 R			CALL	BYTE_HEX					; write as hex byte
 F988  EB E4				JMP	ROM_SCAN_POST_DONE			; end column and return
				
 F98A  52 4F 4D 00		S_OPT_ROM	DB	'ROM', 0
 F98E  53 69 7A 65 00		S_OPT_SIZE	DB	'Size', 0
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-191


 F993  43 68 6B 73 75 6D	S_OPT_CHK	DB	'Chksum ', 0			; Checksum
       20 00			
 F99B  20 4B 42 00		S_OPT_K	DB	' ', POST_K_UNIT, 0
				
 F99F				ROM_SCAN_POST ENDP
						ENDIF
				
						IF LIGHT_PEN EQ 1
				;----------------------------------------------------------------------------;
				; INT 10,4 - Read Light Pen Position
				;----------------------------------------------------------------------------;
				; Return:
				;	AH = 0 light pen switch not triggered
				;	   = 1 light pen triggered
				;	BX = pixel column (0-319 or 0-639, mode dependent)
				;	CH = raster line (0-199) (CGA and EGA modes 4, 5 and 6)
				;	CX = raster line (EGA modes except 4, 5 and 6)
				;	DH = row (0-24)
				;	DL = column (0-79 or 0-79 mode dependent)
				;
				; Size: 128 bytes
				;
				; Thx to @Raffzahn for "clean room" specs.
				;----------------------------------------------------------------------------;
				; https://nerdlypleasures.blogspot.com/2016/05/ibms-cga-hardware-explained.html
				; https://www.reenigne.org/blog/cga-reading-the-current-beam-position-with-the-lightpen-latch/
				; https://scalibq.wordpress.com/2015/04/19/8088-mph-sprites-where-were-going-we-dont-need-sprites/
				;----------------------------------------------------------------------------;
 F99F				INT_10_4 PROC
 F99F  8B FA				MOV	DI, DX			; save caller DX
 F9A1  8B 16 0063 R			MOV	DX, VID_PORT		; 6845 I/O port address (3x4h)
 F9A5  83 C2 06				ADD	DX, CGA_STAT-CGA_IDX	; DX = 3xAh status port
 F9A8  EC				IN	AL, DX			; read Status Register
 F9A9  32 E4				XOR	AH, AH			; AH = 0 (switch not triggered)
 F9AB  A8 04				TEST	AL, MASK VSPE		; light pen on? (/0100b) (0=on, 1=off)
 F9AD  75 4A				JNZ	INT_10_4_RESET		; if light pen off, reset latch and exit
 F9AF  A8 02				TEST	AL, MASK VSPT		; light pen trigger set? (0010b) (0=not set, 1=set)
 F9B1  74 4A				JZ	INT_10_4_EXIT		; if not set, just exit
				
				;----------------------------------------------------------------------------;
				; Trigger is set, read light pen word from 6845. Address Register is latched
				; into light pen register when LPSTB pulses high.
				;
 F9B3  83 EA 06				SUB	DX, CGA_STAT-CGA_IDX	; DX = 3x4h index port
 F9B6  B0 10				MOV	AL, 10h			; light pen index (MSB)
 F9B8  EE				OUT	DX, AL			; select index
 F9B9  42				INC	DX				; DX = 3x5h data port
 F9BA  EC				IN	AL, DX			; read MSB
 F9BB  8A E0				MOV	AH, AL			; save MSB
 F9BD  4A				DEC	DX				; DX = 3x4h index port
 F9BE  B0 11				MOV	AL, 11h			; light pen index (LSB)
 F9C0  EE				OUT	DX, AL			; select index
 F9C1  42				INC	DX				; DX = 3x5h data port
 F9C2  EC				IN	AL, DX			; read LSB
				
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-192


				;----------------------------------------------------------------------------;
				; Calculate screen location from latched address. Address needs a
				; "calibration factor" applied due to "slow light pen response".
				;
				; -3: 0,1,4,5,6 (CGA low-res text/gfx)
				; -5: 2,3 (CGA hi-res text)
				; -4: 7 (MDA text)
				;
 F9C3  8B 1E 004E R			MOV	BX, VID_SEG			; BX = start offset of video memory
 F9C7  D1 EB				SHR	BX, 1				; byte align index
 F9C9  83 C3 03				ADD	BX, 3				; BX = minimum calibration factor
 F9CC  91				XCHG	AX, CX			; save AX
 F9CD  E8 F085 R			CALL	INT_10_IS_TXT		; ZF=1 if text, ZF=0 if gfx, CF=1 if MDA
 F9D0  9F				LAHF					; save video type flags for later
 F9D1  75 08				JNZ	INT_10_4_CAL_2		; skip if modes 4,5,6
 F9D3  72 05				JC	INT_10_4_CAL_1		; +1 if MDA mode 7
 F9D5  3C 02				CMP	AL, 2				; AL < 2?
 F9D7  7C 02				JL	INT_10_4_CAL_2		; skip if modes 0,1 (+0)
 F9D9  43				INC	BX				; +1 for modes 2,3
 F9DA				INT_10_4_CAL_1:
 F9DA  43				INC	BX				; +1 for modes 2,3,7
 F9DB				INT_10_4_CAL_2:
 F9DB  2B CB				SUB	CX, BX			; CX = calibrated memory regen offset
 F9DD  73 02				JAE	INT_10_4_CAL_DONE		; is result < 0?
 F9DF  33 C9				XOR	CX, CX			; if so, use base offset 0000
 F9E1				INT_10_4_CAL_DONE:
 F9E1  9E				SAHF					; ZF=1 if text, ZF=0 if gfx
 F9E2  91				XCHG	AX, CX			; restore AX, CL = video mode
 F9E3  75 1B				JNZ	INT_10_4_GFX		; jump if graphics mode
				
				;----------------------------------------------------------------------------;
				; Calculate output for Text mode
				;
				; Input:
				;	AX = calibrated memory offset
				; Output:
				;	BX = pixel column (0-319 or 0-639)
				;	CH = raster line (0-199)
				;	DI = (value for DX) DH = row (0-24), DL = column (0-79)
				;----------------------------------------------------------------------------;
				; Formula:
				;	DX = calibrated memory offset (AX) DIV video columns (DH=row, DL=col)
				;	BX = col (DL) * 8
				;	CH = row (DH) * 8
				;----------------------------------------------------------------------------;
 F9E5				INT_10_4_TXT:
 F9E5  B1 03				MOV	CL, 3				; shift counter 3 (for * 8)
 F9E7  F6 36 004A R			DIV	BYTE PTR VID_COLS		; divide value by char/line
 F9EB  86 E0				XCHG	AH, AL			; AH = row, AL = col
 F9ED  8B F8				MOV	DI, AX			; DH = row, DL = col
 F9EF  8A EC				MOV	CH, AH			; CH = row
 F9F1  D2 E5				SHL	CH, CL			; CH = raster line (col * 8)
 F9F3  98				CBW					; AH = 0, AL = col
 F9F4  D3 E0				SHL	AX, CL			; AX = col * 8
 F9F6  93				XCHG	AX, BX			; BX = pixel column
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-193


				
				;----------------------------------------------------------------------------;
				; DONE: Clear latch and return with AH = 1
				;
 F9F7				INT_10_4_DONE:
 F9F7  B4 01				MOV	AH, 1				; light pen triggered
				
				;----------------------------------------------------------------------------;
				; Light pen strobe reset
				;
 F9F9				INT_10_4_RESET:
 F9F9  83 C2 06				ADD	DX, CGA_PEN_RST-CGA_DATA	; pen latch register
 F9FC  EE				OUT	DX, AL			; reset light pen latch
				
 F9FD				INT_10_4_EXIT:
 F9FD  8B D7				MOV	DX, DI			; restore/output DX
 F9FF  C3				RET
				
				;----------------------------------------------------------------------------;
				; Calculate output for GFX mode
				;
				; Input:
				;	AX = calibrated memory offset
				;	CL = video mode
				; Output:
				;	BX = pixel column (0-319 or 0-639)
				;	CH = raster line (0-199)
				;	DI = (value for DX) DH = row (0-24), DL = column (0-79)
				;----------------------------------------------------------------------------;
				; Formula:
				; 	DX = calibrated memory offset (AX) DIV 40 (DH=row, DL=col)
				;	CH = row (DH) * 2
				;	DH = row (DH) / 4
				;	if ( high res ):
				; 		DL = col (DL) * 2
				;	BX = DL * 8
				;
				; Note: output registers used as variable names in comments below.
				;----------------------------------------------------------------------------;
 FA00				INT_10_4_GFX:
 FA00  B5 28				MOV	CH, 40			; divide value by 40
 FA02  F6 F5				DIV	CH				; AL = row, AH = col
 FA04  86 E0				XCHG	AH, AL			; AH = row, AL = col
 FA06  8A EC				MOV	CH, AH			; CH = row (DH) * 2
 FA08  D0 E5				SHL	CH, 1				; adjust for odd/even fields
				
				;----------------------------------------------------------------------------;
				; Multiply column according to graphics mode
				;
 FA0A  80 F9 06				CMP	CL, 6				; is 640x200 mode?
 FA0D  75 02				JNE	INT_10_4_LOW		; if not, jump
 FA0F  D0 E0				SHL	AL, 1				; DL = col (DL) * 2
 FA11				INT_10_4_LOW:
 FA11  B1 03				MOV	CL, 3				; shift counter 3 for * 8
 FA13  8B D8				MOV	BX, AX			; BL = DL for pixel column
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-194


 FA15  98				CBW					; zero extend BL
 FA16  D3 E0				SHL	AX, CL			; BX = DL * 8
 FA18  93				XCHG	AX, BX			; return as BX
 FA19  49				DEC	CX				; shift counter 2 for / 4
 FA1A  D2 EC				SHR	AH, CL			; DH = row / 4
 FA1C  97				XCHG	AX, DI			; return as DX
 FA1D  EB D8				JMP	SHORT INT_10_4_DONE	; clear latch and return with AH=1
 FA1F				INT_10_4 ENDP
						ENDIF
				
				;
				; 79 BYTES HERE / 0 BYTES HERE 5150
				;
				BYTES_HERE	GFX_CHARSET
 = 004F                      1	BYTES_HERE_GFX_CHARSET = GFX_CHARSET-$ 
			     1			IFDEF BYTES_HERE_GFX_CHARSET 
			     1			IF2 
			     1			ENDIF 
			     1			ENDIF 
				
				;----------------------------------------------------------------------------;
				; INT 1F - 8x8 Font bitmaps
				;----------------------------------------------------------------------------;
				; Font bitmaps from "VileR", (CC BY-SA 4.0)
				; https://int10h.org/oldschool-pc-fonts/
				;----------------------------------------------------------------------------;
 FA6E						ORG 0FA6EH
 FA6E				GFX_CHARSET LABEL BYTE
							ELSE
				;----------------------------------------------------------------------------;
				; A more clone style font
				;
 FA6E  00 00 00 00 00 00		DB	000H, 000H, 000H, 000H, 000H, 000H, 000H, 000H	; 00H
       00 00			
 FA76  7E 81 A5 81 BD 99		DB	07EH, 081H, 0A5H, 081H, 0BDH, 099H, 081H, 07EH	; 01H
       81 7E			
 FA7E  7E DB FF FF C3 E7		DB	07EH, 0DBH, 0FFH, 0FFH, 0C3H, 0E7H, 07EH, 000H	; 02H
       7E 00			
 FA86  36 7F 7F 7F 3E 1C		DB	036H, 07FH, 07FH, 07FH, 03EH, 01CH, 008H, 000H	; 03H
       08 00			
 FA8E  08 1C 3E 7F 3E 1C		DB	008H, 01CH, 03EH, 07FH, 03EH, 01CH, 008H, 000H	; 04H
       08 00			
 FA96  18 3C 18 66 FF 66		DB	018H, 03CH, 018H, 066H, 0FFH, 066H, 018H, 03CH	; 05H
       18 3C			
 FA9E  08 1C 3E 7F 7F 3E		DB	008H, 01CH, 03EH, 07FH, 07FH, 03EH, 008H, 01CH	; 06H
       08 1C			
 FAA6  00 00 18 3C 3C 18		DB	000H, 000H, 018H, 03CH, 03CH, 018H, 000H, 000H	; 07H
       00 00			
 FAAE  FF FF E7 C3 C3 E7		DB	0FFH, 0FFH, 0E7H, 0C3H, 0C3H, 0E7H, 0FFH, 0FFH	; 08H
       FF FF			
 FAB6  00 3C 66 42 42 66		DB	000H, 03CH, 066H, 042H, 042H, 066H, 03CH, 000H	; 09H
       3C 00			
 FABE  FF C3 99 BD BD 99		DB	0FFH, 0C3H, 099H, 0BDH, 0BDH, 099H, 0C3H, 0FFH	; 0AH
       C3 FF			
 FAC6  3F 0D 1C 3E 63 63		DB	03FH, 00DH, 01CH, 03EH, 063H, 063H, 03EH, 000H	; 0BH
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-195


       3E 00			
 FACE  3E 63 63 3E 1C 7F		DB	03EH, 063H, 063H, 03EH, 01CH, 07FH, 01CH, 000H	; 0CH
       1C 00			
 FAD6  0E 0F 0D 0D 1C 7F		DB	00EH, 00FH, 00DH, 00DH, 01CH, 07FH, 01CH, 000H	; 0DH
       1C 00			
 FADE  0F 3B 37 3B 33 37		DB	00FH, 03BH, 037H, 03BH, 033H, 037H, 077H, 070H	; 0EH
       77 70			
 FAE6  18 DB 3C E7 3C DB		DB	018H, 0DBH, 03CH, 0E7H, 03CH, 0DBH, 018H, 000H	; 0FH
       18 00			
 FAEE  60 78 7E 7F 7E 78		DB	060H, 078H, 07EH, 07FH, 07EH, 078H, 060H, 000H	; 10H
       60 00			
 FAF6  03 0F 3F 7F 3F 0F		DB	003H, 00FH, 03FH, 07FH, 03FH, 00FH, 003H, 000H	; 11H
       03 00			
 FAFE  18 3C 7E 18 18 7E		DB	018H, 03CH, 07EH, 018H, 018H, 07EH, 03CH, 018H	; 12H
       3C 18			
 FB06  66 66 66 66 66 00		DB	066H, 066H, 066H, 066H, 066H, 000H, 066H, 000H	; 13H
       66 00			
 FB0E  3F 6D 6D 3D 0D 0D		DB	03FH, 06DH, 06DH, 03DH, 00DH, 00DH, 00DH, 000H	; 14H
       0D 00			
 FB16  3F 70 3E 63 63 3E		DB	03FH, 070H, 03EH, 063H, 063H, 03EH, 007H, 07EH	; 15H
       07 7E			
 FB1E  00 00 00 00 FF FF		DB	000H, 000H, 000H, 000H, 0FFH, 0FFH, 0FFH, 000H	; 16H
       FF 00			
 FB26  3C 7E 18 18 7E 3C		DB	03CH, 07EH, 018H, 018H, 07EH, 03CH, 018H, 07EH	; 17H
       18 7E			
 FB2E  18 3C 7E 18 18 18		DB	018H, 03CH, 07EH, 018H, 018H, 018H, 018H, 000H	; 18H
       18 00			
 FB36  18 18 18 18 7E 3C		DB	018H, 018H, 018H, 018H, 07EH, 03CH, 018H, 000H	; 19H
       18 00			
 FB3E  18 0C 06 7F 06 0C		DB	018H, 00CH, 006H, 07FH, 006H, 00CH, 018H, 000H	; 1AH
       18 00			
 FB46  0C 18 30 7F 30 18		DB	00CH, 018H, 030H, 07FH, 030H, 018H, 00CH, 000H	; 1BH
       0C 00			
 FB4E  00 00 00 60 60 7F		DB	000H, 000H, 000H, 060H, 060H, 07FH, 000H, 000H	; 1CH
       00 00			
 FB56  00 24 66 FF 66 24		DB	000H, 024H, 066H, 0FFH, 066H, 024H, 000H, 000H	; 1DH
       00 00			
 FB5E  08 1C 1C 3E 3E 7F		DB	008H, 01CH, 01CH, 03EH, 03EH, 07FH, 07FH, 000H	; 1EH
       7F 00			
 FB66  7F 7F 3E 3E 1C 1C		DB	07FH, 07FH, 03EH, 03EH, 01CH, 01CH, 008H, 000H	; 1FH
       08 00			
 FB6E  00 00 00 00 00 00		DB	000H, 000H, 000H, 000H, 000H, 000H, 000H, 000H	; 20H  
       00 00			
 FB76  18 18 18 18 18 00		DB	018H, 018H, 018H, 018H, 018H, 000H, 018H, 000H	; 21H !
       18 00			
 FB7E  33 66 CC 00 00 00		DB	033H, 066H, 0CCH, 000H, 000H, 000H, 000H, 000H	; 22H "
       00 00			
 FB86  36 36 7F 36 36 7F		DB	036H, 036H, 07FH, 036H, 036H, 07FH, 036H, 036H	; 23H #
       36 36			
 FB8E  18 7E 58 38 1C 1A		DB	018H, 07EH, 058H, 038H, 01CH, 01AH, 07EH, 018H	; 24H $
       7E 18			
 FB96  E3 A6 EC 18 37 65		DB	0E3H, 0A6H, 0ECH, 018H, 037H, 065H, 0C7H, 000H	; 25H %
       C7 00			
 FB9E  3C 66 3C 38 6D 66		DB	03CH, 066H, 03CH, 038H, 06DH, 066H, 03DH, 000H	; 26H &
       3D 00			
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-196


 FBA6  06 0C 18 00 00 00		DB	006H, 00CH, 018H, 000H, 000H, 000H, 000H, 000H	; 27H '
       00 00			
 FBAE  1C 30 60 60 60 30		DB	01CH, 030H, 060H, 060H, 060H, 030H, 01CH, 000H	; 28H (
       1C 00			
 FBB6  38 0C 06 06 06 0C		DB	038H, 00CH, 006H, 006H, 006H, 00CH, 038H, 000H	; 29H )
       38 00			
 FBBE  63 36 1C 7F 1C 36		DB	063H, 036H, 01CH, 07FH, 01CH, 036H, 063H, 000H	; 2AH *
       63 00			
 FBC6  18 18 18 7E 18 18		DB	018H, 018H, 018H, 07EH, 018H, 018H, 018H, 000H	; 2BH +
       18 00			
 FBCE  00 00 00 00 00 18		DB	000H, 000H, 000H, 000H, 000H, 018H, 018H, 030H	; 2CH ,
       18 30			
 FBD6  00 00 00 7E 00 00		DB	000H, 000H, 000H, 07EH, 000H, 000H, 000H, 000H	; 2DH -
       00 00			
 FBDE  00 00 00 00 00 18		DB	000H, 000H, 000H, 000H, 000H, 018H, 018H, 000H	; 2EH .
       18 00			
 FBE6  02 06 0C 18 30 60		DB	002H, 006H, 00CH, 018H, 030H, 060H, 040H, 000H	; 2FH /
       40 00			
 FBEE  3E 63 63 6B 63 63		DB	03EH, 063H, 063H, 06BH, 063H, 063H, 03EH, 000H	; 30H 0
       3E 00			
 FBF6  1C 3C 0C 0C 0C 0C		DB	01CH, 03CH, 00CH, 00CH, 00CH, 00CH, 00CH, 000H	; 31H 1
       0C 00			
 FBFE  3E 63 03 0E 38 60		DB	03EH, 063H, 003H, 00EH, 038H, 060H, 07FH, 000H	; 32H 2
       7F 00			
 FC06  7C 06 06 3C 06 06		DB	07CH, 006H, 006H, 03CH, 006H, 006H, 07CH, 000H	; 33H 3
       7C 00			
 FC0E  0E 1E 36 66 7F 06		DB	00EH, 01EH, 036H, 066H, 07FH, 006H, 006H, 000H	; 34H 4
       06 00			
 FC16  7E 60 7C 06 06 06		DB	07EH, 060H, 07CH, 006H, 006H, 006H, 07CH, 000H	; 35H 5
       7C 00			
 FC1E  1E 30 60 7E 63 63		DB	01EH, 030H, 060H, 07EH, 063H, 063H, 03EH, 000H	; 36H 6
       3E 00			
 FC26  7E 66 0C 18 30 30		DB	07EH, 066H, 00CH, 018H, 030H, 030H, 030H, 000H	; 37H 7
       30 00			
 FC2E  3E 63 36 1C 36 63		DB	03EH, 063H, 036H, 01CH, 036H, 063H, 03EH, 000H	; 38H 8
       3E 00			
 FC36  3E 63 63 3F 03 06		DB	03EH, 063H, 063H, 03FH, 003H, 006H, 07CH, 000H	; 39H 9
       7C 00			
 FC3E  00 00 18 18 00 18		DB	000H, 000H, 018H, 018H, 000H, 018H, 018H, 000H	; 3AH :
       18 00			
 FC46  00 00 18 18 00 18		DB	000H, 000H, 018H, 018H, 000H, 018H, 018H, 030H	; 3BH ;
       18 30			
 FC4E  0C 18 30 60 30 18		DB	00CH, 018H, 030H, 060H, 030H, 018H, 00CH, 000H	; 3CH <
       0C 00			
 FC56  00 00 7E 00 7E 00		DB	000H, 000H, 07EH, 000H, 07EH, 000H, 000H, 000H	; 3DH =
       00 00			
 FC5E  30 18 0C 06 0C 18		DB	030H, 018H, 00CH, 006H, 00CH, 018H, 030H, 000H	; 3EH >
       30 00			
 FC66  3E 63 06 0C 0C 00		DB	03EH, 063H, 006H, 00CH, 00CH, 000H, 00CH, 000H	; 3FH ?
       0C 00			
 FC6E  3E 63 6F 69 6F 60		DB	03EH, 063H, 06FH, 069H, 06FH, 060H, 03FH, 000H	; 40H @
       3F 00			
 FC76  3C 66 66 7E 66 66		DB	03CH, 066H, 066H, 07EH, 066H, 066H, 066H, 000H	; 41H A
       66 00			
 FC7E  7E 63 63 7E 63 63		DB	07EH, 063H, 063H, 07EH, 063H, 063H, 07EH, 000H	; 42H B
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-197


       7E 00			
 FC86  1E 33 60 60 60 33		DB	01EH, 033H, 060H, 060H, 060H, 033H, 01EH, 000H	; 43H C
       1E 00			
 FC8E  7C 66 63 63 63 66		DB	07CH, 066H, 063H, 063H, 063H, 066H, 07CH, 000H	; 44H D
       7C 00			
 FC96  7E 60 60 7C 60 60		DB	07EH, 060H, 060H, 07CH, 060H, 060H, 07EH, 000H	; 45H E
       7E 00			
 FC9E  7E 60 60 7C 60 60		DB	07EH, 060H, 060H, 07CH, 060H, 060H, 060H, 000H	; 46H F
       60 00			
 FCA6  1E 33 63 60 67 33		DB	01EH, 033H, 063H, 060H, 067H, 033H, 01EH, 000H	; 47H G
       1E 00			
 FCAE  63 63 63 7F 63 63		DB	063H, 063H, 063H, 07FH, 063H, 063H, 063H, 000H	; 48H H
       63 00			
 FCB6  3C 18 18 18 18 18		DB	03CH, 018H, 018H, 018H, 018H, 018H, 03CH, 000H	; 49H I
       3C 00			
 FCBE  06 06 06 06 66 66		DB	006H, 006H, 006H, 006H, 066H, 066H, 03CH, 000H	; 4AH J
       3C 00			
 FCC6  63 66 6C 78 6C 66		DB	063H, 066H, 06CH, 078H, 06CH, 066H, 063H, 000H	; 4BH K
       63 00			
 FCCE  30 30 30 30 30 30		DB	030H, 030H, 030H, 030H, 030H, 030H, 03FH, 000H	; 4CH L
       3F 00			
 FCD6  63 77 7F 6B 63 63		DB	063H, 077H, 07FH, 06BH, 063H, 063H, 063H, 000H	; 4DH M
       63 00			
 FCDE  63 73 7B 6F 67 63		DB	063H, 073H, 07BH, 06FH, 067H, 063H, 063H, 000H	; 4EH N
       63 00			
 FCE6  3E 63 63 63 63 63		DB	03EH, 063H, 063H, 063H, 063H, 063H, 03EH, 000H	; 4FH O
       3E 00			
 FCEE  7E 63 63 7E 60 60		DB	07EH, 063H, 063H, 07EH, 060H, 060H, 060H, 000H	; 50H P
       60 00			
 FCF6  3E 63 63 63 7B 6E		DB	03EH, 063H, 063H, 063H, 07BH, 06EH, 03CH, 007H	; 51H Q
       3C 07			
 FCFE  7E 63 63 7E 6C 66		DB	07EH, 063H, 063H, 07EH, 06CH, 066H, 063H, 000H	; 52H R
       63 00			
 FD06  3E 63 30 1C 06 63		DB	03EH, 063H, 030H, 01CH, 006H, 063H, 03EH, 000H	; 53H S
       3E 00			
 FD0E  7E 18 18 18 18 18		DB	07EH, 018H, 018H, 018H, 018H, 018H, 018H, 000H	; 54H T
       18 00			
 FD16  63 63 63 63 63 63		DB	063H, 063H, 063H, 063H, 063H, 063H, 03EH, 000H	; 55H U
       3E 00			
 FD1E  63 63 63 63 36 1C		DB	063H, 063H, 063H, 063H, 036H, 01CH, 008H, 000H	; 56H V
       08 00			
 FD26  63 63 63 6B 6B 7F		DB	063H, 063H, 063H, 06BH, 06BH, 07FH, 036H, 000H	; 57H W
       36 00			
 FD2E  63 63 36 1C 36 63		DB	063H, 063H, 036H, 01CH, 036H, 063H, 063H, 000H	; 58H X
       63 00			
 FD36  63 63 63 3E 0C 0C		DB	063H, 063H, 063H, 03EH, 00CH, 00CH, 00CH, 000H	; 59H Y
       0C 00			
 FD3E  7F 06 0C 18 30 60		DB	07FH, 006H, 00CH, 018H, 030H, 060H, 07FH, 000H	; 5AH Z
       7F 00			
 FD46  3E 30 30 30 30 30		DB	03EH, 030H, 030H, 030H, 030H, 030H, 03EH, 000H	; 5BH [
       3E 00			
 FD4E  40 60 30 18 0C 06		DB	040H, 060H, 030H, 018H, 00CH, 006H, 002H, 000H	; 5CH \
       02 00			
 FD56  3E 06 06 06 06 06		DB	03EH, 006H, 006H, 006H, 006H, 006H, 03EH, 000H	; 5DH ]
       3E 00			
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-198


 FD5E  1C 36 63 00 00 00		DB	01CH, 036H, 063H, 000H, 000H, 000H, 000H, 000H	; 5EH ^
       00 00			
 FD66  00 00 00 00 00 00		DB	000H, 000H, 000H, 000H, 000H, 000H, 000H, 0FFH	; 5FH _
       00 FF			
 FD6E  30 18 0C 00 00 00		DB	030H, 018H, 00CH, 000H, 000H, 000H, 000H, 000H	; 60H `
       00 00			
 FD76  00 00 3C 06 3E 66		DB	000H, 000H, 03CH, 006H, 03EH, 066H, 03FH, 000H	; 61H a
       3F 00			
 FD7E  60 60 7C 66 66 66		DB	060H, 060H, 07CH, 066H, 066H, 066H, 07CH, 000H	; 62H b
       7C 00			
 FD86  00 00 3E 63 60 60		DB	000H, 000H, 03EH, 063H, 060H, 060H, 03FH, 000H	; 63H c
       3F 00			
 FD8E  06 06 3E 66 66 66		DB	006H, 006H, 03EH, 066H, 066H, 066H, 03EH, 000H	; 64H d
       3E 00			
 FD96  00 00 3C 66 7C 60		DB	000H, 000H, 03CH, 066H, 07CH, 060H, 03EH, 000H	; 65H e
       3E 00			
 FD9E  1E 30 30 7C 30 30		DB	01EH, 030H, 030H, 07CH, 030H, 030H, 030H, 000H	; 66H f
       30 00			
 FDA6  00 00 3F 63 63 3F		DB	000H, 000H, 03FH, 063H, 063H, 03FH, 003H, 07EH	; 67H g
       03 7E			
 FDAE  60 60 6C 76 66 66		DB	060H, 060H, 06CH, 076H, 066H, 066H, 066H, 000H	; 68H h
       66 00			
 FDB6  18 00 38 18 18 18		DB	018H, 000H, 038H, 018H, 018H, 018H, 018H, 000H	; 69H i
       18 00			
 FDBE  06 00 06 06 06 06		DB	006H, 000H, 006H, 006H, 006H, 006H, 066H, 03CH	; 6AH j
       66 3C			
 FDC6  60 60 66 6C 78 6C		DB	060H, 060H, 066H, 06CH, 078H, 06CH, 066H, 000H	; 6BH k
       66 00			
 FDCE  18 18 18 18 18 18		DB	018H, 018H, 018H, 018H, 018H, 018H, 00CH, 000H	; 6CH l
       0C 00			
 FDD6  00 00 76 7F 6B 6B		DB	000H, 000H, 076H, 07FH, 06BH, 06BH, 063H, 000H	; 6DH m
       63 00			
 FDDE  00 00 6C 76 66 66		DB	000H, 000H, 06CH, 076H, 066H, 066H, 066H, 000H	; 6EH n
       66 00			
 FDE6  00 00 3E 63 63 63		DB	000H, 000H, 03EH, 063H, 063H, 063H, 03EH, 000H	; 6FH o
       3E 00			
 FDEE  00 00 7C 66 66 7C		DB	000H, 000H, 07CH, 066H, 066H, 07CH, 060H, 060H	; 70H p
       60 60			
 FDF6  00 00 3E 66 66 3E		DB	000H, 000H, 03EH, 066H, 066H, 03EH, 006H, 006H	; 71H q
       06 06			
 FDFE  00 00 36 3B 30 30		DB	000H, 000H, 036H, 03BH, 030H, 030H, 030H, 000H	; 72H r
       30 00			
 FE06  00 00 3E 70 3C 0E		DB	000H, 000H, 03EH, 070H, 03CH, 00EH, 07CH, 000H	; 73H s
       7C 00			
 FE0E  18 18 7E 18 18 18		DB	018H, 018H, 07EH, 018H, 018H, 018H, 00EH, 000H	; 74H t
       0E 00			
 FE16  00 00 66 66 66 66		DB	000H, 000H, 066H, 066H, 066H, 066H, 03BH, 000H	; 75H u
       3B 00			
 FE1E  00 00 66 66 66 3C		DB	000H, 000H, 066H, 066H, 066H, 03CH, 018H, 000H	; 76H v
       18 00			
 FE26  00 00 63 63 6B 7F		DB	000H, 000H, 063H, 063H, 06BH, 07FH, 036H, 000H	; 77H w
       36 00			
 FE2E  00 00 63 36 1C 36		DB	000H, 000H, 063H, 036H, 01CH, 036H, 063H, 000H	; 78H x
       63 00			
 FE36  00 00 66 66 66 3E		DB	000H, 000H, 066H, 066H, 066H, 03EH, 006H, 07CH	; 79H y
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-199


       06 7C			
 FE3E  00 00 7E 0C 18 30		DB	000H, 000H, 07EH, 00CH, 018H, 030H, 07EH, 000H	; 7AH z
       7E 00			
 FE46  0E 18 18 78 18 18		DB	00EH, 018H, 018H, 078H, 018H, 018H, 00EH, 000H	; 7BH {
       0E 00			
 FE4E  18 18 18 00 18 18		DB	018H, 018H, 018H, 000H, 018H, 018H, 018H, 000H	; 7CH |
       18 00			
 FE56  70 18 18 0E 18 18		DB	070H, 018H, 018H, 00EH, 018H, 018H, 070H, 000H	; 7DH }
       70 00			
 FE5E  3B 6E 00 00 00 00		DB	03BH, 06EH, 000H, 000H, 000H, 000H, 000H, 000H	; 7EH ~
       00 00			
 FE66  18 3C 66 C3 C3 FF		DB	018H, 03CH, 066H, 0C3H, 0C3H, 0FFH, 000H, 000H	; 7FH
       00 00			
							ENDIF
				
				;----------------------------------------------------------------------------;
				; INT 1A - System and "Real Time" Clock BIOS Services
				;----------------------------------------------------------------------------;
				; INT 1A,0   Read system clock counter
				; INT 1A,1   Set system clock counter
				;----------------------------------------------------------------------------;
 FE6E						ORG 0FE6EH
 FE6E				INT_1A PROC
						ASSUME DS:_BDA
 FE6E  FB				STI						; enable interrupts
 FE6F  80 EC 01				SUB	AH, 1 				; is function 0 or 1?
 FE72  77 18				JA	INT_1A_EXIT 			; if not, exit
 FE74  1E				PUSH	DS
 FE75  56				PUSH	SI
 FE76  BE ---- R			MOV	SI, SEG _BDA 			; get BDA segment
 FE79  8E DE				MOV	DS, SI 				; DS = BDA
 FE7B  BE 006C R			MOV	SI, OFFSET TIMER			; SI = BIOS Timer
 FE7E  FA				CLI 						; disable interrupts
 FE7F  74 0C				JZ	INT_1A_SET 				; AH = 1, jump to Set clock
											; AH = 0, fall through to Read
				
				;----------------------------------------------------------------------------;
				; INT 1A,0   Read system clock counter
				;----------------------------------------------------------------------------;
				; Output:
				;	AL = midnight flag, 1 if 24 hours passed since reset
				;	CX = high order word of tick count
				;	DX = low order word of tick count
				;----------------------------------------------------------------------------;
 FE81				INT_1A_READ PROC
 FE81  FC				CLD						; string direction forward
 FE82  AD				LODSW 					; AX = low word of timer
 FE83  92				XCHG	AX, DX
 FE84  AD				LODSW 					; AX = high word of timer
 FE85  91				XCHG	AX, CX
 FE86  33 C0				XOR	AX, AX				; reset midnight flag to 0
 FE88  86 04				XCHG	AL, [SI]				; AL = BDA flag, BDA = 0
 FE8A				INT_1A_DONE:
					;STI 						; re-enable interrupts
 FE8A  5E				POP	SI
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-200


 FE8B  1F				POP	DS
 FE8C				INT_1A_EXIT:
 FE8C  CF				IRET
 FE8D				INT_1A_READ ENDP
				
				;----------------------------------------------------------------------------;
				; INT 1A,1   Set system clock counter
				;----------------------------------------------------------------------------;
				; Input:
				;	AH = 0
				;	CX = high order word of tick count
				;	DX = low order word of tick count
				;----------------------------------------------------------------------------;
 FE8D				INT_1A_SET PROC
 FE8D  89 14				MOV	[SI].LW, DX				; set low word ticks (seconds)
 FE8F  89 4C 02				MOV	[SI].HW, CX				; set high word ticks (hours)
 FE92  88 64 04				MOV	[SI].OF, AH				; reset midnight counter (0)
 FE95  EB F3				JMP	SHORT INT_1A_DONE
 FE97				INT_1A_SET ENDP
				
 FE97				INT_1A ENDP
				
 FE97				INT_08_PROC PROC
				;----------------------------------------------------------------------------;
				; INT 8 - Floppy Motor shutoff has elapsed - shut off motor
				;----------------------------------------------------------------------------;
 FE97				INT_08_MOTOR_OFF:
 FE97  B0 F0				MOV	AL, NOT MASK FMOT			; BDA motor off on all drives
 FE99  20 06 003F R			AND	FD_MOTOR_ST, AL			; write to BDA
 FE9D  34 FC				XOR	AL, NOT MASK FDSEL		; FDC motor off on all drives
 FE9F  BA 03F2				MOV	DX, FDC_CTRL 			; FD control port
 FEA2  EE				OUT	DX, AL 				; write to controller
 FEA3  EB 20				JMP	SHORT INT_08_INT_1C
				
				;
				; 0 BYTES HERE
				;
				BYTES_HERE	INT_08
 = 0000                      1	BYTES_HERE_INT_08 = INT_08-$ 
			     1			IFDEF BYTES_HERE_INT_08 
			     1			IF2 
			     1			ENDIF 
			     1			ENDIF 
				
				;----------------------------------------------------------------------------;
				; INT 8 - Timer
				;----------------------------------------------------------------------------;
				; - Run 18.2 times per second by PIT Timer
				; - f = 1193182 / 10000H
				; - Increment 32 bit counter, overflows at 24 hours + 9.67 sec
				;	( 3600s/h - 65,536t / ( 1,193,182t/s / 65,536t ) ) * 24h = ~9.67s
				; - Decrement floppy disk motor timeout counter
				;  	  if reaches 0, turns off motor
				; - only take jumps on special cases
				;
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-201


				; IMPORTANT NOTE: ROM BASIC's INT 1CH handler clobbers DX, so DX
				; MUST be call-preserved here.
				;----------------------------------------------------------------------------;
 FEA5						ORG 0FEA5H
 FEA5				INT_08 PROC
						ASSUME DS:_BDA
 FEA5  50				PUSH	AX 					; save AX, DX, DS and DI
 FEA6  52				PUSH	DX					; workaround ROM BASIC INT 1Ch bug
 FEA7  1E				PUSH	DS
 FEA8  57				PUSH	DI
 FEA9  B8 ---- R			MOV	AX, SEG _BDA 			; DS = BIOS Data Area
 FEAC  8E D8				MOV	DS, AX
 FEAE  99				CWD						; DX = 0
				
				;----------------------------------------------------------------------------;
				; Increment Timer
				;
 FEAF				INT_08_TICK_TIMER:				; Advance the time ticker
 FEAF  BF 006C R			MOV	DI, OFFSET TIMER 			; Low timer at BDA 0040:006C
 FEB2  83 05 01				ADD	[DI].LW, 1				; increment low word
 FEB5  11 55 02				ADC	[DI].HW, DX				; carry into high word
 FEB8  83 7D 02 18			CMP	[DI].HW, 24 			; rolled over to next day?
 FEBC  73 13				JAE	INT_08_TICK_DAY			; if so, check for day rollover
				
				;----------------------------------------------------------------------------;
				; Decrement Floppy Motor shutoff counter
				;
 FEBE				INT_08_FD_MOTOR: 					; Check if there is a motor timeout
 FEBE  FB				STI						; interrupts back on
 FEBF  FE 0E 0040 R			DEC	FD_MOTOR_CT 			; increment counter, has reached 0?
 FEC3  74 D2				JZ	INT_08_MOTOR_OFF			; if so, turn off motor
				
				;----------------------------------------------------------------------------;
				; Call INT 1CH user vector
				;
 FEC5				INT_08_INT_1C:
 FEC5  CD 1C				INT	1CH					; call user timer hook
				
				;----------------------------------------------------------------------------;
				; Interrupt Complete - send EOI and return
				;
 FEC7				INT_08_EOI:
 FEC7  FA				CLI						; disable interrupts for EOI
 FEC8  B0 20				MOV	AL, EOI 				; End of Interrupt OCW
 FECA  E6 20				OUT	INT_P0, AL				; write EOI to port 0
 FECC  5F				POP	DI
 FECD  1F				POP	DS
 FECE  5A				POP	DX					; restore DX
 FECF  58				POP	AX
 FED0  CF				IRET
				
				;----------------------------------------------------------------------------;
				; Check if day has rolled over (24H + 9.67s) and reset 32 bit ticker if so
				;
 FED1				INT_08_TICK_DAY:
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-202


 FED1  80 3D B0				CMP	BYTE PTR [DI].LW, 176 		; has day rolled over?
 FED4  72 E8				JB	INT_08_FD_MOTOR			; if not, handle FD motor timeout
				
				;----------------------------------------------------------------------------;
				; Timer has rolled over 24 hours - reset counters and increment midnight
				; http://www.ctyme.com/intr/rb-2271.htm
				; http://www.phatcode.net/res/246/files/pctim003.txt
				;
 FED6				INT_08_RESET:
 FED6  89 15				MOV	[DI].LW, DX				; TIMER low word = 0
 FED8  89 55 02				MOV	[DI].HW, DX				; TIMER high word = 0
 FEDB  FE 45 04				INC	[DI].OF				; increment TIMER midnight counter
 FEDE  EB DE				JMP	INT_08_FD_MOTOR			; continue and check motor
				
 FEE0				INT_08 ENDP
 FEE0				INT_08_PROC ENDP
				
				;
				; 3 BYTES HERE
				;
				BYTES_HERE	VECTOR_TABLE
 = 0003                      1	BYTES_HERE_VECTOR_TABLE = VECTOR_TABLE-$ 
			     1			IFDEF BYTES_HERE_VECTOR_TABLE 
			     1			IF2 
			     1			ENDIF 
			     1			ENDIF 
				
				;----------------------------------------------------------------------------;
				; Interrupt Vector Table - These fill the IVT prior to bootstrap
				;----------------------------------------------------------------------------;
				; Each ISR is found at the compatibility offset described here:
				; https://www.intel.com/content/dam/doc/reference-guide/efi-compatibility-support-module-specificati
				on-v097.pdf
				;----------------------------------------------------------------------------;
 FEE3						ORG 0FEE3H
 FEE3				VECTOR_TABLE PROC
 FEE3  FF23 R				DW  OFFSET INT_IRQ 		; INT 00
 FEE5  FF23 R				DW  OFFSET INT_IRQ 		; INT 01
 FEE7  E2C3 R				DW  OFFSET INT_02 		; INT 02	NMI
 FEE9  FF23 R				DW  OFFSET INT_IRQ 		; INT 03
 FEEB  FF23 R				DW  OFFSET INT_IRQ 		; INT 04
 FEED  FF54 R				DW  OFFSET INT_05 		; INT 05	Print Screen
 FEEF  FF23 R				DW  OFFSET INT_IRQ 		; INT 06
 FEF1  FF23 R				DW  OFFSET INT_IRQ 		; INT 07
				
				;----------------------------------------------------------------------------;
				; Compatibility fixed ORG for INT 08 - 1Eh
				;
 FEF3						ORG 0FEF3H
 FEF3  FEA5 R				DW  OFFSET INT_08 		; INT 08	IRQ0 System timer
 FEF5  E944 R				DW  OFFSET INT_09_POST		; INT 09	IRQ1 Keyboard IRQ (during POST)
 FEF7  FF23 R				DW  OFFSET INT_IRQ		; INT 0A	IRQ2 Reserved
 FEF9  FF23 R				DW  OFFSET INT_IRQ		; INT 0B	IRQ3 COM2
 FEFB  FF23 R				DW  OFFSET INT_IRQ		; INT 0C	IRQ4 COM1
 FEFD  FF23 R				DW  OFFSET INT_IRQ		; INT 0D	IRQ5 XT FDC
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-203


 FEFF  EF57 R				DW  OFFSET INT_0E			; INT 0E	IRQ6 Floppy Controller
 FF01  FF23 R				DW  OFFSET INT_IRQ		; INT 0F	IRQ7 LPT
 FF03  F065 R				DW  OFFSET INT_10			; INT 10	Video
 FF05  F84D R				DW  OFFSET INT_11			; INT 11	Equipment Check
 FF07  F841 R				DW  OFFSET INT_12			; INT 12	Memory Size
 FF09  EC59 R				DW  OFFSET INT_13			; INT 13	Floppy Disk
 FF0B  E739 R				DW  OFFSET INT_14			; INT 14	Serial Port
 FF0D  F859 R				DW  OFFSET INT_15			; INT 15	System Services
 FF0F  E82E R				DW  OFFSET INT_16			; INT 16	Keyboard Services
 FF11  EFD2 R				DW  OFFSET INT_17			; INT 17	Printer
 FF13  E478 R				DW  OFFSET INT_18 		; INT 18	Unbootable/ROM BASIC
 FF15  E6F2 R				DW  OFFSET INT_19			; INT 19	Bootstrap
 FF17  FE6E R				DW  OFFSET INT_1A			; INT 1A	Time of day
 FF19  FF53 R				DW  OFFSET INT_RET 		; INT 1B	Ctrl Brk
 FF1B  FF53 R				DW  OFFSET INT_RET 		; INT 1C	Timer Tick
 FF1D  F0A4 R				DW  OFFSET INT_1D 		; INT 1D	CRTC param table
 FF1F  EFC7 R				DW  OFFSET INT_1E 		; INT 1E	Floppy param table
 = 001F				L_VECTOR_TABLE = ($-VECTOR_TABLE)/2	; number of vectors 1Fh (31)
 FF21  0000				DW  0 				; INT 1F	8x8 (CP 128-255) custom
										;		 video font table (0000:0000)
 FF23				VECTOR_TABLE ENDP
				
				;----------------------------------------------------------------------------;
				; INT_IRQ - Handle placeholder hardware interrupts
				;----------------------------------------------------------------------------;
				; ISR for any hardware interrupts that have yet to be vectored.
				; Acknowledge interrupt, mask the active one and write last HW interrupt to BDA.
				;
				; Output:
				;	INT_LAST = last interrupt or 0FFh if non-hardware/unknown interrupt
				;----------------------------------------------------------------------------;
 FF23						ORG 0FF23H
 FF23				INT_IRQ PROC
							ASSUME DS:_BDA_ABS
 FF23  50				PUSH	AX
 FF24  1E				PUSH	DS				; save DS
 FF25  B0 0B				MOV	AL, OCW3 <,,,,11b> 	; AL = OCW3 Read ISR reg on next pulse
 FF27  E6 20				OUT	INT_P0, AL			; write to PIC A0 (20h)
 FF29  33 C0				XOR	AX, AX			; AH = 0, delay for PIC at least 1 clock pulse
 FF2B  8E D8				MOV	DS, AX			; set DS to BDA_ABS (segment 0000h)
 FF2D  E4 20				IN	AL, INT_P0			; get current In-Service Register (ISR)
 FF2F  48				DEC	AX				; if ISR is zero there is no active hardware int
 FF30  7C 0D				JL	INT_IRQ_DONE		; if no active int, exit with INT_LAST = FFh
 FF32  40				INC	AX				; otherwise INT_LAST = active interrupt level
 FF33  8A E0				MOV	AH, AL 			; restore ISR and save to AH
 FF35  E4 21				IN	AL, INT_IMR			; get current Interrupt Mask Register (IMR)
 FF37  0A C4				OR	AL, AH 			; mask active interrupt
 FF39  E6 21				OUT	INT_IMR, AL			; write new IMR to PIC A1 (21h)
 FF3B  B0 20				MOV	AL, EOI 			; AL = OCW2 End of Interrupt
 FF3D  E6 20				OUT	INT_P0, AL			; write EOI to PIC A0 (20h)
 FF3F				INT_IRQ_DONE:
 FF3F  88 26 046B R			MOV	INT_LAST_ABS, AH	 	; save last interrupt to BDA
 FF43  1F				POP	DS
 FF44  58				POP	AX
 FF45  CF				IRET
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-204


							ASSUME DS:NOTHING
 FF46				INT_IRQ ENDP
				
				;----------------------------------------------------------------------------;
				; POST Video Adapter Type Strings (2 of 2)
				; 11 bytes
				;
								IF POST_VIDEO_TYPE EQ 1
 FF46  56 69 64 65 6F 00	POST_VIDEO		DB	'Video', 0
								ENDIF
 FF4C  4E 6F 6E 65 00		POST_NONE		DB	'None', 0	; must be contiguous to POST_VIDEO
				
				;
				; 2 BYTES HERE
				;
				BYTES_HERE	INT_RET
 = 0002                      1	BYTES_HERE_INT_RET = INT_RET-$ 
			     1			IFDEF BYTES_HERE_INT_RET 
			     1			IF2 
			     1			ENDIF 
			     1			ENDIF 
				
				;----------------------------------------------------------------------------;
				; INT_RET - Handle placeholder software interrupts
				;----------------------------------------------------------------------------;
 FF53						ORG 0FF53H
 FF53				INT_RET PROC
 FF53  CF				IRET
 FF54				INT_RET ENDP
				
				;----------------------------------------------------------------------------;
				; INT 5 - Print Screen
				;----------------------------------------------------------------------------;
				; Print the contents of the current screen/page.
				;
				; Output:
				; - Screen contents to PRN (BIOS printer 0)
				; - Status to BDA 50:0H:
				;	00	Print screen has not been called, or upon return
				;			from a call there were no errors
				;	01	Print screen is already in progress
				;	FF	Error encountered during printing
				;----------------------------------------------------------------------------;
				; Things you must do:
				; 	1. Check status (BDA 50:0H) to ensure PrtScn is not already in progress.
				;	2. Set working status to 1.
				;	3. Get the current screen size (columns) and video page.
				;	4. Save the current cursor position, then move to the top.
				;	5. Read the char at that position and send to printer.
				;	6. If last column reached, move screen cursor to start of next line
				;		and send CR and LF to printer to start new line.
				;	7. Keep looping until past the last row (always 25)
				;	8. Restore screen cursor position
				;	9. Set BDA status to either success (0) or error (-1)
				;----------------------------------------------------------------------------;
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-205


 FF54						ORG 0FF54H
 FF54				INT_05 PROC
							ASSUME DS:_BDA
 FF54  FC				CLD						; string direction forward
					PUSHX	AX, DI, ES				; preserve caller registers
			     1				IFNB <AX>			; exit if last reg 
 FF55  50                    1		PUSH	AX 					; push register and repeat 
			     1		PUSHX	DI, ES, , , , ,  
			     2				IFNB <DI>			; exit if last reg 
 FF56  57                    2		PUSH	DI 					; push register and repeat 
			     2		PUSHX	ES, , , , , ,  
			     3				IFNB <ES>			; exit if last reg 
 FF57  06                    3		PUSH	ES 					; push register and repeat 
			     3		PUSHX	, , , , , ,  
			     3				ENDIF 
			     2				ENDIF 
			     1				ENDIF 
 FF58  BF ---- R			MOV	DI, SEG _DOS_DAT
 FF5B  8E C7				MOV	ES, DI				; ES = seg 50H
 FF5D  33 FF				XOR	DI, DI				; DI = PTRSCN_ST (offset 00H)
 FF5F  B0 01				MOV	AL, 1					; print status = 1 (in progress)
 FF61  AE				SCASB						; is in progress already?
 FF62  74 42				JZ	INT_05_EXIT				; if so, exit
 FF64  FB				STI						; Interrupts should be okay now
 FF65  4F				DEC	DI					; undo earlier SCASB increment
 FF66  AA				STOSB						; update status to 1
					PUSHX	BX, CX, DX				; preserve working registers
			     1				IFNB <BX>			; exit if last reg 
 FF67  53                    1		PUSH	BX 					; push register and repeat 
			     1		PUSHX	CX, DX, , , , ,  
			     2				IFNB <CX>			; exit if last reg 
 FF68  51                    2		PUSH	CX 					; push register and repeat 
			     2		PUSHX	DX, , , , , ,  
			     3				IFNB <DX>			; exit if last reg 
 FF69  52                    3		PUSH	DX 					; push register and repeat 
			     3		PUSHX	, , , , , ,  
			     3				ENDIF 
			     2				ENDIF 
			     1				ENDIF 
 FF6A  B4 0F				MOV	AH, 0FH				; get video state (columns)
 FF6C  CD 10				INT	10H					; AH = screen columns, BH = page
 FF6E  8A DC				MOV	BL, AH				; BL = screen columns
 FF70  4B				DEC	BX					; fix 0 index
 FF71  B4 03				MOV	AH, 3					; get cursor position
 FF73  CD 10				INT	10H					; DH = cursor row, DL = cursor column
 FF75  52				PUSH	DX					; save starting cursor position
 FF76  E8 FFAA R			CALL	LPT_CRLF				; start print head on new line
 FF79  72 1F				JC	INT_05_DONE				; exit if print error
 FF7B  99				CWD						; start position at row 0, col 0
 FF7C				INT_05_LOOP_1:
 FF7C  B4 02				MOV	AH, 2					; set cursor position
 FF7E  CD 10				INT	10H					; set cursor to DH=row, DL=col
 FF80  B4 08				MOV	AH, 8					; get char/attr at current position
 FF82  CD 10				INT	10H					; AL = char at current position
 FF84  E8 FFB3 R			CALL	LPT_CHAR				; print char in AL
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-206


 FF87  72 11				JC	INT_05_DONE				; exit if print error
 FF89  3A DA				CMP	BL, DL				; end of screen cols?
 FF8B  75 07				JNE	INT_05_NEXT_COL			; jump if not
 FF8D  B2 FF				MOV	DL, -1				; else move to first col and next row
 FF8F  E8 FFAA R			CALL	LPT_CRLF				; CR and LF to PRN
 FF92  72 06				JC	INT_05_DONE				; exit if print error
 FF94				INT_05_NEXT_COL:
 FF94  42				INC	DX					; move to next column (and maybe row)
 FF95  80 FE 19				CMP	DH, VID_DEF_ROWS+1		; end of screen rows?
 FF98  75 E2				JNE	INT_05_LOOP_1			; loop while not last row, CF=0 when done
 FF9A				INT_05_DONE:
 FF9A  1A C0				SBB	AL, AL				; print status: AL = 0 if NC, AL = -1 if CF
 FF9C  4F				DEC	DI					; undo earlier STOSB increment
 FF9D  AA				STOSB						; update BDA status
 FF9E  5A				POP	DX					; restore starting cursor position
 FF9F  B4 02				MOV	AH, 2					; set cursor position in DH/DL
 FFA1  CD 10				INT	10H
					POPX	DX, CX, BX
			     1				IFNB <DX>			; exit if last reg 
 FFA3  5A                    1		POP	DX 					; pop register and repeat 
			     1		POPX	CX, BX, , , , ,  
			     2				IFNB <CX>			; exit if last reg 
 FFA4  59                    2		POP	CX 					; pop register and repeat 
			     2		POPX	BX, , , , , ,  
			     3				IFNB <BX>			; exit if last reg 
 FFA5  5B                    3		POP	BX 					; pop register and repeat 
			     3		POPX	, , , , , ,  
			     3				ENDIF 
			     2				ENDIF 
			     1				ENDIF 
 FFA6				INT_05_EXIT:
					POPX	ES, DI, AX
			     1				IFNB <ES>			; exit if last reg 
 FFA6  07                    1		POP	ES 					; pop register and repeat 
			     1		POPX	DI, AX, , , , ,  
			     2				IFNB <DI>			; exit if last reg 
 FFA7  5F                    2		POP	DI 					; pop register and repeat 
			     2		POPX	AX, , , , , ,  
			     3				IFNB <AX>			; exit if last reg 
 FFA8  58                    3		POP	AX 					; pop register and repeat 
			     3		POPX	, , , , , ,  
			     3				ENDIF 
			     2				ENDIF 
			     1				ENDIF 
 FFA9  CF				IRET
				
				;----------------------------------------------------------------------------;
				; LPT_CRLF - Write CR and LF to PRN
				;----------------------------------------------------------------------------;
 FFAA				LPT_CRLF PROC
 FFAA  B0 0D				MOV	AL, CR
 FFAC  E8 FFB3 R			CALL	LPT_CHAR
 FFAF  72 11				JC	LPT_CHAR_EXIT			; exit if print error
				
				;----------------------------------------------------------------------------;
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-207


				; LPT_LF - Write LF to PRN
				;----------------------------------------------------------------------------;
 FFB1				LPT_LF PROC
 FFB1  B0 0A				MOV	AL, LF
				
				;----------------------------------------------------------------------------;
				; LPT_CHAR - Write a char to PRN
				;----------------------------------------------------------------------------;
				; Input:
				;	AL = char to print
				; Output:
				;	CF = 1 (CY) if timeout
				;
				; AL clobbered if null
				;----------------------------------------------------------------------------;
 FFB3				LPT_CHAR PROC
 FFB3  52				PUSH	DX
 FFB4  B4 00				MOV	AH, 0					; Print Character function
 FFB6  99				CWD						; DX = printer 0 (PRN)
 FFB7  84 C0				TEST	AL, AL				; was input char a null?
 FFB9  75 02				JNZ	LPT_CHAR_OUT			; jump if not
 FFBB  B0 20				MOV	AL, ' '				; if so, use a space
 FFBD				LPT_CHAR_OUT:
 FFBD  CD 17				INT	17H					; Print AL to PRN0
 FFBF  D0 EC				SHR	AH, 1					; CF if timeout
 FFC1  5A				POP	DX
 FFC2				LPT_CHAR_EXIT:
 FFC2  C3				RET
 FFC3				LPT_CHAR ENDP
 FFC3				LPT_LF ENDP
 FFC3				LPT_CRLF ENDP
				
 FFC3				INT_05 ENDP
				
				;----------------------------------------------------------------------------;
				; Check if a 8087 FPU is present and perform quick tests
				;----------------------------------------------------------------------------;
				; Input:
				;	DI = any non-zero value
				; Output:
				;	ZF = 0 if no FPU, ZF = 1 if present
				;
				; Clobbers: BX, DI
				;
				; Sources:
				;   https://retrocomputing.stackexchange.com/questions/16529/detecting-the-external-x87-fpu
				;   Intel(R) App Note AP-485 "Intel(R) Processor Identification and the CPUID Instruction"
				;----------------------------------------------------------------------------;
 FFC3				HAS_FPU PROC
 FFC3  97				XCHG	AX, DI			; save AX
 FFC4  DB E3				FNINIT 				; reset FPU, no wait
				
				;----------------------------------------------------------------------------;
				; Test Status Word
				;
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-208


 FFC6				FPU_TEST_SW:
 FFC6  50				PUSH	AX 				; init temp word to non-zero
 FFC7  8B DC				MOV	BX, SP	 		; use stack memory
 FFC9  36: DD 3F			FNSTSW WORD PTR SS:[BX]		; store status word
 FFCC  90				NOP					; delay to allow FPU to complete
 FFCD  58				POP	AX 				; AX = control word if FNSTCW executed
 FFCE  84 C0				TEST	AL, AL 			; check exception flags
 FFD0  75 0C				JNZ	FPU_TEST_DONE		; if flags = 00, FPU is present
				
				;----------------------------------------------------------------------------;
				; Test Control Word
				;
 FFD2				FPU_TEST_CW:
 FFD2  50				PUSH	AX
 FFD3  36: D9 3F			FNSTCW WORD PTR SS:[BX]		; store control word
 FFD6  90				NOP					; delay to allow FPU to complete
 FFD7  58				POP	AX 				; AX = control word
 FFD8  35 103F				XOR	AX, 0103FH 			; isolate interesting status flags
 FFDB  25 003F				AND	AX, 03FH 			; check for 8087 "signature"
										; ZF = 0 if no FPU
 FFDE				FPU_TEST_DONE:
 FFDE  97				XCHG	AX, DI			; restore AX
 FFDF  C3				RET
 FFE0				HAS_FPU ENDP
				
				;
				; 0 BYTES HERE
				;
				BYTES_HERE	VER
 = 0000                      1	BYTES_HERE_VER = VER-$ 
			     1			IFDEF BYTES_HERE_VER 
			     1			IF2 
			     1			ENDIF 
			     1			ENDIF 
				
				;----------------------------------------------------------------------------;
				; Version and Build Strings
				;----------------------------------------------------------------------------;
 FFE0						ORG	0FFE0H
 FFE0  56 65 72 3A 20		VER 	DB	'Ver: '
 FFE5  30 2E 32 2E 36			DB	VER_NUM
 FFEA  2D				DB	'-'				; Show CPU type and
 FFEB  38				DB	CPU_TYPE			; architecture target
 FFEC  54				DB	ARCH_TYPE
							IF ARCH_SUB_TYPE NE 0
 FFED  41				DB	ARCH_SUB_TYPE		; add optional ARCH sub-identifier
							ENDIF
 FFEE  20				DB	' '				; space before date
 FFEF  00				DB	0
				
				;
				; 0 BYTES HERE
				;
				BYTES_HERE	POWER_ON
 = 0000                      1	BYTES_HERE_POWER_ON = POWER_ON-$ 
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Page     1-209


			     1			IFDEF BYTES_HERE_POWER_ON 
			     1			IF2 
			     1			ENDIF 
			     1			ENDIF 
				
 FFF0				BIOS		ENDS
GLABIOS.ASM(12524): warning A4102: Segment near (or at) 64K limit
				
				;============================================================================;
				;
				;				* * *    END OF BIOS   * * *
				;
				;============================================================================;
				
				END

Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Symbols-1


Macros:

		N a m e			Lines

AAD_I  . . . . . . . . . . . . .  	   1
AAM_I  . . . . . . . . . . . . .  	   1
BEEP_OFF . . . . . . . . . . . .  	   1
BEEP_ON  . . . . . . . . . . . .  	   6
BEXT . . . . . . . . . . . . . .  	   2
BINS . . . . . . . . . . . . . .  	   2
BYTES_HERE . . . . . . . . . . .  	   9
CALL_NS  . . . . . . . . . . . .  	   9
CGA_WAIT_SYNC  . . . . . . . . .  	  26
CLR1 . . . . . . . . . . . . . .  	   1
CMP_EFLAG  . . . . . . . . . . .  	  25
GET_EFLAG  . . . . . . . . . . .  	  64
IO_DELAY . . . . . . . . . . . .  	   2
IO_DELAY_LONG  . . . . . . . . .  	   4
IO_DELAY_SHORT . . . . . . . . .  	   4
IO_DELAY_TURBO . . . . . . . . .  	   5
IRET_F . . . . . . . . . . . . .  	   1
JMP_FIX  . . . . . . . . . . . .  	   7
JNWB . . . . . . . . . . . . . .  	   2
JWB  . . . . . . . . . . . . . .  	   4
NOT1 . . . . . . . . . . . . . .  	   1
POPX . . . . . . . . . . . . . .  	   4
POST_CODE  . . . . . . . . . . .  	   8
POST_COL_1 . . . . . . . . . . .  	  13
POST_COL_2 . . . . . . . . . . .  	  13
POST_COL_END . . . . . . . . . .  	   7
POST_COL_END_NL  . . . . . . . .  	   7
POST_FLAG_CLR  . . . . . . . . .  	  10
POST_FLAG_FLIP . . . . . . . . .  	   5
POST_FLAG_SET  . . . . . . . . .  	   5
POST_FLAG_TEST . . . . . . . . .  	   5
PRINTLN_SZ . . . . . . . . . . .  	  10
PRINT_SZ . . . . . . . . . . . .  	  10
PUSHX  . . . . . . . . . . . . .  	   4
ROL4 . . . . . . . . . . . . . .  	   1
ROR4 . . . . . . . . . . . . . .  	   1
SET1 . . . . . . . . . . . . . .  	   1
SET_EFLAG  . . . . . . . . . . .  	  41
SET_GFLAG  . . . . . . . . . . .  	   4
SET_SZ_ATTR  . . . . . . . . . .  	  18
TEST1  . . . . . . . . . . . . .  	   1
TEST_EFLAG . . . . . . . . . . .  	   5
TEST_GFLAG . . . . . . . . . . .  	   1
V20_OP1  . . . . . . . . . . . .  	   6
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Symbols-2


Structures and Records:

                N a m e                 Width   # fields
                                        Shift   Width   Mask    Initial

BEEP_SL  . . . . . . . . . . . .  	0008	0002
  BEEP_S . . . . . . . . . . . .  	0004	0004	00F0	0000
  BEEP_L . . . . . . . . . . . .  	0000	0004	000F	0000
COM_LCR  . . . . . . . . . . . .  	0008	0007
  DLAB . . . . . . . . . . . . .  	0007	0001	0080	0000
  LCBK . . . . . . . . . . . . .  	0006	0001	0040	0000
  LCPD . . . . . . . . . . . . .  	0005	0001	0020	0000
  LCEPS  . . . . . . . . . . . .  	0004	0001	0010	0000
  LCPEN  . . . . . . . . . . . .  	0003	0001	0008	0000
  LCSB . . . . . . . . . . . . .  	0002	0001	0004	0000
  LCWLS  . . . . . . . . . . . .  	0000	0002	0003	0000
COM_LSR  . . . . . . . . . . . .  	0008	0008
  LSX  . . . . . . . . . . . . .  	0007	0001	0080	0000
  TSRE . . . . . . . . . . . . .  	0006	0001	0040	0000
  THRE . . . . . . . . . . . . .  	0005	0001	0020	0000
  LBI  . . . . . . . . . . . . .  	0004	0001	0010	0000
  LFE  . . . . . . . . . . . . .  	0003	0001	0008	0000
  LPE  . . . . . . . . . . . . .  	0002	0001	0004	0000
  LOE  . . . . . . . . . . . . .  	0001	0001	0002	0000
  LDR  . . . . . . . . . . . . .  	0000	0001	0001	0000
COM_MCR  . . . . . . . . . . . .  	0008	0006
  MCRX . . . . . . . . . . . . .  	0005	0003	00E0	0000
  MCLB . . . . . . . . . . . . .  	0004	0001	0010	0000
  MCO2 . . . . . . . . . . . . .  	0003	0001	0008	0000
  MCO1 . . . . . . . . . . . . .  	0002	0001	0004	0000
  RTS  . . . . . . . . . . . . .  	0001	0001	0002	0000
  DTR  . . . . . . . . . . . . .  	0000	0001	0001	0000
COM_MSR  . . . . . . . . . . . .  	0008	0008
  MLSD . . . . . . . . . . . . .  	0007	0001	0080	0000
  MRI  . . . . . . . . . . . . .  	0006	0001	0040	0000
  MDSR . . . . . . . . . . . . .  	0005	0001	0020	0000
  MCTS . . . . . . . . . . . . .  	0004	0001	0010	0000
  DDCD . . . . . . . . . . . . .  	0003	0001	0008	0000
  DRI  . . . . . . . . . . . . .  	0002	0001	0004	0000
  DDSR . . . . . . . . . . . . .  	0001	0001	0002	0000
  DCTS . . . . . . . . . . . . .  	0000	0001	0001	0000
CRTC . . . . . . . . . . . . . .  	0010	0010
  H_TC . . . . . . . . . . . . .  	0000
  H_CL . . . . . . . . . . . . .  	0001
  H_SP . . . . . . . . . . . . .  	0002
  H_SW . . . . . . . . . . . . .  	0003
  V_TL . . . . . . . . . . . . .  	0004
  V_SL . . . . . . . . . . . . .  	0005
  V_DR . . . . . . . . . . . . .  	0006
  V_SP . . . . . . . . . . . . .  	0007
  IL . . . . . . . . . . . . . .  	0008
  MSL  . . . . . . . . . . . . .  	0009
  CSL  . . . . . . . . . . . . .  	000A
  CEL  . . . . . . . . . . . . .  	000B
  SA_H . . . . . . . . . . . . .  	000C
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Symbols-3


  SA_L . . . . . . . . . . . . .  	000D
  CA_H . . . . . . . . . . . . .  	000E
  CA_L . . . . . . . . . . . . .  	000F
DBT  . . . . . . . . . . . . . .  	000B	000B
  SRT  . . . . . . . . . . . . .  	0000
  HLT_ND . . . . . . . . . . . .  	0001
  FMCT . . . . . . . . . . . . .  	0002
  FBPS . . . . . . . . . . . . .  	0003
  SPT  . . . . . . . . . . . . .  	0004
  SGAP . . . . . . . . . . . . .  	0005
  LSEC . . . . . . . . . . . . .  	0006
  FGAP . . . . . . . . . . . . .  	0007
  FFILL  . . . . . . . . . . . .  	0008
  HDST . . . . . . . . . . . . .  	0009
  FMST . . . . . . . . . . . . .  	000A
DBW  . . . . . . . . . . . . . .  	0010	0002
  HWB  . . . . . . . . . . . . .  	0008	0008	FF00	0000
  LWB  . . . . . . . . . . . . .  	0000	0008	00FF	0000
DMA_CR . . . . . . . . . . . . .  	0008	0008
  DACK . . . . . . . . . . . . .  	0007	0001	0080	0000
  DREQ . . . . . . . . . . . . .  	0006	0001	0040	0000
  DWS  . . . . . . . . . . . . .  	0005	0001	0020	0000
  DPRI . . . . . . . . . . . . .  	0004	0001	0010	0000
  DTIM . . . . . . . . . . . . .  	0003	0001	0008	0000
  DDIS . . . . . . . . . . . . .  	0002	0001	0004	0000
  DHLD . . . . . . . . . . . . .  	0001	0001	0002	0000
  DM2M . . . . . . . . . . . . .  	0000	0001	0001	0000
DMA_MR . . . . . . . . . . . . .  	0008	0005
  DMM  . . . . . . . . . . . . .  	0006	0002	00C0	0040
  DMINC  . . . . . . . . . . . .  	0005	0001	0020	0000
  DMAI . . . . . . . . . . . . .  	0004	0001	0010	0010
  DMOP . . . . . . . . . . . . .  	0002	0002	000C	0000
  DMCH . . . . . . . . . . . . .  	0000	0002	0003	0000
DMA_SMR  . . . . . . . . . . . .  	0008	0002
  SMCLR  . . . . . . . . . . . .  	0002	0006	00FC	0000
  SMCH . . . . . . . . . . . . .  	0000	0002	0003	0000
DMA_SR . . . . . . . . . . . . .  	0008	0008
  CR3  . . . . . . . . . . . . .  	0007	0001	0080	0000
  CR2  . . . . . . . . . . . . .  	0006	0001	0040	0000
  CR1  . . . . . . . . . . . . .  	0005	0001	0020	0000
  CR0  . . . . . . . . . . . . .  	0004	0001	0010	0000
  TC3  . . . . . . . . . . . . .  	0003	0001	0008	0000
  TC2  . . . . . . . . . . . . .  	0002	0001	0004	0000
  TC1  . . . . . . . . . . . . .  	0001	0001	0002	0000
  TC0  . . . . . . . . . . . . .  	0000	0001	0001	0000
DNB  . . . . . . . . . . . . . .  	0008	0002
  HBN  . . . . . . . . . . . . .  	0004	0004	00F0	0000
  LBN  . . . . . . . . . . . . .  	0000	0004	000F	0000
EFLAGS86 . . . . . . . . . . . .  	0008	0008
  FSF  . . . . . . . . . . . . .  	0007	0001	0080	0000
  FZF  . . . . . . . . . . . . .  	0006	0001	0040	0000
  FR1  . . . . . . . . . . . . .  	0005	0001	0020	0000
  FAF  . . . . . . . . . . . . .  	0004	0001	0010	0000
  FR2  . . . . . . . . . . . . .  	0003	0001	0008	0000
  FPF  . . . . . . . . . . . . .  	0002	0001	0004	0000
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Symbols-4


  FR3  . . . . . . . . . . . . .  	0001	0001	0002	0002
  FCF  . . . . . . . . . . . . .  	0000	0001	0001	0000
EQFLAGS  . . . . . . . . . . . .  	0010	000A
  LPT  . . . . . . . . . . . . .  	000E	0002	C000	0000
  X1 . . . . . . . . . . . . . .  	000D	0001	2000	0000
  GAM  . . . . . . . . . . . . .  	000C	0001	1000	0000
  COM  . . . . . . . . . . . . .  	0009	0003	0E00	0000
  DMA  . . . . . . . . . . . . .  	0008	0001	0100	0000
  FLP  . . . . . . . . . . . . .  	0006	0002	00C0	0000
  VID  . . . . . . . . . . . . .  	0004	0002	0030	0000
  MBRAM  . . . . . . . . . . . .  	0002	0002	000C	000C
  FPU  . . . . . . . . . . . . .  	0001	0001	0002	0000
  IPL  . . . . . . . . . . . . .  	0000	0001	0001	0000
FDC_CB . . . . . . . . . . . . .  	0008	0004
  FC0MT  . . . . . . . . . . . .  	0007	0001	0080	0000
  FC0MF  . . . . . . . . . . . .  	0006	0001	0040	0040
  FC0SK  . . . . . . . . . . . .  	0005	0001	0020	0000
  FC0CMD . . . . . . . . . . . .  	0000	0005	001F	0000
FDC_CB1  . . . . . . . . . . . .  	0008	0003
  FC1X . . . . . . . . . . . . .  	0003	0005	00F8	0000
  FC1HD  . . . . . . . . . . . .  	0002	0001	0004	0000
  FC1DS  . . . . . . . . . . . .  	0000	0002	0003	0000
FDC_CSB  . . . . . . . . . . . .  	0007	0007
  SB0  . . . . . . . . . . . . .  	0000
  SB1  . . . . . . . . . . . . .  	0001
  SB2  . . . . . . . . . . . . .  	0002
  CYL  . . . . . . . . . . . . .  	0003
  HEAD . . . . . . . . . . . . .  	0004
  SEC  . . . . . . . . . . . . .  	0005
  BPS  . . . . . . . . . . . . .  	0006
FDC_DOR  . . . . . . . . . . . .  	0008	0007
  FDMD . . . . . . . . . . . . .  	0007	0001	0080	0000
  FDMC . . . . . . . . . . . . .  	0006	0001	0040	0000
  FDMB . . . . . . . . . . . . .  	0005	0001	0020	0000
  FDMA . . . . . . . . . . . . .  	0004	0001	0010	0000
  FDDMA  . . . . . . . . . . . .  	0003	0001	0008	0000
  FDCEN  . . . . . . . . . . . .  	0002	0001	0004	0000
  FDSEL  . . . . . . . . . . . .  	0000	0002	0003	0000
FDC_MF . . . . . . . . . . . . .  	0008	0003
  FWRT . . . . . . . . . . . . .  	0007	0001	0080	0000
  FMTBD  . . . . . . . . . . . .  	0004	0003	0070	0000
  FMOT . . . . . . . . . . . . .  	0000	0004	000F	0000
FDC_MFD  . . . . . . . . . . . .  	0008	0005
  FMOTX  . . . . . . . . . . . .  	0004	0004	00F0	0000
  FMOT3  . . . . . . . . . . . .  	0003	0001	0008	0000
  FMOT2  . . . . . . . . . . . .  	0002	0001	0004	0000
  FMOT1  . . . . . . . . . . . .  	0001	0001	0002	0000
  FMOT0  . . . . . . . . . . . .  	0000	0001	0001	0000
FDC_MODE . . . . . . . . . . . .  	0008	0008
  FM1X . . . . . . . . . . . . .  	0007	0001	0080	0000
  FM1D . . . . . . . . . . . . .  	0006	0001	0040	0000
  FM1M . . . . . . . . . . . . .  	0005	0001	0020	0000
  FM18 . . . . . . . . . . . . .  	0004	0001	0010	0000
  FM0X . . . . . . . . . . . . .  	0003	0001	0008	0000
  FM0D . . . . . . . . . . . . .  	0002	0001	0004	0000
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Symbols-5


  FM0M . . . . . . . . . . . . .  	0001	0001	0002	0000
  FM08 . . . . . . . . . . . . .  	0000	0001	0001	0000
FDC_MSR  . . . . . . . . . . . .  	0008	0008
  FDRR . . . . . . . . . . . . .  	0007	0001	0080	0000
  FIOD . . . . . . . . . . . . .  	0006	0001	0040	0000
  FDND . . . . . . . . . . . . .  	0005	0001	0020	0000
  FDRW . . . . . . . . . . . . .  	0004	0001	0010	0000
  F3SK . . . . . . . . . . . . .  	0003	0001	0008	0000
  F2SK . . . . . . . . . . . . .  	0002	0001	0004	0000
  F1SK . . . . . . . . . . . . .  	0001	0001	0002	0000
  F0SK . . . . . . . . . . . . .  	0000	0001	0001	0000
FDC_SF . . . . . . . . . . . . .  	0008	0006
  FWIF . . . . . . . . . . . . .  	0007	0001	0080	0000
  FSTBD  . . . . . . . . . . . .  	0004	0003	0070	0000
  FCAL3  . . . . . . . . . . . .  	0003	0001	0008	0000
  FCAL2  . . . . . . . . . . . .  	0002	0001	0004	0000
  FCAL1  . . . . . . . . . . . .  	0001	0001	0002	0000
  FCAL0  . . . . . . . . . . . .  	0000	0001	0001	0000
FDC_ST0  . . . . . . . . . . . .  	0008	0006
  ST0CS  . . . . . . . . . . . .  	0006	0002	00C0	0000
  ST0SK  . . . . . . . . . . . .  	0005	0001	0020	0000
  ST0CHK . . . . . . . . . . . .  	0004	0001	0010	0000
  ST0NR  . . . . . . . . . . . .  	0003	0001	0008	0000
  ST0HD  . . . . . . . . . . . .  	0002	0001	0004	0000
  ST0DRV . . . . . . . . . . . .  	0000	0002	0003	0000
FDC_STATE  . . . . . . . . . . .  	0008	0005
  FSR  . . . . . . . . . . . . .  	0006	0002	00C0	0000
  FDDS . . . . . . . . . . . . .  	0005	0001	0020	0000
  FSE  . . . . . . . . . . . . .  	0004	0001	0010	0000
  FDX  . . . . . . . . . . . . .  	0003	0001	0008	0000
  FSD  . . . . . . . . . . . . .  	0000	0003	0007	0000
GFLAGS . . . . . . . . . . . . .  	0008	0004
  GTBD1  . . . . . . . . . . . .  	0004	0004	00F0	0000
  TURBO  . . . . . . . . . . . .  	0003	0001	0008	0000
  V20  . . . . . . . . . . . . .  	0002	0001	0004	0000
  GTBD2  . . . . . . . . . . . .  	0000	0002	0003	0000
ICW1 . . . . . . . . . . . . . .  	0008	0005
  D4 . . . . . . . . . . . . . .  	0004	0004	00F0	0010
  LTIM . . . . . . . . . . . . .  	0003	0001	0008	0000
  ADI  . . . . . . . . . . . . .  	0002	0001	0004	0000
  SNGL . . . . . . . . . . . . .  	0001	0001	0002	0002
  IC4  . . . . . . . . . . . . .  	0000	0001	0001	0001
ICW2 . . . . . . . . . . . . . .  	0008	0002
  ICW2IVA  . . . . . . . . . . .  	0003	0005	00F8	0000
  ICW2X  . . . . . . . . . . . .  	0000	0003	0007	0000
ICW4 . . . . . . . . . . . . . .  	0008	0004
  SFNM . . . . . . . . . . . . .  	0004	0004	00F0	0000
  ICWBUF . . . . . . . . . . . .  	0002	0002	000C	0000
  AEOI . . . . . . . . . . . . .  	0001	0001	0002	0000
  UPM  . . . . . . . . . . . . .  	0000	0001	0001	0000
KB . . . . . . . . . . . . . . .  	0010	0002
  KBK  . . . . . . . . . . . . .  	000A	0006	FC00	0000
  KBS  . . . . . . . . . . . . .  	0000	000A	03FF	0000
KBBRK  . . . . . . . . . . . . .  	0008	0002
  KBRK . . . . . . . . . . . . .  	0007	0001	0080	0000
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Symbols-6


  KBRX . . . . . . . . . . . . .  	0000	0007	007F	0000
KBFLAGS1 . . . . . . . . . . . .  	0008	0008
  K1IN . . . . . . . . . . . . .  	0007	0001	0080	0000
  K1CL . . . . . . . . . . . . .  	0006	0001	0040	0000
  K1NL . . . . . . . . . . . . .  	0005	0001	0020	0000
  K1SL . . . . . . . . . . . . .  	0004	0001	0010	0000
  K1AL . . . . . . . . . . . . .  	0003	0001	0008	0000
  K1CT . . . . . . . . . . . . .  	0002	0001	0004	0000
  K1LS . . . . . . . . . . . . .  	0001	0001	0002	0000
  K1RS . . . . . . . . . . . . .  	0000	0001	0001	0000
KBFLAGS2 . . . . . . . . . . . .  	0008	0008
  K2IN . . . . . . . . . . . . .  	0007	0001	0080	0000
  K2CL . . . . . . . . . . . . .  	0006	0001	0040	0000
  K2NL . . . . . . . . . . . . .  	0005	0001	0020	0000
  K2SL . . . . . . . . . . . . .  	0004	0001	0010	0000
  K2PA . . . . . . . . . . . . .  	0003	0001	0008	0000
  K2SY . . . . . . . . . . . . .  	0002	0001	0004	0000
  K2LA . . . . . . . . . . . . .  	0001	0001	0002	0000
  K2LC . . . . . . . . . . . . .  	0000	0001	0001	0000
KBFLAGS3 . . . . . . . . . . . .  	0008	0008
  KERD . . . . . . . . . . . . .  	0007	0001	0080	0000
  KEFI . . . . . . . . . . . . .  	0006	0001	0040	0000
  KENL . . . . . . . . . . . . .  	0005	0001	0020	0000
  KEEN . . . . . . . . . . . . .  	0004	0001	0010	0000
  KERA . . . . . . . . . . . . .  	0003	0001	0008	0000
  KERC . . . . . . . . . . . . .  	0002	0001	0004	0000
  KEE0 . . . . . . . . . . . . .  	0001	0001	0002	0000
  KEE1 . . . . . . . . . . . . .  	0000	0001	0001	0000
KBFLAGS4 . . . . . . . . . . . .  	0008	0008
  KLTE . . . . . . . . . . . . .  	0007	0001	0080	0000
  KLMU . . . . . . . . . . . . .  	0006	0001	0040	0000
  KLRF . . . . . . . . . . . . .  	0005	0001	0020	0000
  KLAK . . . . . . . . . . . . .  	0004	0001	0010	0000
  KLCI . . . . . . . . . . . . .  	0003	0001	0008	0000
  KLCL . . . . . . . . . . . . .  	0002	0001	0004	0000
  KLNL . . . . . . . . . . . . .  	0001	0001	0002	0000
  KLSL . . . . . . . . . . . . .  	0000	0001	0001	0000
KBP  . . . . . . . . . . . . . .  	0010	0002
  KBPK . . . . . . . . . . . . .  	0006	000A	FFC0	0000
  KBPS . . . . . . . . . . . . .  	0000	0006	003F	0000
KBW  . . . . . . . . . . . . . .  	0010	0002
  KBWK . . . . . . . . . . . . .  	0009	0007	FE00	0000
  KBWS . . . . . . . . . . . . .  	0000	0009	01FF	0000
KP . . . . . . . . . . . . . . .  	0010	0002
  KPWP . . . . . . . . . . . . .  	0004	000C	FFF0	0000
  KPWPX  . . . . . . . . . . . .  	0000	0004	000F	0000
MDA_CH_ATTR  . . . . . . . . . .  	0008	0004
  MDBK . . . . . . . . . . . . .  	0007	0001	0080	0000
  MDBG . . . . . . . . . . . . .  	0004	0003	0070	0000
  MDIN . . . . . . . . . . . . .  	0003	0001	0008	0000
  MDFG . . . . . . . . . . . . .  	0000	0003	0007	0007
NMI  . . . . . . . . . . . . . .  	0008	0002
  NMIE . . . . . . . . . . . . .  	0007	0001	0080	0000
  NMIX . . . . . . . . . . . . .  	0000	0007	007F	0000
OCW1 . . . . . . . . . . . . . .  	0008	0008
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Symbols-7


  IRQ7 . . . . . . . . . . . . .  	0007	0001	0080	0000
  IRQ6 . . . . . . . . . . . . .  	0006	0001	0040	0000
  IRQ5 . . . . . . . . . . . . .  	0005	0001	0020	0000
  IRQ4 . . . . . . . . . . . . .  	0004	0001	0010	0000
  IRQ3 . . . . . . . . . . . . .  	0003	0001	0008	0000
  IRQ2 . . . . . . . . . . . . .  	0002	0001	0004	0000
  IRQ1 . . . . . . . . . . . . .  	0001	0001	0002	0000
  IRQ0 . . . . . . . . . . . . .  	0000	0001	0001	0000
OCW2 . . . . . . . . . . . . . .  	0008	0003
  O2CMD  . . . . . . . . . . . .  	0005	0003	00E0	0020
  O2X  . . . . . . . . . . . . .  	0003	0002	0018	0000
  O2L  . . . . . . . . . . . . .  	0000	0003	0007	0000
OCW3 . . . . . . . . . . . . . .  	0008	0005
  O3D7 . . . . . . . . . . . . .  	0007	0001	0080	0000
  ESMM . . . . . . . . . . . . .  	0005	0002	0060	0000
  O3D3 . . . . . . . . . . . . .  	0003	0002	0018	0008
  O3P  . . . . . . . . . . . . .  	0002	0001	0004	0000
  O3RR . . . . . . . . . . . . .  	0000	0002	0003	0000
PFLAGS . . . . . . . . . . . . .  	0010	000A
  WARM . . . . . . . . . . . . .  	000F	0001	8000	0000
  PKI  . . . . . . . . . . . . .  	000E	0001	4000	0000
  PKEY . . . . . . . . . . . . .  	000D	0001	2000	0000
  PFDC . . . . . . . . . . . . .  	000C	0001	1000	0000
  PFSK . . . . . . . . . . . . .  	000B	0001	0800	0000
  PDMA . . . . . . . . . . . . .  	000A	0001	0400	0000
  PMEM . . . . . . . . . . . . .  	0009	0001	0200	0000
  PFXX . . . . . . . . . . . . .  	0008	0001	0100	0000
  PTBD . . . . . . . . . . . . .  	0002	0006	00FC	0000
  GRND . . . . . . . . . . . . .  	0000	0002	0003	0000
PIT_CW . . . . . . . . . . . . .  	0008	0004
  PCWSC  . . . . . . . . . . . .  	0006	0002	00C0	0000
  PCWRW  . . . . . . . . . . . .  	0004	0002	0030	0000
  PCWM . . . . . . . . . . . . .  	0001	0003	000E	0000
  PCWBCD . . . . . . . . . . . .  	0000	0001	0001	0000
PPI_B_F  . . . . . . . . . . . .  	0008	0008
  PBKB . . . . . . . . . . . . .  	0007	0001	0080	0000
  PBKC . . . . . . . . . . . . .  	0006	0001	0040	0000
  PBIO . . . . . . . . . . . . .  	0005	0001	0020	0000
  PBPC . . . . . . . . . . . . .  	0004	0001	0010	0000
  PBSW . . . . . . . . . . . . .  	0003	0001	0008	0000
  PBTB . . . . . . . . . . . . .  	0002	0001	0004	0000
  PBSP . . . . . . . . . . . . .  	0001	0001	0002	0000
  PBST . . . . . . . . . . . . .  	0000	0001	0001	0000
PPI_CR . . . . . . . . . . . . .  	0008	0007
  PPEN . . . . . . . . . . . . .  	0007	0001	0080	0080
  PPAM . . . . . . . . . . . . .  	0005	0002	0060	0000
  PPAD . . . . . . . . . . . . .  	0004	0001	0010	0010
  PPCU . . . . . . . . . . . . .  	0003	0001	0008	0008
  PPBM . . . . . . . . . . . . .  	0002	0001	0004	0000
  PPBD . . . . . . . . . . . . .  	0001	0001	0002	0000
  PPCL . . . . . . . . . . . . .  	0000	0001	0001	0001
PPI_C_X_H  . . . . . . . . . . .  	0008	0006
  PC2PE  . . . . . . . . . . . .  	0007	0001	0080	0000
  PC2IE  . . . . . . . . . . . .  	0006	0001	0040	0000
  PC2T2  . . . . . . . . . . . .  	0005	0001	0020	0000
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Symbols-8


  PC2CI  . . . . . . . . . . . .  	0004	0001	0010	0000
  PCDRV  . . . . . . . . . . . .  	0002	0002	000C	0000
  PCVID  . . . . . . . . . . . .  	0000	0002	0003	0000
PPI_C_X_L  . . . . . . . . . . .  	0008	0007
  PCPE . . . . . . . . . . . . .  	0007	0001	0080	0000
  PCIE . . . . . . . . . . . . .  	0006	0001	0040	0000
  PCT2 . . . . . . . . . . . . .  	0005	0001	0020	0000
  PCCI . . . . . . . . . . . . .  	0004	0001	0010	0000
  PCMB . . . . . . . . . . . . .  	0002	0002	000C	0000
  PCFP . . . . . . . . . . . . .  	0001	0001	0002	0000
  PCFD . . . . . . . . . . . . .  	0000	0001	0001	0000
PRN_CTRL . . . . . . . . . . . .  	0008	0006
  LCX  . . . . . . . . . . . . .  	0005	0003	00E0	0000
  LCIRQ  . . . . . . . . . . . .  	0004	0001	0010	0000
  LCDR . . . . . . . . . . . . .  	0003	0001	0008	0000
  LCINI  . . . . . . . . . . . .  	0002	0001	0004	0000
  LCLF . . . . . . . . . . . . .  	0001	0001	0002	0000
  LCOUT  . . . . . . . . . . . .  	0000	0001	0001	0000
PRN_STAT . . . . . . . . . . . .  	0008	0007
  LPBZ . . . . . . . . . . . . .  	0007	0001	0080	0000
  LPACK  . . . . . . . . . . . .  	0006	0001	0040	0000
  LPOP . . . . . . . . . . . . .  	0005	0001	0020	0000
  LPSEL  . . . . . . . . . . . .  	0004	0001	0010	0000
  LPIO . . . . . . . . . . . . .  	0003	0001	0008	0000
  LPX  . . . . . . . . . . . . .  	0001	0002	0006	0000
  LPTO . . . . . . . . . . . . .  	0000	0001	0001	0000
TIMER_C  . . . . . . . . . . . .  	0005	0003
  LW . . . . . . . . . . . . . .  	0000
  HW . . . . . . . . . . . . . .  	0002
  OF . . . . . . . . . . . . . .  	0004
V20_F3 . . . . . . . . . . . . .  	0008	0002
  VF3_OPC  . . . . . . . . . . .  	0003	0005	00F8	00C0
  VF3_SRC  . . . . . . . . . . .  	0000	0003	0007	0000
V20_F4 . . . . . . . . . . . . .  	0008	0003
  VF4_OPC  . . . . . . . . . . .  	0006	0002	00C0	00C0
  VF4_DST  . . . . . . . . . . .  	0003	0003	0038	0000
  VF4_SRC  . . . . . . . . . . .  	0000	0003	0007	0000
V20_R  . . . . . . . . . . . . .  	0008	0002
  VRW  . . . . . . . . . . . . .  	0003	0005	00F8	0000
  ROPC . . . . . . . . . . . . .  	0000	0003	0007	0000
V40_WCY1 . . . . . . . . . . . .  	0008	0004
  IOW  . . . . . . . . . . . . .  	0006	0002	00C0	0000
  UMW  . . . . . . . . . . . . .  	0004	0002	0030	0000
  MMW  . . . . . . . . . . . . .  	0002	0002	000C	0000
  LMW  . . . . . . . . . . . . .  	0000	0002	0003	0000
VID_ATTR . . . . . . . . . . . .  	0008	0002
  VBG  . . . . . . . . . . . . .  	0004	0004	00F0	0000
  VFB  . . . . . . . . . . . . .  	0000	0004	000F	0007
VID_CSGFX  . . . . . . . . . . .  	0008	0005
  CGPH . . . . . . . . . . . . .  	0006	0002	00C0	0000
  CGPL . . . . . . . . . . . . .  	0005	0001	0020	0020
  CGX  . . . . . . . . . . . . .  	0004	0001	0010	0010
  CGIN . . . . . . . . . . . . .  	0003	0001	0008	0008
  CGBG . . . . . . . . . . . . .  	0000	0003	0007	0007
VID_CSTXT  . . . . . . . . . . .  	0008	0004
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Symbols-9


  CTX  . . . . . . . . . . . . .  	0005	0003	00E0	0020
  CTBI . . . . . . . . . . . . .  	0004	0001	0010	0010
  CTIN . . . . . . . . . . . . .  	0003	0001	0008	0000
  CTBC . . . . . . . . . . . . .  	0000	0003	0007	0000
VID_STAT . . . . . . . . . . . .  	0008	0005
  VSX  . . . . . . . . . . . . .  	0004	0004	00F0	0000
  VSVS . . . . . . . . . . . . .  	0003	0001	0008	0000
  VSPE . . . . . . . . . . . . .  	0002	0001	0004	0000
  VSPT . . . . . . . . . . . . .  	0001	0001	0002	0000
  VSHS . . . . . . . . . . . . .  	0000	0001	0001	0000

Segments and Groups:

                N a m e         	Length	 Align	Combine Class

BIOS . . . . . . . . . . . . . .  	00010000 PARA	NONE	
RESET  . . . . . . . . . . . . .  	0000	AT	FFFF	
_BASIC . . . . . . . . . . . . .  	0000	AT	F600	
_BDA . . . . . . . . . . . . . .  	00F0	AT	0040	
_BDA_ABS . . . . . . . . . . . .  	0482	AT	0000	
_BIOS  . . . . . . . . . . . . .  	FFF0	AT	F000	
_BOOT_STACK  . . . . . . . . . .  	0100	AT	0030	
_CGA_MEM . . . . . . . . . . . .  	4000	AT	B800	
_DOS_DAT . . . . . . . . . . . .  	0034	AT	0050	
_IPL_SEG . . . . . . . . . . . .  	7E00	AT	0000	
_IVT . . . . . . . . . . . . . .  	0080	AT	0000	
_MDA_MEM . . . . . . . . . . . .  	1000	AT	B000	
_OPT_ROM . . . . . . . . . . . .  	0000	AT	C800	
_VID_BIOS  . . . . . . . . . . .  	0005	AT	C000	

Symbols:            

                N a m e         	Type	 Value	 Attr

ADI  . . . . . . . . . . . . . .  		0002	
AEOI . . . . . . . . . . . . . .  		0001	
ANY_KEY  . . . . . . . . . . . .  	L BYTE	E4A7	BIOS
ARCH_5150  . . . . . . . . . . .  	NUMBER	0050	
ARCH_5160  . . . . . . . . . . .  	NUMBER	0058	
ARCH_5160V2  . . . . . . . . . .  	NUMBER	0059	
ARCH_BOOK88  . . . . . . . . . .  	NUMBER	0042	
ARCH_CPQ . . . . . . . . . . . .  	NUMBER	0051	
ARCH_EHB . . . . . . . . . . . .  	NUMBER	0048	
ARCH_EMU . . . . . . . . . . . .  	NUMBER	0045	
ARCH_FE2010  . . . . . . . . . .  	NUMBER	0046	
ARCH_ID  . . . . . . . . . . . .  	NUMBER	00FE	
ARCH_LASER . . . . . . . . . . .  	NUMBER	004C	
ARCH_M88 . . . . . . . . . . . .  	NUMBER	004D	
ARCH_MARTY . . . . . . . . . . .  	NUMBER	0043	
ARCH_MIST  . . . . . . . . . . .  	NUMBER	0049	
ARCH_SUB_TYPE  . . . . . . . . .  	TEXT  "A"		
ARCH_TD3300  . . . . . . . . . .  	NUMBER	0053	
ARCH_TURBO . . . . . . . . . . .  	NUMBER	0054	
ARCH_TYPE  . . . . . . . . . . .  	ALIAS	 ARCH_TURBO		
ARCH_UM82  . . . . . . . . . . .  	NUMBER	0055	
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Symbols-10


ARCH_VEN888  . . . . . . . . . .  	NUMBER	0056	
ARCH_VIRTUALXT . . . . . . . . .  	NUMBER	0041	
ATKB_CMD . . . . . . . . . . . .  	NUMBER	0064	
ATKB_IO  . . . . . . . . . . . .  	NUMBER	0060	

BANNER_STRINGS . . . . . . . . .  	N PROC	E485	BIOS	Length = 0037
BASE_RAM_ERROR . . . . . . . . .  	L NEAR	E153	BIOS
BASE_RAM_TEST  . . . . . . . . .  	L NEAR	E127	BIOS
BASE_RAM_ZERO  . . . . . . . . .  	L NEAR	E158	BIOS
BASIC_ROM  . . . . . . . . . . .  	NUMBER	0000	
BASIC_TOP  . . . . . . . . . . .  	L WORD	0000	_BASIC
BEEP . . . . . . . . . . . . . .  	N PROC	E8AE	BIOS	Length = 0013
BEEP_1K  . . . . . . . . . . . .  	NUMBER	04A9	
BEEP_1K7 . . . . . . . . . . . .  	NUMBER	04A0	
BEEP_2K  . . . . . . . . . . . .  	NUMBER	0250	
BEEP_A4  . . . . . . . . . . . .  	NUMBER	0A98	
BEEP_A5  . . . . . . . . . . . .  	NUMBER	054C	
BEEP_B4  . . . . . . . . . . . .  	NUMBER	0970	
BEEP_B5  . . . . . . . . . . . .  	NUMBER	04B8	
BEEP_C4  . . . . . . . . . . . .  	NUMBER	11D1	
BEEP_C5  . . . . . . . . . . . .  	NUMBER	08E8	
BEEP_C6  . . . . . . . . . . . .  	NUMBER	0474	
BEEP_D5  . . . . . . . . . . . .  	NUMBER	07F0	
BEEP_DEFAULT . . . . . . . . . .  	ALIAS	 BEEP_A5		
BEEP_E5  . . . . . . . . . . . .  	NUMBER	0712	
BEEP_ERR_HIGH  . . . . . . . . .  	ALIAS	 BEEP_F5		
BEEP_ERR_LOW . . . . . . . . . .  	ALIAS	 BEEP_C5		
BEEP_F5  . . . . . . . . . . . .  	NUMBER	06AC	
BEEP_G5  . . . . . . . . . . . .  	NUMBER	05F2	
BEEP_L . . . . . . . . . . . . .  		0000	
BEEP_OFF_P . . . . . . . . . . .  	N PROC	E8F1	BIOS	Length = 0005
BEEP_ON_1  . . . . . . . . . . .  	N PROC	E8E2	BIOS	Length = 000F
BEEP_ON_P  . . . . . . . . . . .  	N PROC	E8DC	BIOS	Length = 0015
BEEP_PROC  . . . . . . . . . . .  	N PROC	E874	BIOS	Length = 0082
BEEP_S . . . . . . . . . . . . .  		0004	
BELL . . . . . . . . . . . . . .  	NUMBER	0007	
BIOS_BREAK . . . . . . . . . . .  	L BYTE	0071	_BDA
BIOS_INT_VECTORS_LOOP  . . . . .  	L NEAR	E1C9	BIOS
BIOS_ROM_SCAN  . . . . . . . . .  	N PROC	E50B	BIOS	Length = 0043
BIOS_TOP . . . . . . . . . . . .  	N PROC	E000	BIOS	Length = 005B
BIOS_VIDEO . . . . . . . . . . .  	L NEAR	F61C	BIOS
BLACK  . . . . . . . . . . . . .  	NUMBER	0000	
BLOCK_LOOP . . . . . . . . . . .  	L NEAR	E576	BIOS
BLOCK_LOOP_DONE  . . . . . . . .  	L NEAR	E582	BIOS
BLUE . . . . . . . . . . . . . .  	NUMBER	0009	
BOOT . . . . . . . . . . . . . .  	N PROC	E05B	BIOS	Length = 042A
BOOT_DEVICE  . . . . . . . . . .  	L NEAR	E469	BIOS
BOOT_FAIL  . . . . . . . . . . .  	L BYTE	E488	BIOS
BOOT_MEDIUM  . . . . . . . . . .  	NUMBER	004D	
BOOT_NORMAL  . . . . . . . . . .  	NUMBER	004E	
BOOT_RETRY . . . . . . . . . . .  	L NEAR	E46C	BIOS
BOOT_SPEED . . . . . . . . . . .  	ALIAS	 BOOT_TURBO		
BOOT_TURBO . . . . . . . . . . .  	NUMBER	0054	
BROWN  . . . . . . . . . . . . .  	NUMBER	0006	
BS . . . . . . . . . . . . . . .  	NUMBER	0008	
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Symbols-11


BULL . . . . . . . . . . . . . .  	NUMBER	00F9	
BYTES_HERE_BOOT  . . . . . . . .  	NUMBER	0000	
BYTES_HERE_GFX_CHARSET . . . . .  	NUMBER	004F	
BYTES_HERE_INT_02  . . . . . . .  	NUMBER	0039	
BYTES_HERE_INT_08  . . . . . . .  	NUMBER	0000	
BYTES_HERE_INT_09  . . . . . . .  	NUMBER	0000	
BYTES_HERE_INT_0E  . . . . . . .  	NUMBER	0001	
BYTES_HERE_INT_10_JMP  . . . . .  	NUMBER	0000	
BYTES_HERE_INT_12  . . . . . . .  	NUMBER	0090	
BYTES_HERE_INT_13  . . . . . . .  	NUMBER	0013	
BYTES_HERE_INT_14  . . . . . . .  	NUMBER	0000	
BYTES_HERE_INT_16  . . . . . . .  	NUMBER	0000	
BYTES_HERE_INT_19  . . . . . . .  	NUMBER	007D	
BYTES_HERE_INT_1D  . . . . . . .  	NUMBER	0001	
BYTES_HERE_INT_1E  . . . . . . .  	NUMBER	0038	
BYTES_HERE_INT_RET . . . . . . .  	NUMBER	0002	
BYTES_HERE_POWER_ON  . . . . . .  	NUMBER	0000	
BYTES_HERE_VECTOR_TABLE  . . . .  	NUMBER	0003	
BYTES_HERE_VER . . . . . . . . .  	NUMBER	0000	
BYTE_HEX . . . . . . . . . . . .  	N PROC	F792	BIOS	Length = 001F

CASSETTE . . . . . . . . . . . .  	NUMBER	0000	
CAS_CRC  . . . . . . . . . . . .  	L WORD	0069	_BDA
CAS_PREV . . . . . . . . . . . .  	L BYTE	006B	_BDA
CAS_RELOCATE . . . . . . . . . .  	NUMBER	0000	
CAS_TIME_CNT . . . . . . . . . .  	L WORD	0067	_BDA
CGA_COLOR  . . . . . . . . . . .  	NUMBER	03D9	
CGA_CTRL . . . . . . . . . . . .  	NUMBER	03D8	
CGA_DATA . . . . . . . . . . . .  	NUMBER	03D5	
CGA_IDX  . . . . . . . . . . . .  	NUMBER	03D4	
CGA_MEM_40 . . . . . . . . . . .  	L BYTE	0000	_CGA_MEM	Length = 0800
CGA_MEM_80 . . . . . . . . . . .  	L BYTE	0800	_CGA_MEM	Length = 3800
CGA_MEM_FLD  . . . . . . . . . .  	NUMBER	2000	
CGA_MEM_SZ . . . . . . . . . . .  	NUMBER	4000	
CGA_PEN_RST  . . . . . . . . . .  	NUMBER	03DB	
CGA_SNOW_REMOVE  . . . . . . . .  	NUMBER	0000	
CGA_STAT . . . . . . . . . . . .  	NUMBER	03DA	
CGBG . . . . . . . . . . . . . .  		0000	
CGIN . . . . . . . . . . . . . .  		0003	
CGPH . . . . . . . . . . . . . .  		0006	
CGPL . . . . . . . . . . . . . .  		0005	
CGX  . . . . . . . . . . . . . .  		0004	
CHECKSUM . . . . . . . . . . . .  	L NEAR	E0BC	BIOS
CHECKSUM_LOOP  . . . . . . . . .  	L NEAR	E557	BIOS
CHECKSUM_OK  . . . . . . . . . .  	L NEAR	E0C5	BIOS
CHECKSUM_ROM . . . . . . . . . .  	L NEAR	E0B4	BIOS
CHECK_ALT_ON . . . . . . . . . .  	L NEAR	EAAD	BIOS
CHECK_EGA  . . . . . . . . . . .  	L NEAR	F637	BIOS
CHECK_ROM  . . . . . . . . . . .  	L NEAR	E50E	BIOS
CHECK_TOP_ROW_NUM  . . . . . . .  	L NEAR	EA9E	BIOS
CHECK_VGA  . . . . . . . . . . .  	L NEAR	F629	BIOS
CLEAR_POST_SCREEN  . . . . . . .  	L NEAR	E455	BIOS
COLD_BOOT  . . . . . . . . . . .  	NUMBER	0000	
COM  . . . . . . . . . . . . . .  		0009	
COM1_DATA  . . . . . . . . . . .  	NUMBER	03F8	
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Symbols-12


COM1_IER . . . . . . . . . . . .  	NUMBER	03F9	
COM1_IIR . . . . . . . . . . . .  	NUMBER	03FA	
COM1_LCR . . . . . . . . . . . .  	NUMBER	03FB	
COM1_LSR . . . . . . . . . . . .  	NUMBER	03FD	
COM1_MCR . . . . . . . . . . . .  	NUMBER	03FC	
COM1_MSR . . . . . . . . . . . .  	NUMBER	03FE	
COM1_SPR . . . . . . . . . . . .  	NUMBER	03FF	
COM2_DATA  . . . . . . . . . . .  	NUMBER	02F8	
COM2_IIR . . . . . . . . . . . .  	NUMBER	02FA	
COM3_DATA  . . . . . . . . . . .  	NUMBER	03E8	
COM3_IIR . . . . . . . . . . . .  	NUMBER	03EA	
COM4_DATA  . . . . . . . . . . .  	NUMBER	02E8	
COM4_IIR . . . . . . . . . . . .  	NUMBER	02EA	
COM_ADDR . . . . . . . . . . . .  	L WORD	0000	_BDA	Length = 0004
COM_DETECT_LOOP  . . . . . . . .  	L NEAR	E306	BIOS
COM_TIME . . . . . . . . . . . .  	L BYTE	007C	_BDA	Length = 0004
COM_TIME_B . . . . . . . . . . .  	NUMBER	007C	
COM_TO . . . . . . . . . . . . .  	NUMBER	0001	
COPYRIGHT  . . . . . . . . . . .  	L BYTE	E031	BIOS
COPY_YEAR  . . . . . . . . . . .  	TEXT  '2022-24'		
CPU_8088 . . . . . . . . . . . .  	NUMBER	0038	
CPU_CHECK_TYPE_2 . . . . . . . .  	L NEAR	F653	BIOS
CPU_CHECK_TYPE_2_DONE  . . . . .  	L NEAR	F66F	BIOS
CPU_CHECK_TYPE_V20 . . . . . . .  	L NEAR	F665	BIOS
CPU_IS_V20 . . . . . . . . . . .  	L NEAR	E1D4	BIOS
CPU_REG_PASS . . . . . . . . . .  	L NEAR	E082	BIOS
CPU_REG_TEST . . . . . . . . . .  	L NEAR	E060	BIOS
CPU_TYPE . . . . . . . . . . . .  	ALIAS	 CPU_8088		
CPU_TYPE_8088  . . . . . . . . .  	L NEAR	E1E2	BIOS
CPU_TYPE_DONE  . . . . . . . . .  	L NEAR	E1E2	BIOS
CPU_V20  . . . . . . . . . . . .  	NUMBER	0056	
CR . . . . . . . . . . . . . . .  	NUMBER	000D	
CR0  . . . . . . . . . . . . . .  		0004	
CR1  . . . . . . . . . . . . . .  		0005	
CR2  . . . . . . . . . . . . . .  		0006	
CR3  . . . . . . . . . . . . . .  		0007	
CRLF . . . . . . . . . . . . . .  	N PROC	F757	BIOS	Length = 0009
CRLF_SHOW_CURSOR . . . . . . . .  	N PROC	F032	BIOS	Length = 0013
CRT_MODE . . . . . . . . . . . .  	L BYTE	F5F5	BIOS
CTBC . . . . . . . . . . . . . .  		0000	
CTBI . . . . . . . . . . . . . .  		0004	
CTIN . . . . . . . . . . . . . .  		0003	
CTX  . . . . . . . . . . . . . .  		0005	
CURL_BOT . . . . . . . . . . . .  	NUMBER	00F5	
CURL_TOP . . . . . . . . . . . .  	NUMBER	00F4	
CURSOR_DEFAULT . . . . . . . . .  	L WORD	00E8	_BDA
CYAN . . . . . . . . . . . . . .  	NUMBER	0003	

D4 . . . . . . . . . . . . . . .  		0004	
DACK . . . . . . . . . . . . . .  		0007	
DARKBLUE . . . . . . . . . . . .  	NUMBER	0001	
DARKGRAY . . . . . . . . . . . .  	NUMBER	0008	
DARKGREEN  . . . . . . . . . . .  	NUMBER	0002	
DARKMAGENTA  . . . . . . . . . .  	NUMBER	0005	
DARKRED  . . . . . . . . . . . .  	NUMBER	0004	
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Symbols-13


DBLARROW . . . . . . . . . . . .  	NUMBER	001D	
DCTS . . . . . . . . . . . . . .  		0000	
DDCD . . . . . . . . . . . . . .  		0003	
DDIS . . . . . . . . . . . . . .  		0002	
DDSR . . . . . . . . . . . . . .  		0001	
DETECT_MEMORY  . . . . . . . . .  	N PROC	E562	BIOS	Length = 0096
DETECT_MEMORY_ERR  . . . . . . .  	L NEAR	E5C9	BIOS
DETECT_MEMORY_ERR_2  . . . . . .  	L NEAR	E5EF	BIOS
DETECT_MEMORY_ERR_DONE . . . . .  	L NEAR	E5F3	BIOS
DHLD . . . . . . . . . . . . . .  		0001	
DISABLE_NMI  . . . . . . . . . .  	L NEAR	E082	BIOS
DLAB . . . . . . . . . . . . . .  		0007	
DM2M . . . . . . . . . . . . . .  		0000	
DMA  . . . . . . . . . . . . . .  		0008	
DMAI . . . . . . . . . . . . . .  		0004	
DMA_0_A  . . . . . . . . . . . .  	NUMBER	0000	
DMA_0_C  . . . . . . . . . . . .  	NUMBER	0001	
DMA_1_A  . . . . . . . . . . . .  	NUMBER	0002	
DMA_1_C  . . . . . . . . . . . .  	NUMBER	0003	
DMA_2_A  . . . . . . . . . . . .  	NUMBER	0004	
DMA_2_C  . . . . . . . . . . . .  	NUMBER	0005	
DMA_3_A  . . . . . . . . . . . .  	NUMBER	0006	
DMA_3_C  . . . . . . . . . . . .  	NUMBER	0007	
DMA_CMD  . . . . . . . . . . . .  	NUMBER	0008	
DMA_FF . . . . . . . . . . . . .  	NUMBER	000C	
DMA_MASK . . . . . . . . . . . .  	NUMBER	000A	
DMA_MASKR  . . . . . . . . . . .  	NUMBER	000E	
DMA_MMASK  . . . . . . . . . . .  	NUMBER	000F	
DMA_MODE . . . . . . . . . . . .  	NUMBER	000B	
DMA_PASS . . . . . . . . . . . .  	L NEAR	E107	BIOS
DMA_P_C0 . . . . . . . . . . . .  	NUMBER	0087	
DMA_P_C1 . . . . . . . . . . . .  	NUMBER	0083	
DMA_P_C2 . . . . . . . . . . . .  	NUMBER	0081	
DMA_P_C3 . . . . . . . . . . . .  	NUMBER	0082	
DMA_REQ  . . . . . . . . . . . .  	NUMBER	0009	
DMA_RESET  . . . . . . . . . . .  	NUMBER	000D	
DMA_SETUP_CH . . . . . . . . . .  	L NEAR	E122	BIOS
DMA_STATUS_OK  . . . . . . . . .  	L NEAR	E3D8	BIOS
DMCH . . . . . . . . . . . . . .  		0000	
DMINC  . . . . . . . . . . . . .  		0005	
DMM  . . . . . . . . . . . . . .  		0006	
DMOP . . . . . . . . . . . . . .  		0002	
DONE_ZERO_ALL_RAM  . . . . . . .  	L NEAR	E5C7	BIOS
DOS_FD_PARAM . . . . . . . . . .  	L BYTE	0022	_DOS_DAT	Length = 000E
DOT  . . . . . . . . . . . . . .  	NUMBER	00FA	
DPRI . . . . . . . . . . . . . .  		0004	
DRAM_REFRESH . . . . . . . . . .  	NUMBER	0012	
DREQ . . . . . . . . . . . . . .  		0006	
DRI  . . . . . . . . . . . . . .  		0002	
DTIM . . . . . . . . . . . . . .  		0003	
DTR  . . . . . . . . . . . . . .  		0000	
DWORD_HEX  . . . . . . . . . . .  	N PROC	F77F	BIOS	Length = 0032
DWS  . . . . . . . . . . . . . .  		0005	

EKB_FLAGS1 . . . . . . . . . . .  	L BYTE	0096	_BDA
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Symbols-14


EKB_FLAGS2 . . . . . . . . . . .  	L BYTE	0097	_BDA
EOI  . . . . . . . . . . . . . .  	NUMBER	0020	
EQUIP_FLAGS  . . . . . . . . . .  	L WORD	0010	_BDA
ESMM . . . . . . . . . . . . . .  		0005	
EXP_UNIT . . . . . . . . . . . .  	NUMBER	0000	
EXP_UNIT_CTRL  . . . . . . . . .  	NUMBER	0213	

F0SK . . . . . . . . . . . . . .  		0000	
F1SK . . . . . . . . . . . . . .  		0001	
F2SK . . . . . . . . . . . . . .  		0002	
F3SK . . . . . . . . . . . . . .  		0003	
FAF  . . . . . . . . . . . . . .  		0004	
FC0CMD . . . . . . . . . . . . .  		0000	
FC0MF  . . . . . . . . . . . . .  		0006	
FC0MT  . . . . . . . . . . . . .  		0007	
FC0SK  . . . . . . . . . . . . .  		0005	
FC1DS  . . . . . . . . . . . . .  		0000	
FC1HD  . . . . . . . . . . . . .  		0002	
FC1X . . . . . . . . . . . . . .  		0003	
FCAL0  . . . . . . . . . . . . .  		0000	
FCAL1  . . . . . . . . . . . . .  		0001	
FCAL2  . . . . . . . . . . . . .  		0002	
FCAL3  . . . . . . . . . . . . .  		0003	
FCF  . . . . . . . . . . . . . .  		0000	
FDCEN  . . . . . . . . . . . . .  		0002	
FDC_ADV_SEEK . . . . . . . . . .  	NUMBER	0001	
FDC_A_STAT . . . . . . . . . . .  	NUMBER	03F0	
FDC_B_STAT . . . . . . . . . . .  	NUMBER	03F1	
FDC_CHECK_SEEK . . . . . . . . .  	L NEAR	EDF5	BIOS
FDC_CMD_FMT  . . . . . . . . . .  	NUMBER	000D	
FDC_CMD_RD . . . . . . . . . . .  	NUMBER	0006	
FDC_CMD_RDEL . . . . . . . . . .  	NUMBER	000C	
FDC_CMD_RECAL  . . . . . . . . .  	NUMBER	0007	
FDC_CMD_RSID . . . . . . . . . .  	NUMBER	000A	
FDC_CMD_RTRK . . . . . . . . . .  	NUMBER	0002	
FDC_CMD_SEEK . . . . . . . . . .  	NUMBER	000F	
FDC_CMD_SENSE  . . . . . . . . .  	NUMBER	0008	
FDC_CMD_SPEC . . . . . . . . . .  	NUMBER	0003	
FDC_CMD_STAT . . . . . . . . . .  	NUMBER	0004	
FDC_CMD_WDEL . . . . . . . . . .  	NUMBER	0009	
FDC_CMD_WR . . . . . . . . . . .  	NUMBER	0005	
FDC_CTRL . . . . . . . . . . . .  	NUMBER	03F2	
FDC_DATA . . . . . . . . . . . .  	NUMBER	03F5	
FDC_DMA_BOUND  . . . . . . . . .  	L NEAR	ECE9	BIOS
FDC_DRIVE_STARTED  . . . . . . .  	L NEAR	EE65	BIOS
FDC_ENABLE . . . . . . . . . . .  	NUMBER	0000	
FDC_ERR1_MAP . . . . . . . . . .  	L BYTE	EF40	BIOS
FDC_ERR_MAP_LOOP . . . . . . . .  	L NEAR	EF33	BIOS
FDC_ERR_SEC_CT . . . . . . . . .  	NUMBER	0000	
FDC_FORMAT . . . . . . . . . . .  	N PROC	EDCD	BIOS	Length = 001B
FDC_FORMAT_ERR . . . . . . . . .  	L NEAR	EDCA	BIOS
FDC_HLT_WAIT . . . . . . . . . .  	NUMBER	0001	
FDC_INIT_DMA . . . . . . . . . .  	L NEAR	ED0C	BIOS
FDC_INIT_DMA_EXIT  . . . . . . .  	L NEAR	ED4D	BIOS
FDC_IPL_SW . . . . . . . . . . .  	NUMBER	0000	
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Symbols-15


FDC_LAST_ST  . . . . . . . . . .  	L 	0042	_BDA
FDC_MOTOR_ON . . . . . . . . . .  	L NEAR	EE35	BIOS
FDC_RECAL  . . . . . . . . . . .  	N PROC	EE34	BIOS	Length = 005E
FDC_RECAL_DONE . . . . . . . . .  	L NEAR	EE90	BIOS
FDC_RECAL_ERR  . . . . . . . . .  	L NEAR	EE90	BIOS
FDC_RECV . . . . . . . . . . . .  	N PROC	EE92	BIOS	Length = 004B
FDC_RECV_ALL . . . . . . . . . .  	N PROC	EEE9	BIOS	Length = 0032
FDC_RECV_ALL_DONE  . . . . . . .  	L NEAR	EF0D	BIOS
FDC_RECV_ALL_LOOP  . . . . . . .  	L NEAR	EEF6	BIOS
FDC_RECV_CHECK_ERR . . . . . . .  	L NEAR	EF08	BIOS
FDC_RECV_DELAY . . . . . . . . .  	L NEAR	EEFE	BIOS
FDC_RECV_FDC_ERR . . . . . . . .  	L NEAR	EF12	BIOS
FDC_RECV_READY . . . . . . . . .  	L NEAR	EEC2	BIOS
FDC_RECV_STATUS  . . . . . . . .  	N PROC	EEE7	BIOS	Length = 0034
FDC_RECV_WAIT_POLL . . . . . . .  	L NEAR	EEBE	BIOS
FDC_RWV  . . . . . . . . . . . .  	N PROC	ED7A	BIOS	Length = 004D
FDC_RWVF . . . . . . . . . . . .  	L NEAR	ED60	BIOS
FDC_RWV_ERR  . . . . . . . . . .  	L NEAR	EDCA	BIOS
FDC_RWV_SEND_WAIT  . . . . . . .  	L NEAR	EDA8	BIOS
FDC_SEC_COUNT  . . . . . . . . .  	L NEAR	EDB2	BIOS
FDC_SEC_COUNT_SAME . . . . . . .  	L NEAR	EDC5	BIOS
FDC_SEC_COUNT_SAME_CYL . . . . .  	L NEAR	EDC3	BIOS
FDC_SEEK . . . . . . . . . . . .  	N PROC	EDE8	BIOS	Length = 004C
FDC_SEEK_DONE  . . . . . . . . .  	L NEAR	EE2B	BIOS
FDC_SEEK_ERR . . . . . . . . . .  	L NEAR	EE2E	BIOS
FDC_SEEK_RECAL_ERR . . . . . . .  	L NEAR	EE2E	BIOS
FDC_SEEK_SETTLE  . . . . . . . .  	L NEAR	EE21	BIOS
FDC_SEND . . . . . . . . . . . .  	N PROC	EE9A	BIOS	Length = 0043
FDC_SEND_PARAM . . . . . . . . .  	N PROC	EE97	BIOS	Length = 0046
FDC_SEND_READY . . . . . . . . .  	L NEAR	EEB9	BIOS
FDC_SEND_RECV  . . . . . . . . .  	L NEAR	EE9D	BIOS
FDC_SEND_WAIT_POLL . . . . . . .  	L NEAR	EEAB	BIOS
FDC_SEND_WAIT_POLL_1 . . . . . .  	L NEAR	EEB5	BIOS
FDC_SEND_WAIT_TIMER  . . . . . .  	L NEAR	EEC9	BIOS
FDC_STAT . . . . . . . . . . . .  	NUMBER	03F4	
FDC_ST_BADCMD  . . . . . . . . .  	NUMBER	0001	
FDC_ST_DISK_CHG  . . . . . . . .  	NUMBER	0006	
FDC_ST_DMA_64K . . . . . . . . .  	NUMBER	0009	
FDC_ST_DMA_OVR . . . . . . . . .  	NUMBER	0008	
FDC_ST_ERR_CRC . . . . . . . . .  	NUMBER	0010	
FDC_ST_ERR_FDC . . . . . . . . .  	NUMBER	0020	
FDC_ST_ERR_MARK  . . . . . . . .  	NUMBER	0002	
FDC_ST_ERR_MED . . . . . . . . .  	NUMBER	000C	
FDC_ST_ERR_SEC . . . . . . . . .  	NUMBER	0004	
FDC_ST_ERR_SEEK  . . . . . . . .  	NUMBER	0040	
FDC_ST_ERR_WP  . . . . . . . . .  	NUMBER	0003	
FDC_ST_OK  . . . . . . . . . . .  	NUMBER	0000	
FDC_ST_SENSE . . . . . . . . . .  	NUMBER	00FF	
FDC_ST_TIMEOUT . . . . . . . . .  	NUMBER	0080	
FDC_WAIT_DONE  . . . . . . . . .  	L NEAR	EEC3	BIOS
FDC_WAIT_ERR_EXIT  . . . . . . .  	L NEAR	EF3C	BIOS
FDC_WAIT_ERR_EXIT_OK . . . . . .  	L NEAR	EF3F	BIOS
FDC_WAIT_EXIT  . . . . . . . . .  	L NEAR	EEC5	BIOS
FDC_WAIT_INT . . . . . . . . . .  	N PROC	EF6A	BIOS	Length = 0025
FDC_WAIT_INT_DONE  . . . . . . .  	L NEAR	EF8C	BIOS
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Symbols-16


FDC_WAIT_INT_LOOP1 . . . . . . .  	L NEAR	EF70	BIOS
FDC_WAIT_INT_LOOP2 . . . . . . .  	L NEAR	EF73	BIOS
FDC_WAIT_INT_OK  . . . . . . . .  	L NEAR	EF88	BIOS
FDC_WAIT_SENSE . . . . . . . . .  	N PROC	EEDD	BIOS	Length = 003E
FDC_WAIT_SENSE_EXIT  . . . . . .  	L NEAR	EF11	BIOS
FDC_WAIT_STATUS  . . . . . . . .  	N PROC	EF1B	BIOS	Length = 002D
FDC_WAIT_STATUS_ERR  . . . . . .  	N PROC	EF23	BIOS	Length = 0025
FDC_WAIT_STATUS_ERR_DONE . . . .  	L NEAR	EF3A	BIOS
FDC_WAIT_TIMEOUT . . . . . . . .  	L NEAR	EED4	BIOS
FDC_ZERO_BDA . . . . . . . . . .  	NUMBER	0000	
FDDMA  . . . . . . . . . . . . .  		0003	
FDDS . . . . . . . . . . . . . .  		0005	
FDMA . . . . . . . . . . . . . .  		0004	
FDMB . . . . . . . . . . . . . .  		0005	
FDMC . . . . . . . . . . . . . .  		0006	
FDMD . . . . . . . . . . . . . .  		0007	
FDND . . . . . . . . . . . . . .  		0005	
FDRR . . . . . . . . . . . . . .  		0007	
FDRW . . . . . . . . . . . . . .  		0004	
FDSEL  . . . . . . . . . . . . .  		0000	
FDX  . . . . . . . . . . . . . .  		0003	
FD_AUTO_DETECT . . . . . . . . .  	NUMBER	0000	
FD_CAL_ST  . . . . . . . . . . .  	L BYTE	003E	_BDA
FD_CAL_ST_ABS  . . . . . . . . .  	L BYTE	043E	_BDA_ABS
FD_LAST_OP . . . . . . . . . . .  	L BYTE	0041	_BDA
FD_LR  . . . . . . . . . . . . .  	L BYTE	008B	_BDA
FD_MEDIA_ST  . . . . . . . . . .  	L BYTE	0090	_BDA	Length = 0004
FD_MODE  . . . . . . . . . . . .  	L BYTE	008F	_BDA
FD_MOTOR_CT  . . . . . . . . . .  	L BYTE	0040	_BDA
FD_MOTOR_CT_ABS  . . . . . . . .  	L BYTE	0440	_BDA_ABS
FD_MOTOR_ST  . . . . . . . . . .  	L BYTE	003F	_BDA
FD_TRACK . . . . . . . . . . . .  	L BYTE	0094	_BDA	Length = 0002
FE2010_CONF_REG  . . . . . . . .  	L BYTE	00EC	_BDA
FIELD_EVEN . . . . . . . . . . .  	L NEAR	F550	BIOS
FIOD . . . . . . . . . . . . . .  		0006	
FLP  . . . . . . . . . . . . . .  		0006	
FM08 . . . . . . . . . . . . . .  		0000	
FM0D . . . . . . . . . . . . . .  		0002	
FM0M . . . . . . . . . . . . . .  		0001	
FM0X . . . . . . . . . . . . . .  		0003	
FM18 . . . . . . . . . . . . . .  		0004	
FM1D . . . . . . . . . . . . . .  		0006	
FM1M . . . . . . . . . . . . . .  		0005	
FM1X . . . . . . . . . . . . . .  		0007	
FMOT . . . . . . . . . . . . . .  		0000	
FMOT0  . . . . . . . . . . . . .  		0000	
FMOT1  . . . . . . . . . . . . .  		0001	
FMOT2  . . . . . . . . . . . . .  		0002	
FMOT3  . . . . . . . . . . . . .  		0003	
FMOTX  . . . . . . . . . . . . .  		0004	
FMTBD  . . . . . . . . . . . . .  		0004	
FOUND_ROM  . . . . . . . . . . .  	L NEAR	E51D	BIOS
FPF  . . . . . . . . . . . . . .  		0002	
FPU  . . . . . . . . . . . . . .  		0001	
FPU_CHECK  . . . . . . . . . . .  	L NEAR	F675	BIOS
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Symbols-17


FPU_DISP_DONE  . . . . . . . . .  	L NEAR	F687	BIOS
FPU_TEST_CW  . . . . . . . . . .  	L NEAR	FFD2	BIOS
FPU_TEST_DONE  . . . . . . . . .  	L NEAR	FFDE	BIOS
FPU_TEST_SW  . . . . . . . . . .  	L NEAR	FFC6	BIOS
FR1  . . . . . . . . . . . . . .  		0005	
FR2  . . . . . . . . . . . . . .  		0003	
FR3  . . . . . . . . . . . . . .  		0001	
FSD  . . . . . . . . . . . . . .  		0000	
FSE  . . . . . . . . . . . . . .  		0004	
FSF  . . . . . . . . . . . . . .  		0007	
FSR  . . . . . . . . . . . . . .  		0006	
FSTBD  . . . . . . . . . . . . .  		0004	
FWIF . . . . . . . . . . . . . .  		0007	
FWRT . . . . . . . . . . . . . .  		0007	
FZF  . . . . . . . . . . . . . .  		0006	

GAM  . . . . . . . . . . . . . .  		000C	
GAME_CTRL  . . . . . . . . . . .  	NUMBER	0201	
GB_FLAGS . . . . . . . . . . . .  	L BYTE	0012	_BDA
GET_DISK_PARAMS  . . . . . . . .  	N PROC	E71E	BIOS	Length = 001B
GET_DISK_PARAMS_ERR  . . . . . .  	L NEAR	E738	BIOS
GET_SW_SETTINGS  . . . . . . . .  	L NEAR	E1E2	BIOS
GFX_CHARSET  . . . . . . . . . .  	L BYTE	FA6E	BIOS
GRAY . . . . . . . . . . . . . .  	NUMBER	0007	
GREEN  . . . . . . . . . . . . .  	NUMBER	000A	
GRND . . . . . . . . . . . . . .  		0000	
GTBD1  . . . . . . . . . . . . .  		0004	
GTBD2  . . . . . . . . . . . . .  		0000	

HALF . . . . . . . . . . . . . .  	NUMBER	00AB	
HALT_BEEP  . . . . . . . . . . .  	N PROC	E874	BIOS	Length = 003A
HALT_BEEP_1  . . . . . . . . . .  	L NEAR	E155	BIOS
HALT_BEEP_2  . . . . . . . . . .  	L NEAR	E23D	BIOS
HALT_BEEP_REP  . . . . . . . . .  	L NEAR	E885	BIOS
HALT_BEEP_START  . . . . . . . .  	L NEAR	E87C	BIOS
HALT_BEEP_START_ODD  . . . . . .  	L NEAR	E883	BIOS
HALT_ERROR . . . . . . . . . . .  	L NEAR	E0F0	BIOS
HAS_FPU  . . . . . . . . . . . .  	N PROC	FFC3	BIOS	Length = 001D
HBN  . . . . . . . . . . . . . .  		0004	
HDC_CTRL . . . . . . . . . . . .  	NUMBER	0321	
HDC_DMA  . . . . . . . . . . . .  	NUMBER	0323	
HDC_PULSE  . . . . . . . . . . .  	NUMBER	0322	
HDC_READ . . . . . . . . . . . .  	NUMBER	0320	
HDC_STAT . . . . . . . . . . . .  	NUMBER	0324	
HDD_POST . . . . . . . . . . . .  	N PROC	E3EE	BIOS	Length = 002E
HDD_POST_DONE  . . . . . . . . .  	L NEAR	E41C	BIOS
HDD_POST_NONE  . . . . . . . . .  	L NEAR	E419	BIOS
HDD_POST_SHOW_LOOP . . . . . . .  	L NEAR	E411	BIOS
HD_COUNT . . . . . . . . . . . .  	L BYTE	0075	_BDA
HD_CTRL  . . . . . . . . . . . .  	L BYTE	0076	_BDA
HD_LAST_ST . . . . . . . . . . .  	L BYTE	0074	_BDA
HD_PORT  . . . . . . . . . . . .  	L BYTE	0077	_BDA
HEART  . . . . . . . . . . . . .  	NUMBER	0003	
HELLO_RAND_TAGLINE . . . . . . .  	N PROC	F8C7	BIOS	Length = 006F
HELLO_WORLD  . . . . . . . . . .  	L NEAR	E24C	BIOS
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Symbols-18


HIDE_CURSOR  . . . . . . . . . .  	N PROC	F03B	BIOS	Length = 000A
HL . . . . . . . . . . . . . . .  	NUMBER	00C4	
HWB  . . . . . . . . . . . . . .  		0008	

IC4  . . . . . . . . . . . . . .  		0000	
ICW2IVA  . . . . . . . . . . . .  		0003	
ICW2X  . . . . . . . . . . . . .  		0000	
ICWBUF . . . . . . . . . . . . .  		0002	
INIT_AT_KBC  . . . . . . . . . .  	NUMBER	0000	
INIT_DMA1  . . . . . . . . . . .  	L NEAR	E0C5	BIOS
INIT_PIT1  . . . . . . . . . . .  	L NEAR	E0F2	BIOS
INIT_PIT1_TEST . . . . . . . . .  	L NEAR	E0D8	BIOS
INIT_PIT1_TEST_DONE  . . . . . .  	L NEAR	E0F2	BIOS
INIT_PIT1_TEST_READ  . . . . . .  	L NEAR	E0E0	BIOS
INIT_SW_INT_VECTORS  . . . . . .  	L NEAR	E1C0	BIOS
INIT_V40 . . . . . . . . . . . .  	NUMBER	0000	
INIT_VIDEO . . . . . . . . . . .  	L NEAR	E086	BIOS
INT_02 . . . . . . . . . . . . .  	N PROC	E2C3	BIOS	Length = 0020
INT_02_NMI_HALT  . . . . . . . .  	L NEAR	E2D5	BIOS
INT_02_NMI_PAR . . . . . . . . .  	L NEAR	E2CC	BIOS
INT_05 . . . . . . . . . . . . .  	N PROC	FF54	BIOS	Length = 006F
INT_05_DONE  . . . . . . . . . .  	L NEAR	FF9A	BIOS
INT_05_EXIT  . . . . . . . . . .  	L NEAR	FFA6	BIOS
INT_05_LOOP_1  . . . . . . . . .  	L NEAR	FF7C	BIOS
INT_05_NEXT_COL  . . . . . . . .  	L NEAR	FF94	BIOS
INT_08 . . . . . . . . . . . . .  	N PROC	FEA5	BIOS	Length = 003B
INT_08_EOI . . . . . . . . . . .  	L NEAR	FEC7	BIOS
INT_08_FD_MOTOR  . . . . . . . .  	L NEAR	FEBE	BIOS
INT_08_INT_1C  . . . . . . . . .  	L NEAR	FEC5	BIOS
INT_08_MOTOR_OFF . . . . . . . .  	L NEAR	FE97	BIOS
INT_08_PROC  . . . . . . . . . .  	N PROC	FE97	BIOS	Length = 0049
INT_08_RESET . . . . . . . . . .  	L NEAR	FED6	BIOS
INT_08_TICK_DAY  . . . . . . . .  	L NEAR	FED1	BIOS
INT_08_TICK_TIMER  . . . . . . .  	L NEAR	FEAF	BIOS
INT_09 . . . . . . . . . . . . .  	N PROC	E987	BIOS	Length = 02BF
INT_09_POST  . . . . . . . . . .  	N PROC	E944	BIOS	Length = 001B
INT_09_POST_DONE . . . . . . . .  	L NEAR	E953	BIOS
INT_0E . . . . . . . . . . . . .  	N PROC	EF57	BIOS	Length = 0013
INT_10 . . . . . . . . . . . . .  	N PROC	F065	BIOS	Length = 0598
INT_10_0 . . . . . . . . . . . .  	N PROC	F0E4	BIOS	Length = 00BC
INT_10_0_1 . . . . . . . . . . .  	L NEAR	F0F2	BIOS
INT_10_0_COLOR_BYTE  . . . . . .  	L NEAR	F187	BIOS
INT_10_0_CRTC_LOOP . . . . . . .  	L NEAR	F177	BIOS
INT_10_0_DETECT_DONE . . . . . .  	L NEAR	F147	BIOS
INT_10_0_IS_40_COL . . . . . . .  	L NEAR	F145	BIOS
INT_10_0_IS_CGA  . . . . . . . .  	L NEAR	F121	BIOS
INT_10_0_IS_CGA_GFX  . . . . . .  	L NEAR	F12E	BIOS
INT_10_0_IS_CGA_TEXT . . . . . .  	L NEAR	F13C	BIOS
INT_10_1 . . . . . . . . . . . .  	N PROC	F1A0	BIOS	Length = 0016
INT_10_2 . . . . . . . . . . . .  	N PROC	F1B6	BIOS	Length = 0039
INT_10_2_DONE  . . . . . . . . .  	L NEAR	F1ED	BIOS
INT_10_3 . . . . . . . . . . . .  	N PROC	F1FC	BIOS	Length = 0011
INT_10_3_CUR_PAGE  . . . . . . .  	N PROC	F1EF	BIOS	Length = 001E
INT_10_4 . . . . . . . . . . . .  	N PROC	F99F	BIOS	Length = 0080
INT_10_4_CAL_1 . . . . . . . . .  	L NEAR	F9DA	BIOS
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Symbols-19


INT_10_4_CAL_2 . . . . . . . . .  	L NEAR	F9DB	BIOS
INT_10_4_CAL_DONE  . . . . . . .  	L NEAR	F9E1	BIOS
INT_10_4_DONE  . . . . . . . . .  	L NEAR	F9F7	BIOS
INT_10_4_EXIT  . . . . . . . . .  	L NEAR	F9FD	BIOS
INT_10_4_GFX . . . . . . . . . .  	L NEAR	FA00	BIOS
INT_10_4_LOW . . . . . . . . . .  	L NEAR	FA11	BIOS
INT_10_4_RESET . . . . . . . . .  	L NEAR	F9F9	BIOS
INT_10_4_TXT . . . . . . . . . .  	L NEAR	F9E5	BIOS
INT_10_5 . . . . . . . . . . . .  	N PROC	F20D	BIOS	Length = 0027
INT_10_6 . . . . . . . . . . . .  	N PROC	F235	BIOS	Length = 010F
INT_10_6_CHECK_CLS . . . . . . .  	L NEAR	F294	BIOS
INT_10_6_DONE  . . . . . . . . .  	L NEAR	F2B9	BIOS
INT_10_6_TXT_CLR . . . . . . . .  	L NEAR	F2AC	BIOS
INT_10_6_TXT_CLR_1 . . . . . . .  	L NEAR	F2AA	BIOS
INT_10_6_TXT_CLR_LOOP  . . . . .  	L NEAR	F2AE	BIOS
INT_10_6_TXT_MOVE_LOOP . . . . .  	L NEAR	F29E	BIOS
INT_10_7 . . . . . . . . . . . .  	N PROC	F234	BIOS	Length = 0110
INT_10_8 . . . . . . . . . . . .  	N PROC	F344	BIOS	Length = 009B
INT_10_8_CHK_CGA . . . . . . . .  	L NEAR	F352	BIOS
INT_10_8_FAST  . . . . . . . . .  	L NEAR	F34E	BIOS
INT_10_8_GFX_DONE  . . . . . . .  	L NEAR	F3C9	BIOS
INT_10_8_GFX_HIGH  . . . . . . .  	L NEAR	F3D1	BIOS
INT_10_8_GFX_LOW_1 . . . . . . .  	L NEAR	F376	BIOS
INT_10_8_GFX_LOW_2 . . . . . . .  	L NEAR	F382	BIOS
INT_10_8_GFX_SEARCH  . . . . . .  	L NEAR	F398	BIOS
INT_10_8_GFX_SEARCH_CHR  . . . .  	L NEAR	F3A6	BIOS
INT_10_8_GFX_SEARCH_TBL  . . . .  	L NEAR	F3A3	BIOS
INT_10_8_MODE_GFX  . . . . . . .  	N PROC	F358	BIOS	Length = 0087
INT_10_8_MODE_GFX_LOW  . . . . .  	L NEAR	F374	BIOS
INT_10_9 . . . . . . . . . . . .  	N PROC	F3DF	BIOS	Length = 00E4
INT_10_9A_FAST . . . . . . . . .  	L NEAR	F3EB	BIOS
INT_10_9A_GFX_2  . . . . . . . .  	L NEAR	F425	BIOS
INT_10_9A_GFX_FG . . . . . . . .  	L NEAR	F438	BIOS
INT_10_9A_GFX_HIGH . . . . . . .  	L NEAR	F489	BIOS
INT_10_9A_GFX_HIGH_WORD  . . . .  	L NEAR	F48D	BIOS
INT_10_9A_GFX_HIGH_WR  . . . . .  	L NEAR	F49A	BIOS
INT_10_9A_GFX_LOW  . . . . . . .  	L NEAR	F433	BIOS
INT_10_9A_GFX_LOW_BYTE . . . . .  	L NEAR	F44A	BIOS
INT_10_9A_GFX_LOW_CHAR . . . . .  	L NEAR	F444	BIOS
INT_10_9A_GFX_LOW_NEXT . . . . .  	L NEAR	F479	BIOS
INT_10_9A_GFX_LOW_PDEP . . . . .  	L NEAR	F451	BIOS
INT_10_9A_GFX_LOW_WR . . . . . .  	L NEAR	F469	BIOS
INT_10_9A_MODE_GFX . . . . . . .  	N PROC	F404	BIOS	Length = 00BF
INT_10_9A_MODE_GFX_DONE  . . . .  	L NEAR	F482	BIOS
INT_10_9A_MODE_GFX_EXIT  . . . .  	L NEAR	F487	BIOS
INT_10_9_FAST  . . . . . . . . .  	L NEAR	F3F7	BIOS
INT_10_A . . . . . . . . . . . .  	N PROC	F3DF	BIOS	Length = 00E4
INT_10_A_FAST  . . . . . . . . .  	L NEAR	F3F1	BIOS
INT_10_B . . . . . . . . . . . .  	N PROC	F4C3	BIOS	Length = 002B
INT_10_BOUNDS_OK . . . . . . . .  	L NEAR	F253	BIOS
INT_10_B_DONE  . . . . . . . . .  	L NEAR	F4DD	BIOS
INT_10_B_SET_COL . . . . . . . .  	L NEAR	F4CB	BIOS
INT_10_B_SET_PAL . . . . . . . .  	L NEAR	F4D2	BIOS
INT_10_C . . . . . . . . . . . .  	N PROC	F4EE	BIOS	Length = 0021
INT_10_CGA_CHECK . . . . . . . .  	L NEAR	F294	BIOS
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Symbols-20


INT_10_CHECK_BOUNDS  . . . . . .  	L NEAR	F249	BIOS
INT_10_CHK_CGA . . . . . . . . .  	L NEAR	F3FD	BIOS
INT_10_C_DONE  . . . . . . . . .  	L NEAR	F507	BIOS
INT_10_C_XOR . . . . . . . . . .  	L NEAR	F50A	BIOS
INT_10_D . . . . . . . . . . . .  	N PROC	F50F	BIOS	Length = 000D
INT_10_DONE  . . . . . . . . . .  	L NEAR	F081	BIOS
INT_10_E . . . . . . . . . . . .  	N PROC	F55F	BIOS	Length = 006A
INT_10_E_BELL  . . . . . . . . .  	L NEAR	F5B6	BIOS
INT_10_E_BS  . . . . . . . . . .  	L NEAR	F5C3	BIOS
INT_10_E_CHAR  . . . . . . . . .  	L NEAR	F56A	BIOS
INT_10_E_CR  . . . . . . . . . .  	L NEAR	F5BB	BIOS
INT_10_E_CTRL  . . . . . . . . .  	L NEAR	F5A8	BIOS
INT_10_E_CURS  . . . . . . . . .  	L NEAR	F5A0	BIOS
INT_10_E_DONE  . . . . . . . . .  	L NEAR	F5A3	BIOS
INT_10_E_LF  . . . . . . . . . .  	L NEAR	F5BF	BIOS
INT_10_E_SCROLL  . . . . . . . .  	L NEAR	F57B	BIOS
INT_10_E_SCROLL_UP . . . . . . .  	L NEAR	F58B	BIOS
INT_10_F . . . . . . . . . . . .  	N PROC	F5C9	BIOS	Length = 0008
INT_10_GET_CUR_ADDR  . . . . . .  	N PROC	F5D1	BIOS	Length = 0024
INT_10_GFX_CHARPOS . . . . . . .  	N PROC	F4AE	BIOS	Length = 0015
INT_10_GFX_PIXEL . . . . . . . .  	N PROC	F51C	BIOS	Length = 0043
INT_10_IRET  . . . . . . . . . .  	L NEAR	F084	BIOS
INT_10_IS_CGA80  . . . . . . . .  	N PROC	F090	BIOS	Length = 0013
INT_10_IS_CGA80_DONE . . . . . .  	L NEAR	F0A0	BIOS
INT_10_IS_TXT  . . . . . . . . .  	N PROC	F085	BIOS	Length = 000B
INT_10_IS_TXT_DONE . . . . . . .  	L NEAR	F08F	BIOS
INT_10_JMP . . . . . . . . . . .  	L WORD	F045	BIOS
INT_10_RET . . . . . . . . . . .  	L NEAR	F19F	BIOS
INT_10_SCR_GFX . . . . . . . . .  	N PROC	F2BE	BIOS	Length = 0086
INT_10_SCR_GFX_2 . . . . . . . .  	L NEAR	F2E7	BIOS
INT_10_SCR_GFX_CLR . . . . . . .  	L NEAR	F327	BIOS
INT_10_SCR_GFX_CLR_1 . . . . . .  	L NEAR	F325	BIOS
INT_10_SCR_GFX_CLR_LOOP  . . . .  	L NEAR	F32B	BIOS
INT_10_SCR_GFX_MOVE_LOOP . . . .  	L NEAR	F307	BIOS
INT_10_SCR_GFX_RDY . . . . . . .  	L NEAR	F2F0	BIOS
INT_10_SCR_TXT . . . . . . . . .  	L NEAR	F261	BIOS
INT_10_SET_CUR_OFFSET  . . . . .  	L NEAR	F1CD	BIOS
INT_11 . . . . . . . . . . . . .  	N PROC	F84D	BIOS	Length = 000C
INT_12 . . . . . . . . . . . . .  	N PROC	F841	BIOS	Length = 000C
INT_13 . . . . . . . . . . . . .  	N PROC	EC59	BIOS	Length = 0336
INT_13_0 . . . . . . . . . . . .  	N PROC	EC98	BIOS	Length = 004B
INT_13_0_1 . . . . . . . . . . .  	L NEAR	ECAD	BIOS
INT_13_0_2 . . . . . . . . . . .  	L NEAR	ECB3	BIOS
INT_13_0_DONE  . . . . . . . . .  	L NEAR	ECDF	BIOS
INT_13_0_RESET_BAD . . . . . . .  	L NEAR	ECC6	BIOS
INT_13_0_RESET_DONE  . . . . . .  	L NEAR	ECC8	BIOS
INT_13_1 . . . . . . . . . . . .  	N PROC	ECE3	BIOS	Length = 0006
INT_13_2_5 . . . . . . . . . . .  	N PROC	ECEF	BIOS	Length = 00F9
INT_13_2_5_EXIT  . . . . . . . .  	L NEAR	EDC7	BIOS
INT_13_2_5_SEEK_ERR  . . . . . .  	L NEAR	ED4E	BIOS
INT_13_2_5_SETUP_DMA . . . . . .  	L NEAR	ED05	BIOS
INT_13_BAD_CMD . . . . . . . . .  	L NEAR	EC7E	BIOS
INT_13_DONE  . . . . . . . . . .  	L NEAR	EC80	BIOS
INT_13_EXIT  . . . . . . . . . .  	L NEAR	EC8C	BIOS
INT_13_EXIT_1  . . . . . . . . .  	L NEAR	EC8F	BIOS
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Symbols-21


INT_13_SET_MOTOR_CT  . . . . . .  	L NEAR	EC82	BIOS
INT_14 . . . . . . . . . . . . .  	N PROC	E739	BIOS	Length = 00B2
INT_14_0 . . . . . . . . . . . .  	N PROC	E761	BIOS	Length = 0036
INT_14_0_SET_BAUD  . . . . . . .  	L NEAR	E779	BIOS
INT_14_0_SET_PSW . . . . . . . .  	L NEAR	E77C	BIOS
INT_14_1 . . . . . . . . . . . .  	N PROC	E797	BIOS	Length = 001E
INT_14_2 . . . . . . . . . . . .  	N PROC	E7B5	BIOS	Length = 0016
INT_14_3 . . . . . . . . . . . .  	N PROC	E787	BIOS	Length = 000A
INT_14_DONE  . . . . . . . . . .  	N PROC	E791	BIOS	Length = 0006
INT_14_EXIT  . . . . . . . . . .  	L NEAR	E795	BIOS
INT_14_POLL  . . . . . . . . . .  	N PROC	E7CB	BIOS	Length = 0020
INT_14_POLL_DONE . . . . . . . .  	L NEAR	E7E9	BIOS
INT_14_POLL_LOOP . . . . . . . .  	L NEAR	E7DB	BIOS
INT_14_POLL_PORT . . . . . . . .  	N PROC	E7D3	BIOS	Length = 0018
INT_14_POLL_RET  . . . . . . . .  	L NEAR	E7EA	BIOS
INT_14_RW_ERR  . . . . . . . . .  	L NEAR	E7B0	BIOS
INT_15 . . . . . . . . . . . . .  	N PROC	F859	BIOS	Length = 000A
INT_15_EXIT  . . . . . . . . . .  	L NEAR	F85C	BIOS
INT_16 . . . . . . . . . . . . .  	N PROC	E82E	BIOS	Length = 0046
INT_16_DONE  . . . . . . . . . .  	L NEAR	E86C	BIOS
INT_17 . . . . . . . . . . . . .  	N PROC	EFD2	BIOS	Length = 0060
INT_17_0 . . . . . . . . . . . .  	L NEAR	EFF7	BIOS
INT_17_0_BUSY_LOOP . . . . . . .  	L NEAR	EFFB	BIOS
INT_17_0_OK  . . . . . . . . . .  	L NEAR	F009	BIOS
INT_17_0_TIMEOUT_LOOP  . . . . .  	L NEAR	EFF9	BIOS
INT_17_1 . . . . . . . . . . . .  	L NEAR	F023	BIOS
INT_17_2 . . . . . . . . . . . .  	L NEAR	F014	BIOS
INT_17_2_STATUS  . . . . . . . .  	L NEAR	F015	BIOS
INT_17_2_STATUS_2  . . . . . . .  	L NEAR	F018	BIOS
INT_17_DONE  . . . . . . . . . .  	L NEAR	F01C	BIOS
INT_17_IRET  . . . . . . . . . .  	L NEAR	F022	BIOS
INT_18 . . . . . . . . . . . . .  	N PROC	E478	BIOS	Length = 000D
INT_19 . . . . . . . . . . . . .  	N PROC	E6F2	BIOS	Length = 002C
INT_19_BOOT_HD . . . . . . . . .  	NUMBER	0000	
INT_19_IPL_FAIL  . . . . . . . .  	L NEAR	E71D	BIOS
INT_19_READ_MBR  . . . . . . . .  	L NEAR	E704	BIOS
INT_1A . . . . . . . . . . . . .  	N PROC	FE6E	BIOS	Length = 0029
INT_1A_DONE  . . . . . . . . . .  	L NEAR	FE8A	BIOS
INT_1A_EXIT  . . . . . . . . . .  	L NEAR	FE8C	BIOS
INT_1A_READ  . . . . . . . . . .  	N PROC	FE81	BIOS	Length = 000C
INT_1A_SET . . . . . . . . . . .  	N PROC	FE8D	BIOS	Length = 000A
INT_1D . . . . . . . . . . . . .  	N PROC	F0A4	BIOS	Length = 0040
INT_1D_40  . . . . . . . . . . .  	L 	F0A4	BIOS
INT_1D_80  . . . . . . . . . . .  	L 	F0B4	BIOS
INT_1D_GFX . . . . . . . . . . .  	L 	F0C4	BIOS
INT_1D_MDA . . . . . . . . . . .  	L 	F0D4	BIOS
INT_1E . . . . . . . . . . . . .  	L 	EFC7	BIOS
INT_1E_PARAM . . . . . . . . . .  	N PROC	EF48	BIOS	Length = 000E
INT_IMR  . . . . . . . . . . . .  	NUMBER	0021	
INT_IRQ  . . . . . . . . . . . .  	N PROC	FF23	BIOS	Length = 0023
INT_IRQ_DONE . . . . . . . . . .  	L NEAR	FF3F	BIOS
INT_KB_ALT . . . . . . . . . . .  	N PROC	EA95	BIOS	Length = 003E
INT_KB_ALT_BREAK . . . . . . . .  	L NEAR	EB8C	BIOS
INT_KB_ALT_SKIP  . . . . . . . .  	L BYTE	EC1A	BIOS
INT_KB_CHECK_CTRL_NUM  . . . . .  	L NEAR	E9F0	BIOS
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Symbols-22


INT_KB_CTRL  . . . . . . . . . .  	L NEAR	EB12	BIOS
INT_KB_CTRL_ALPHA  . . . . . . .  	L NEAR	EAF8	BIOS
INT_KB_CTRL_ALT  . . . . . . . .  	L NEAR	EB17	BIOS
INT_KB_CTRL_ALT_1  . . . . . . .  	L NEAR	EB28	BIOS
INT_KB_CTRL_ALT_DEL  . . . . . .  	L NEAR	EB1C	BIOS
INT_KB_CTRL_ASC_TBL  . . . . . .  	L BYTE	E96F	BIOS
INT_KB_CTRL_ASC_TBL_DONE . . . .  	L NEAR	EAED	BIOS
INT_KB_CTRL_ASC_TBL_LOOP . . . .  	L NEAR	EAD9	BIOS
INT_KB_CTRL_BREAK  . . . . . . .  	L NEAR	E9E4	BIOS
INT_KB_CTRL_NO_ALT . . . . . . .  	N PROC	EAD3	BIOS	Length = 003F
INT_KB_CTRL_NO_ALT_1 . . . . . .  	L NEAR	EB06	BIOS
INT_KB_CTRL_NO_DONE  . . . . . .  	L NEAR	EAEA	BIOS
INT_KB_CTRL_SCAN_TBL . . . . . .  	L BYTE	E979	BIOS
INT_KB_DONE  . . . . . . . . . .  	L NEAR	EA8C	BIOS
INT_KB_DONE_1  . . . . . . . . .  	L NEAR	EAD1	BIOS
INT_KB_DONE_2  . . . . . . . . .  	L NEAR	EA17	BIOS
INT_KB_DONE_3  . . . . . . . . .  	L NEAR	EB6B	BIOS
INT_KB_FLAG_CLEAR  . . . . . . .  	L NEAR	EB83	BIOS
INT_KB_FLAG_FOUND  . . . . . . .  	L NEAR	EB4F	BIOS
INT_KB_FLAG_LOOP . . . . . . . .  	L NEAR	EB45	BIOS
INT_KB_FLAG_TOGGLE . . . . . . .  	L NEAR	EB62	BIOS
INT_KB_ICNS_BREAK  . . . . . . .  	L NEAR	EB5A	BIOS
INT_KB_ICNS_MAKE . . . . . . . .  	L NEAR	EB60	BIOS
INT_KB_IS_ALT_000  . . . . . . .  	L NEAR	EAB7	BIOS
INT_KB_IS_FLAG . . . . . . . . .  	N PROC	EB39	BIOS	Length = 0053
INT_KB_MEEP_DONE . . . . . . . .  	L NEAR	EA19	BIOS
INT_KB_NOT_ALT_000 . . . . . . .  	L NEAR	EAC4	BIOS
INT_KB_NOT_ICNS  . . . . . . . .  	L NEAR	EB6E	BIOS
INT_KB_NOT_ICNS_1  . . . . . . .  	L NEAR	EB7A	BIOS
INT_KB_PAUSE_LOOP  . . . . . . .  	L NEAR	EA10	BIOS
INT_KB_PUT_BUFFER_2  . . . . . .  	L NEAR	EB99	BIOS
INT_KB_SET_PAUSE . . . . . . . .  	L NEAR	EA0A	BIOS
INT_KB_TOGGLE_TURBO  . . . . . .  	N PROC	EB2D	BIOS	Length = 000C
INT_LAST . . . . . . . . . . . .  	L BYTE	006B	_BDA
INT_LAST_ABS . . . . . . . . . .  	L BYTE	046B	_BDA_ABS
INT_P0 . . . . . . . . . . . . .  	NUMBER	0020	
INT_RET  . . . . . . . . . . . .  	N PROC	FF53	BIOS	Length = 0001
IOW  . . . . . . . . . . . . . .  		0006	
IO_DELAY_MS  . . . . . . . . . .  	N PROC	E647	BIOS	Length = 002E
IO_DELAY_MS_FDC  . . . . . . . .  	ALIAS	 IO_DELAY_MS		
IO_DELAY_TICK  . . . . . . . . .  	N PROC	E64B	BIOS	Length = 002A
IO_WAIT_LATCH  . . . . . . . . .  	N PROC	E665	BIOS	Length = 0010
IO_WAIT_MS_125 . . . . . . . . .  	N PROC	E643	BIOS	Length = 0032
IO_WAIT_MS_DONE  . . . . . . . .  	L NEAR	E664	BIOS
IO_WAIT_MS_LOOP  . . . . . . . .  	L NEAR	E653	BIOS
IPL  . . . . . . . . . . . . . .  		0000	
IPL_ID . . . . . . . . . . . . .  	L WORD	7DFE	_IPL_SEG
IPL_TOP  . . . . . . . . . . . .  	L BYTE	7C00	_IPL_SEG	Length = 01FE
IRQ0 . . . . . . . . . . . . . .  		0000	
IRQ1 . . . . . . . . . . . . . .  		0001	
IRQ2 . . . . . . . . . . . . . .  		0002	
IRQ3 . . . . . . . . . . . . . .  		0003	
IRQ4 . . . . . . . . . . . . . .  		0004	
IRQ5 . . . . . . . . . . . . . .  		0005	
IRQ6 . . . . . . . . . . . . . .  		0006	
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Symbols-23


IRQ7 . . . . . . . . . . . . . .  		0007	
ISA_TYPE . . . . . . . . . . . .  	L BYTE	FFFE	BIOS
IS_ALPHA . . . . . . . . . . . .  	L NEAR	EA3B	BIOS
IS_ALPHA_DONE  . . . . . . . . .  	L NEAR	EA45	BIOS
IS_TURBO . . . . . . . . . . . .  	NUMBER	-0001	
IVT_08 . . . . . . . . . . . . .  	L WORD	0020	_IVT
IVT_08_SEG . . . . . . . . . . .  	L WORD	0022	_IVT
IVT_09 . . . . . . . . . . . . .  	L WORD	0024	_IVT
IVT_09_SEG . . . . . . . . . . .  	L WORD	0026	_IVT
IVT_10 . . . . . . . . . . . . .  	L WORD	0040	_IVT
IVT_10_SEG . . . . . . . . . . .  	L WORD	0042	_IVT
IVT_18 . . . . . . . . . . . . .  	L WORD	0060	_IVT
IVT_18_SEG . . . . . . . . . . .  	L WORD	0062	_IVT
IVT_1D . . . . . . . . . . . . .  	L DWORD	0074	_IVT
IVT_1E . . . . . . . . . . . . .  	L DWORD	0078	_IVT
IVT_1F . . . . . . . . . . . . .  	L DWORD	007C	_IVT

K1AL . . . . . . . . . . . . . .  		0003	
K1CL . . . . . . . . . . . . . .  		0006	
K1CT . . . . . . . . . . . . . .  		0002	
K1IN . . . . . . . . . . . . . .  		0007	
K1LS . . . . . . . . . . . . . .  		0001	
K1NL . . . . . . . . . . . . . .  		0005	
K1RS . . . . . . . . . . . . . .  		0000	
K1SL . . . . . . . . . . . . . .  		0004	
K2CL . . . . . . . . . . . . . .  		0006	
K2IN . . . . . . . . . . . . . .  		0007	
K2LA . . . . . . . . . . . . . .  		0001	
K2LC . . . . . . . . . . . . . .  		0000	
K2NL . . . . . . . . . . . . . .  		0005	
K2PA . . . . . . . . . . . . . .  		0003	
K2SL . . . . . . . . . . . . . .  		0004	
K2SY . . . . . . . . . . . . . .  		0002	
KBK  . . . . . . . . . . . . . .  		000A	
KBPK . . . . . . . . . . . . . .  		0006	
KBPS . . . . . . . . . . . . . .  		0000	
KBRK . . . . . . . . . . . . . .  		0007	
KBRX . . . . . . . . . . . . . .  		0000	
KBS  . . . . . . . . . . . . . .  		0000	
KBWK . . . . . . . . . . . . . .  		0009	
KBWS . . . . . . . . . . . . . .  		0000	
KB_ALT . . . . . . . . . . . . .  	L BYTE	0019	_BDA
KB_BUF . . . . . . . . . . . . .  	L WORD	001E	_BDA	Length = 0010
KB_BUF_CLEAR . . . . . . . . . .  	N PROC	E95F	BIOS	Length = 0010
KB_BUF_END . . . . . . . . . . .  	L WORD	003E	_BDA
KB_BUF_END_B . . . . . . . . . .  	NUMBER	003E	
KB_BUF_HAS_KEY . . . . . . . . .  	L NEAR	E84F	BIOS
KB_BUF_HD  . . . . . . . . . . .  	L WORD	001A	_BDA
KB_BUF_HD_ABS  . . . . . . . . .  	L WORD	041A	_BDA_ABS
KB_BUF_ST  . . . . . . . . . . .  	L WORD	0080	_BDA
KB_BUF_ST_ABS  . . . . . . . . .  	L WORD	0480	_BDA_ABS
KB_BUF_TL  . . . . . . . . . . .  	L WORD	001C	_BDA
KB_FILTER_SC . . . . . . . . . .  	NUMBER	0000	
KB_FLAGS . . . . . . . . . . . .  	L WORD	0017	_BDA
KB_FLAGS1  . . . . . . . . . . .  	L BYTE	0017	_BDA
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Symbols-24


KB_FLAGS2  . . . . . . . . . . .  	L BYTE	0018	_BDA
KB_GET_READ  . . . . . . . . . .  	L NEAR	E868	BIOS
KB_HAPPY . . . . . . . . . . . .  	L NEAR	E39D	BIOS
KB_HLT_WAIT  . . . . . . . . . .  	NUMBER	0001	
KB_INT_CHAR  . . . . . . . . . .  	L NEAR	EA1E	BIOS
KB_INT_CHECK_FN_KEY  . . . . . .  	L NEAR	E9B6	BIOS
KB_INT_CHECK_FN_KEY_DONE . . . .  	L NEAR	E9DB	BIOS
KB_INT_CHECK_FULL  . . . . . . .  	L NEAR	EA80	BIOS
KB_INT_IS_ALT  . . . . . . . . .  	L NEAR	EA4A	BIOS
KB_INT_IS_ALT_DONE . . . . . . .  	L NEAR	EA59	BIOS
KB_INT_IS_CAPS . . . . . . . . .  	L NEAR	EA36	BIOS
KB_INT_IS_CAPS_DONE  . . . . . .  	L NEAR	EA4A	BIOS
KB_INT_IS_CTRL . . . . . . . . .  	L NEAR	EA59	BIOS
KB_INT_IS_CTRL_DONE  . . . . . .  	L NEAR	EA65	BIOS
KB_INT_IS_NUM  . . . . . . . . .  	L NEAR	E9F4	BIOS
KB_INT_IS_NUM_DONE . . . . . . .  	L NEAR	EA1E	BIOS
KB_INT_IS_PAUSE  . . . . . . . .  	L NEAR	EA65	BIOS
KB_INT_NOT_FLAG  . . . . . . . .  	L NEAR	EA32	BIOS
KB_INT_PRTSC . . . . . . . . . .  	L NEAR	EA61	BIOS
KB_INT_PUT_BUFFER  . . . . . . .  	L NEAR	EA71	BIOS
KB_INT_PUT_BUFFER_2  . . . . . .  	L NEAR	E9D8	BIOS
KB_INT_SHIFT . . . . . . . . . .  	L NEAR	EA25	BIOS
KB_INT_UC  . . . . . . . . . . .  	L NEAR	EA26	BIOS
KB_KEY_STATUS  . . . . . . . . .  	N PROC	E840	BIOS	Length = 0013
KB_KEY_STATUS_DONE . . . . . . .  	L NEAR	E849	BIOS
KB_RESET_TEST  . . . . . . . . .  	L NEAR	E378	BIOS
KB_SHIFT_STATUS  . . . . . . . .  	N PROC	E86F	BIOS	Length = 0005
KB_WAIT_READ . . . . . . . . . .  	N PROC	E853	BIOS	Length = 001C
KB_WAIT_READ_1 . . . . . . . . .  	L NEAR	E855	BIOS
KEE0 . . . . . . . . . . . . . .  		0001	
KEE1 . . . . . . . . . . . . . .  		0000	
KEEN . . . . . . . . . . . . . .  		0004	
KEFI . . . . . . . . . . . . . .  		0006	
KENL . . . . . . . . . . . . . .  		0005	
KERA . . . . . . . . . . . . . .  		0003	
KERC . . . . . . . . . . . . . .  		0002	
KERD . . . . . . . . . . . . . .  		0007	
KEY_FLAG_ON_TBL  . . . . . . . .  	L BYTE	EC12	BIOS
KEY_SCAN_TBL . . . . . . . . . .  	L BYTE	EB9C	BIOS
KEY_SCAN_TBL_HIGH  . . . . . . .  	L BYTE	EC26	BIOS
KLAK . . . . . . . . . . . . . .  		0004	
KLCI . . . . . . . . . . . . . .  		0003	
KLCL . . . . . . . . . . . . . .  		0002	
KLMU . . . . . . . . . . . . . .  		0006	
KLNL . . . . . . . . . . . . . .  		0001	
KLRF . . . . . . . . . . . . . .  		0005	
KLSL . . . . . . . . . . . . . .  		0000	
KLTE . . . . . . . . . . . . . .  		0007	
KPWP . . . . . . . . . . . . . .  		0004	
KPWPX  . . . . . . . . . . . . .  		0000	

LASER_TURBO  . . . . . . . . . .  	NUMBER	01F0	
LBI  . . . . . . . . . . . . . .  		0004	
LBN  . . . . . . . . . . . . . .  		0000	
LCBK . . . . . . . . . . . . . .  		0006	
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Symbols-25


LCDR . . . . . . . . . . . . . .  		0003	
LCEPS  . . . . . . . . . . . . .  		0004	
LCINI  . . . . . . . . . . . . .  		0002	
LCIRQ  . . . . . . . . . . . . .  		0004	
LCLF . . . . . . . . . . . . . .  		0001	
LCOUT  . . . . . . . . . . . . .  		0000	
LCPD . . . . . . . . . . . . . .  		0005	
LCPEN  . . . . . . . . . . . . .  		0003	
LCSB . . . . . . . . . . . . . .  		0002	
LCWLS  . . . . . . . . . . . . .  		0000	
LCX  . . . . . . . . . . . . . .  		0005	
LDR  . . . . . . . . . . . . . .  		0000	
LF . . . . . . . . . . . . . . .  	NUMBER	000A	
LFE  . . . . . . . . . . . . . .  		0003	
LIGHTCYAN  . . . . . . . . . . .  	NUMBER	000B	
LIGHT_PEN  . . . . . . . . . . .  	NUMBER	0001	
LMW  . . . . . . . . . . . . . .  		0000	
LOE  . . . . . . . . . . . . . .  		0001	
LPACK  . . . . . . . . . . . . .  		0006	
LPBZ . . . . . . . . . . . . . .  		0007	
LPE  . . . . . . . . . . . . . .  		0002	
LPIO . . . . . . . . . . . . . .  		0003	
LPOP . . . . . . . . . . . . . .  		0005	
LPSEL  . . . . . . . . . . . . .  		0004	
LPT  . . . . . . . . . . . . . .  		000E	
LPT1 . . . . . . . . . . . . . .  	NUMBER	0378	
LPT2 . . . . . . . . . . . . . .  	NUMBER	0278	
LPTO . . . . . . . . . . . . . .  		0000	
LPT_ADDR . . . . . . . . . . . .  	L WORD	0008	_BDA	Length = 0003
LPT_ADDR_B . . . . . . . . . . .  	NUMBER	0008	
LPT_CHAR . . . . . . . . . . . .  	N PROC	FFB3	BIOS	Length = 0010
LPT_CHAR_EXIT  . . . . . . . . .  	L NEAR	FFC2	BIOS
LPT_CHAR_OUT . . . . . . . . . .  	L NEAR	FFBD	BIOS
LPT_CRLF . . . . . . . . . . . .  	N PROC	FFAA	BIOS	Length = 0019
LPT_DETECT_LOOP  . . . . . . . .  	L NEAR	E32C	BIOS
LPT_LF . . . . . . . . . . . . .  	N PROC	FFB1	BIOS	Length = 0012
LPT_MDA  . . . . . . . . . . . .  	NUMBER	03BC	
LPT_TIME . . . . . . . . . . . .  	L BYTE	0078	_BDA	Length = 0004
LPT_TIME_B . . . . . . . . . . .  	NUMBER	0078	
LPT_TO . . . . . . . . . . . . .  	NUMBER	0014	
LPX  . . . . . . . . . . . . . .  		0001	
LSX  . . . . . . . . . . . . . .  		0007	
LTIM . . . . . . . . . . . . . .  		0003	
LWB  . . . . . . . . . . . . . .  		0000	
L_INT_10_JMP . . . . . . . . . .  	NUMBER	0010	
L_INT_KB_ALT_SKIP  . . . . . . .  	NUMBER	000A	
L_INT_KB_CTRL_ASC_TBL  . . . . .  	NUMBER	000C	
L_INT_KB_CTRL_SCAN_TBL . . . . .  	NUMBER	0006	
L_KEY_FLAG_ON_TBL  . . . . . . .  	NUMBER	0008	
L_KEY_SCAN_TBL . . . . . . . . .  	NUMBER	00AA	
L_POST_ERRORS  . . . . . . . . .  	NUMBER	0006	
L_POST_L . . . . . . . . . . . .  	NUMBER	0002	
L_VECTOR_TABLE . . . . . . . . .  	NUMBER	001F	
L_VID_BDA  . . . . . . . . . . .  	NUMBER	001E	

Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Symbols-26


MAGENTA  . . . . . . . . . . . .  	NUMBER	000D	
MAGIC_WORD . . . . . . . . . . .  	NUMBER	AA55	
MAX_RAM  . . . . . . . . . . . .  	NUMBER	02E0	
MAX_RAM_AUTO . . . . . . . . . .  	NUMBER	0001	
MAX_RAM_AUTO_DONE  . . . . . . .  	L NEAR	E20D	BIOS
MAX_RAM_AUTO_SETUP . . . . . . .  	N PROC	E1FD	BIOS	Length = 0015
MAX_RAM_CGA  . . . . . . . . . .  	NUMBER	02E0	
MAX_RAM_MDA  . . . . . . . . . .  	NUMBER	02C0	
MAX_RAM_PC . . . . . . . . . . .  	NUMBER	0280	
MBRAM  . . . . . . . . . . . . .  		0002	
MBR_CHECK  . . . . . . . . . . .  	NUMBER	0000	
MCLB . . . . . . . . . . . . . .  		0004	
MCO1 . . . . . . . . . . . . . .  		0002	
MCO2 . . . . . . . . . . . . . .  		0003	
MCRX . . . . . . . . . . . . . .  		0005	
MCTS . . . . . . . . . . . . . .  		0004	
MDA_ATTR . . . . . . . . . . . .  	NUMBER	0001	
MDA_COLOR_FIX  . . . . . . . . .  	L NEAR	F71D	BIOS
MDA_CTRL . . . . . . . . . . . .  	NUMBER	03B8	
MDA_MEM  . . . . . . . . . . . .  	L BYTE	0000	_MDA_MEM	Length = 1000
MDA_PEN_RST  . . . . . . . . . .  	NUMBER	03BB	
MDA_STAT . . . . . . . . . . . .  	NUMBER	03BA	
MDBG . . . . . . . . . . . . . .  		0004	
MDBK . . . . . . . . . . . . . .  		0007	
MDFG . . . . . . . . . . . . . .  		0000	
MDIN . . . . . . . . . . . . . .  		0003	
MDSR . . . . . . . . . . . . . .  		0005	
MEEP . . . . . . . . . . . . . .  	N PROC	E8C6	BIOS	Length = 0016
MEEPMEEP . . . . . . . . . . . .  	N PROC	E8C3	BIOS	Length = 0019
MEEPMEEP_Z . . . . . . . . . . .  	N PROC	E8C1	BIOS	Length = 001B
MEEP_DELAY . . . . . . . . . . .  	NUMBER	0040	
MEM_ADDR_ERR . . . . . . . . . .  	L NEAR	E61D	BIOS
MEM_ADDR_LOOP  . . . . . . . . .  	L NEAR	E5FF	BIOS
MEM_ADDR_TEST  . . . . . . . . .  	N PROC	E5F8	BIOS	Length = 0026
MEM_CHECK  . . . . . . . . . . .  	N PROC	E629	BIOS	Length = 000F
MEM_SZ_KB  . . . . . . . . . . .  	L WORD	0013	_BDA
MEM_SZ_PC  . . . . . . . . . . .  	L WORD	0015	_BDA
MEM_TEST . . . . . . . . . . . .  	N PROC	E61E	BIOS	Length = 001A
MEM_TEST_VERIFY  . . . . . . . .  	L NEAR	E630	BIOS
MLSD . . . . . . . . . . . . . .  		0007	
MMW  . . . . . . . . . . . . . .  		0002	
MOVE_COL . . . . . . . . . . . .  	N PROC	F73D	BIOS	Length = 0017
MOVE_COL_SET . . . . . . . . . .  	L NEAR	F749	BIOS
MRI  . . . . . . . . . . . . . .  		0006	

NEXT_COL . . . . . . . . . . . .  	L NEAR	F57A	BIOS
NEXT_COM_PORT  . . . . . . . . .  	L NEAR	E322	BIOS
NEXT_LPT_PORT  . . . . . . . . .  	L NEAR	E34A	BIOS
NEXT_ROM . . . . . . . . . . . .  	L NEAR	E543	BIOS
NIB_HEX  . . . . . . . . . . . .  	N PROC	F79F	BIOS	Length = 0012
NL2_ANY_KEY  . . . . . . . . . .  	L BYTE	E4A4	BIOS
NL_ANY_KEY . . . . . . . . . . .  	L BYTE	E4A5	BIOS
NL_Z . . . . . . . . . . . . . .  	L BYTE	E485	BIOS
NMIE . . . . . . . . . . . . . .  		0007	
NMIX . . . . . . . . . . . . . .  		0000	
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Symbols-27


NMI_ERR_IO . . . . . . . . . . .  	L BYTE	E501	BIOS
NMI_ERR_PAR  . . . . . . . . . .  	L BYTE	E503	BIOS
NMI_R0 . . . . . . . . . . . . .  	NUMBER	00A0	
NMI_RESET  . . . . . . . . . . .  	N PROC	E638	BIOS	Length = 000B
NOTE1  . . . . . . . . . . . . .  	NUMBER	000D	
NOTE2  . . . . . . . . . . . . .  	NUMBER	000E	
NOT_HI_RES . . . . . . . . . . .  	L NEAR	F53E	BIOS
NO_COM_PORT  . . . . . . . . . .  	L NEAR	E316	BIOS
NO_GAME_PORT . . . . . . . . . .  	L NEAR	E2FE	BIOS
NO_LPT_PORT  . . . . . . . . . .  	L NEAR	E340	BIOS

O2CMD  . . . . . . . . . . . . .  		0005	
O2L  . . . . . . . . . . . . . .  		0000	
O2X  . . . . . . . . . . . . . .  		0003	
O3D3 . . . . . . . . . . . . . .  		0003	
O3D7 . . . . . . . . . . . . . .  		0007	
O3P  . . . . . . . . . . . . . .  		0002	
O3RR . . . . . . . . . . . . . .  		0000	
OEM_FONT . . . . . . . . . . . .  	NUMBER	0000	
OPT_ROM_END  . . . . . . . . . .  	NUMBER	FE00	
OUTLN_SZ . . . . . . . . . . . .  	N PROC	F754	BIOS	Length = 000C
OUT_CHAR . . . . . . . . . . . .  	N PROC	F7A6	BIOS	Length = 000B
OUT_DECU . . . . . . . . . . . .  	N PROC	F768	BIOS	Length = 0017
OUT_DECU_DONE  . . . . . . . . .  	L NEAR	F777	BIOS
OUT_DECU_R . . . . . . . . . . .  	L NEAR	F76B	BIOS
OUT_SZ . . . . . . . . . . . . .  	N PROC	F72E	BIOS	Length = 000F
OUT_SZ_ATTR  . . . . . . . . . .  	N PROC	F71C	BIOS	Length = 0021
OUT_SZ_ATTR_SET  . . . . . . . .  	L NEAR	F728	BIOS
OUT_SZ_DONE  . . . . . . . . . .  	L NEAR	F73B	BIOS
OUT_SZ_LOOP  . . . . . . . . . .  	L NEAR	F731	BIOS
O_INT_1D_40  . . . . . . . . . .  	NUMBER	0000	
O_INT_1D_80  . . . . . . . . . .  	NUMBER	0010	
O_INT_1D_GFX . . . . . . . . . .  	NUMBER	0020	
O_INT_1D_MDA . . . . . . . . . .  	NUMBER	0030	

PBIO . . . . . . . . . . . . . .  		0005	
PBKB . . . . . . . . . . . . . .  		0007	
PBKC . . . . . . . . . . . . . .  		0006	
PBPC . . . . . . . . . . . . . .  		0004	
PBSP . . . . . . . . . . . . . .  		0001	
PBST . . . . . . . . . . . . . .  		0000	
PBSW . . . . . . . . . . . . . .  		0003	
PBTB . . . . . . . . . . . . . .  		0002	
PC2CI  . . . . . . . . . . . . .  		0004	
PC2IE  . . . . . . . . . . . . .  		0006	
PC2PE  . . . . . . . . . . . . .  		0007	
PC2T2  . . . . . . . . . . . . .  		0005	
PCCI . . . . . . . . . . . . . .  		0004	
PCDRV  . . . . . . . . . . . . .  		0002	
PCFD . . . . . . . . . . . . . .  		0000	
PCFP . . . . . . . . . . . . . .  		0001	
PCIE . . . . . . . . . . . . . .  		0006	
PCMB . . . . . . . . . . . . . .  		0002	
PCPE . . . . . . . . . . . . . .  		0007	
PCT2 . . . . . . . . . . . . . .  		0005	
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Symbols-28


PCVID  . . . . . . . . . . . . .  		0000	
PCWBCD . . . . . . . . . . . . .  		0000	
PCWM . . . . . . . . . . . . . .  		0001	
PCWRW  . . . . . . . . . . . . .  		0004	
PCWSC  . . . . . . . . . . . . .  		0006	
PDMA . . . . . . . . . . . . . .  		000A	
PFDC . . . . . . . . . . . . . .  		000C	
PFSK . . . . . . . . . . . . . .  		000B	
PFXX . . . . . . . . . . . . . .  		0008	
PIC_INT_FAIL . . . . . . . . . .  	L NEAR	E190	BIOS
PIC_INT_PASS . . . . . . . . . .  	L NEAR	E1B4	BIOS
PIC_INT_TEST . . . . . . . . . .  	L NEAR	E196	BIOS
PIC_REG_PASS . . . . . . . . . .  	L NEAR	E192	BIOS
PIC_VECT_TMP_LOOP  . . . . . . .  	L NEAR	E19A	BIOS
PIT_CH0  . . . . . . . . . . . .  	NUMBER	0040	
PIT_CH1  . . . . . . . . . . . .  	NUMBER	0041	
PIT_CH2  . . . . . . . . . . . .  	NUMBER	0042	
PIT_CTRL . . . . . . . . . . . .  	NUMBER	0043	
PKEY . . . . . . . . . . . . . .  		000D	
PKI  . . . . . . . . . . . . . .  		000E	
PMEM . . . . . . . . . . . . . .  		0009	
PORT_COUNT_LOOP  . . . . . . . .  	L NEAR	F6BB	BIOS
PORT_COUNT_NONE  . . . . . . . .  	L NEAR	F6C9	BIOS
PORT_TEST  . . . . . . . . . . .  	N PROC	E7EB	BIOS	Length = 002F
PORT_TEST_DONE . . . . . . . . .  	L NEAR	E819	BIOS
POST_286 . . . . . . . . . . . .  	L BYTE	E4E2	BIOS
POST_BANNER  . . . . . . . . . .  	NUMBER	0001	
POST_BOOT  . . . . . . . . . . .  	L BYTE	E8F6	BIOS
POST_BOOT_TYPE . . . . . . . . .  	N PROC	E3B0	BIOS	Length = 0017
POST_BOOT_TYPE_OUT . . . . . . .  	L NEAR	E3C1	BIOS
POST_CARD  . . . . . . . . . . .  	NUMBER	0000	
POST_CARD_PORT . . . . . . . . .  	NUMBER	0080	
POST_CGA . . . . . . . . . . . .  	L BYTE	E822	BIOS
POST_CHS . . . . . . . . . . . .  	L BYTE	F8C3	BIOS
POST_CLR_COLD  . . . . . . . . .  	ALIAS	 BLUE		
POST_CLR_GB  . . . . . . . . . .  	ALIAS	 GRAY		
POST_CLR_TXT . . . . . . . . . .  	ALIAS	 CYAN		
POST_CLR_VAL1  . . . . . . . . .  	ALIAS	 GREEN		
POST_CLR_VAL2  . . . . . . . . .  	ALIAS	 YELLOW		
POST_CLR_WARM  . . . . . . . . .  	ALIAS	 DARKRED		
POST_CLS . . . . . . . . . . . .  	NUMBER	0000	
POST_COL . . . . . . . . . . . .  	N PROC	F6D1	BIOS	Length = 0083
POST_COLD  . . . . . . . . . . .  	L BYTE	E900	BIOS
POST_COL_LBL_W . . . . . . . . .  	NUMBER	0007	
POST_COL_PAD . . . . . . . . . .  	NUMBER	0004	
POST_COL_VT  . . . . . . . . . .  	NUMBER	0009	
POST_COL_W . . . . . . . . . . .  	NUMBER	0006	
POST_COM . . . . . . . . . . . .  	L BYTE	E4EE	BIOS
POST_CONFIG  . . . . . . . . . .  	NUMBER	0001	
POST_CPU . . . . . . . . . . . .  	L BYTE	E4BC	BIOS
POST_CPU_TEST  . . . . . . . . .  	L NEAR	E05D	BIOS
POST_DETECT_COM  . . . . . . . .  	L NEAR	E2FE	BIOS
POST_DETECT_GAM  . . . . . . . .  	L NEAR	E2F3	BIOS
POST_DETECT_LPT  . . . . . . . .  	L NEAR	E324	BIOS
POST_DETECT_PORTS  . . . . . . .  	N PROC	E2E3	BIOS	Length = 0069
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Symbols-29


POST_EGA . . . . . . . . . . . .  	L BYTE	E81E	BIOS
POST_END_COL . . . . . . . . . .  	N PROC	F713	BIOS	Length = 002A
POST_END_COL_NL  . . . . . . . .  	N PROC	F70E	BIOS	Length = 0005
POST_END_COL_STR . . . . . . . .  	N PROC	F716	BIOS	Length = 0027
POST_ERR . . . . . . . . . . . .  	L BYTE	E905	BIOS
POST_ERROR . . . . . . . . . . .  	L NEAR	E435	BIOS
POST_ERRORS  . . . . . . . . . .  	L WORD	E922	BIOS
POST_ERROR_MSG . . . . . . . . .  	N PROC	E92E	BIOS	Length = 0016
POST_ERROR_MSG_EXIT  . . . . . .  	L NEAR	E943	BIOS
POST_ERROR_MSG_LOOP  . . . . . .  	L NEAR	E934	BIOS
POST_ERROR_MSG_NEXT  . . . . . .  	L NEAR	E941	BIOS
POST_ERR_ERR . . . . . . . . . .  	L BYTE	E90C	BIOS
POST_ERR_MSG . . . . . . . . . .  	N PROC	E905	BIOS	Length = 003F
POST_ERR_PDMA  . . . . . . . . .  	L BYTE	E91E	BIOS
POST_ERR_PFDC  . . . . . . . . .  	L BYTE	E91A	BIOS
POST_ERR_PKEY  . . . . . . . . .  	L BYTE	E916	BIOS
POST_ERR_PKI . . . . . . . . . .  	L BYTE	E913	BIOS
POST_ERR_WAIT  . . . . . . . . .  	NUMBER	0001	
POST_FDD . . . . . . . . . . . .  	L BYTE	E4F2	BIOS
POST_FD_COUNT  . . . . . . . . .  	NUMBER	0001	
POST_FLAG_DONE . . . . . . . . .  	L NEAR	E099	BIOS
POST_FPU . . . . . . . . . . . .  	L BYTE	E4C5	BIOS
POST_GLADOS  . . . . . . . . . .  	NUMBER	0000	
POST_HD  . . . . . . . . . . . .  	L BYTE	E4CE	BIOS
POST_HDD . . . . . . . . . . . .  	L BYTE	E4F6	BIOS
POST_HD_CHECK  . . . . . . . . .  	NUMBER	0001	
POST_HD_COUNT  . . . . . . . . .  	NUMBER	0001	
POST_HD_PARMS  . . . . . . . . .  	NUMBER	0001	
POST_KB_RESET  . . . . . . . . .  	N PROC	E34C	BIOS	Length = 0061
POST_K_UNIT  . . . . . . . . . .  	TEXT  'KB'		
POST_L . . . . . . . . . . . . .  	TEXT  ' [ '		
POST_LPT . . . . . . . . . . . .  	L BYTE	E4EA	BIOS
POST_LSEP  . . . . . . . . . . .  	L BYTE	E4FA	BIOS
POST_MDA . . . . . . . . . . . .  	L BYTE	E826	BIOS
POST_MEMORY  . . . . . . . . . .  	L BYTE	E4D4	BIOS
POST_M_UNIT  . . . . . . . . . .  	TEXT  'MB'		
POST_NONE  . . . . . . . . . . .  	L BYTE	FF4C	BIOS
POST_OK  . . . . . . . . . . . .  	L NEAR	E455	BIOS
POST_OPT_ROM . . . . . . . . . .  	NUMBER	0001	
POST_QUIET . . . . . . . . . . .  	NUMBER	0000	
POST_R . . . . . . . . . . . . .  	TEXT  ' ]'		
POST_RSEP  . . . . . . . . . . .  	L BYTE	E4FE	BIOS
POST_START_COL_1 . . . . . . . .  	N PROC	F6D5	BIOS	Length = 0027
POST_START_COL_2 . . . . . . . .  	N PROC	F6FC	BIOS	Length = 0012
POST_START_COL_2_40  . . . . . .  	L NEAR	F6D1	BIOS
POST_START_COL_START . . . . . .  	L NEAR	F6D8	BIOS
POST_STRINGS . . . . . . . . . .  	N PROC	E4BC	BIOS	Length = 004F
POST_SYS_CONFIG  . . . . . . . .  	N PROC	F5FD	BIOS	Length = 00D4
POST_SYS_VIDEO . . . . . . . . .  	N PROC	F5FD	BIOS	Length = 004E
POST_SYS_VIDEO_DONE  . . . . . .  	L NEAR	F645	BIOS
POST_TAB_COL . . . . . . . . . .  	NUMBER	0020	
POST_TAB_COL_I . . . . . . . . .  	NUMBER	0013	
POST_TEST_CHK_ROM  . . . . . . .  	NUMBER	0001	
POST_TEST_DMA  . . . . . . . . .  	NUMBER	0001	
POST_TEST_DMA_TC0  . . . . . . .  	NUMBER	0001	
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Symbols-30


POST_TEST_FD . . . . . . . . . .  	NUMBER	0001	
POST_TEST_INST . . . . . . . . .  	NUMBER	0000	
POST_TEST_KB . . . . . . . . . .  	NUMBER	0001	
POST_TEST_KEY  . . . . . . . . .  	NUMBER	0001	
POST_TEST_PIC_INT  . . . . . . .  	NUMBER	0001	
POST_TEST_PIC_REG  . . . . . . .  	NUMBER	0001	
POST_TEST_PIT_1  . . . . . . . .  	NUMBER	0001	
POST_TEST_SEEK . . . . . . . . .  	NUMBER	0000	
POST_THEME . . . . . . . . . . .  	NUMBER	0001	
POST_V20 . . . . . . . . . . . .  	L BYTE	E4E6	BIOS
POST_VGA . . . . . . . . . . . .  	L BYTE	E81A	BIOS
POST_VIDEO . . . . . . . . . . .  	L BYTE	FF46	BIOS
POST_VIDEO_TYPE  . . . . . . . .  	NUMBER	0001	
POST_WARM  . . . . . . . . . . .  	L BYTE	E8FB	BIOS
POST_WARM_COLD . . . . . . . . .  	NUMBER	0001	
POWER_ON . . . . . . . . . . . .  	F PROC	FFF0	BIOS	Length = 0010
PPAD . . . . . . . . . . . . . .  		0004	
PPAM . . . . . . . . . . . . . .  		0005	
PPBD . . . . . . . . . . . . . .  		0001	
PPBM . . . . . . . . . . . . . .  		0002	
PPCL . . . . . . . . . . . . . .  		0000	
PPCU . . . . . . . . . . . . . .  		0003	
PPEN . . . . . . . . . . . . . .  		0007	
PPI_A  . . . . . . . . . . . . .  	NUMBER	0060	
PPI_B  . . . . . . . . . . . . .  	NUMBER	0061	
PPI_B_BOOT . . . . . . . . . . .  	NUMBER	00A8	
PPI_C  . . . . . . . . . . . . .  	NUMBER	0062	
PPI_CW . . . . . . . . . . . . .  	NUMBER	0063	
PTBD . . . . . . . . . . . . . .  		0002	
PTRSCN_ST  . . . . . . . . . . .  	L BYTE	0000	_DOS_DAT

QUARTER  . . . . . . . . . . . .  	NUMBER	00AC	

RAM_DIGITS . . . . . . . . . . .  	NUMBER	0003	
RAM_PARITY . . . . . . . . . . .  	NUMBER	0000	
RAM_TEST . . . . . . . . . . . .  	NUMBER	731D	
RAM_TEST_1 . . . . . . . . . . .  	NUMBER	95A5	
RAM_TEST_2 . . . . . . . . . . .  	NUMBER	731D	
RAM_TEST_LONG  . . . . . . . . .  	NUMBER	0000	
RANDOM_TAGLINE . . . . . . . . .  	NUMBER	0001	
RED  . . . . . . . . . . . . . .  	NUMBER	000C	
REL_DATE . . . . . . . . . . . .  	L BYTE	FFF5	BIOS
RESET_PPI  . . . . . . . . . . .  	L NEAR	E0A8	BIOS
RESET_VIDEO  . . . . . . . . . .  	L NEAR	E24A	BIOS
RESET_VIDEO_DONE . . . . . . . .  	L NEAR	E24C	BIOS
ROM_CHECKSUM . . . . . . . . . .  	N PROC	E54E	BIOS	Length = 0014
ROM_INIT_SP  . . . . . . . . . .  	L WORD	0069	_BDA
ROM_INIT_SS  . . . . . . . . . .  	L WORD	0067	_BDA
ROM_SCAN_DONE  . . . . . . . . .  	L NEAR	E54A	BIOS
ROM_SCAN_POST  . . . . . . . . .  	N PROC	F936	BIOS	Length = 0069
ROM_SCAN_POST_CHK  . . . . . . .  	L NEAR	F975	BIOS
ROM_SCAN_POST_DONE . . . . . . .  	L NEAR	F96E	BIOS
ROM_SCAN_POST_EXIT . . . . . . .  	L NEAR	F971	BIOS
ROPC . . . . . . . . . . . . . .  		0000	
RTC_DATA . . . . . . . . . . . .  	L WORD	00EE	_BDA
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Symbols-31


RTC_WAIT . . . . . . . . . . . .  	L BYTE	00A0	_BDA
RTS  . . . . . . . . . . . . . .  		0001	

SETTINGS_5160  . . . . . . . . .  	L NEAR	E1E5	BIOS
SETTINGS_DONE  . . . . . . . . .  	L NEAR	E212	BIOS
SETTINGS_SAVE  . . . . . . . . .  	L NEAR	E21D	BIOS
SET_CURSOR . . . . . . . . . . .  	N PROC	F03E	BIOS	Length = 0007
SFNM . . . . . . . . . . . . . .  		0004	
SHOW_CURSOR  . . . . . . . . . .  	N PROC	F035	BIOS	Length = 0010
SHOW_DISK_PARAMS . . . . . . . .  	N PROC	F863	BIOS	Length = 0064
SHOW_DISK_PARAMS_DONE  . . . . .  	L NEAR	F8C0	BIOS
SHOW_PORT_COUNT  . . . . . . . .  	N PROC	F6B9	BIOS	Length = 0018
SMCH . . . . . . . . . . . . . .  		0000	
SMCLR  . . . . . . . . . . . . .  		0002	
SNGL . . . . . . . . . . . . . .  		0001	
SPACE  . . . . . . . . . . . . .  	N PROC	F760	BIOS	Length = 0008
SQUARE . . . . . . . . . . . . .  	NUMBER	00FE	
ST0CHK . . . . . . . . . . . . .  		0004	
ST0CS  . . . . . . . . . . . . .  		0006	
ST0DRV . . . . . . . . . . . . .  		0000	
ST0HD  . . . . . . . . . . . . .  		0002	
ST0NR  . . . . . . . . . . . . .  		0003	
ST0SK  . . . . . . . . . . . . .  		0005	
STACK_TOP  . . . . . . . . . . .  	L WORD	0100	_BOOT_STACK
STRINGS  . . . . . . . . . . . .  	N PROC	E485	BIOS	Length = 0086
SW1_FLP  . . . . . . . . . . . .  	NUMBER	00C0	
SYN  . . . . . . . . . . . . . .  	NUMBER	0016	
S_OPT_CHK  . . . . . . . . . . .  	L BYTE	F993	BIOS
S_OPT_K  . . . . . . . . . . . .  	L BYTE	F99B	BIOS
S_OPT_ROM  . . . . . . . . . . .  	L BYTE	F98A	BIOS
S_OPT_SIZE . . . . . . . . . . .  	L BYTE	F98E	BIOS

TAG0 . . . . . . . . . . . . . .  	L BYTE	E00E	BIOS
TAG1 . . . . . . . . . . . . . .  	L BYTE	F8E6	BIOS
TAG2 . . . . . . . . . . . . . .  	L BYTE	F8FB	BIOS
TAG3 . . . . . . . . . . . . . .  	L BYTE	F911	BIOS
TAGS . . . . . . . . . . . . . .  	L WORD	F92E	BIOS
TC0  . . . . . . . . . . . . . .  		0000	
TC1  . . . . . . . . . . . . . .  		0001	
TC2  . . . . . . . . . . . . . .  		0002	
TC3  . . . . . . . . . . . . . .  		0003	
TD_MEM . . . . . . . . . . . . .  	NUMBER	00E0	
TD_TURBO . . . . . . . . . . . .  	NUMBER	0090	
TD_WS  . . . . . . . . . . . . .  	NUMBER	0070	
THRE . . . . . . . . . . . . . .  		0005	
TIMER  . . . . . . . . . . . . .  	L 	006C	_BDA
TOGGLE_TURBO . . . . . . . . . .  	N PROC	E274	BIOS	Length = 0016
TOGGLE_TURBO_CURSOR  . . . . . .  	L NEAR	E285	BIOS
TOGGLE_TURBO_DONE  . . . . . . .  	L NEAR	E288	BIOS
TOP_BANNER . . . . . . . . . . .  	L BYTE	E000	BIOS
TRY_INT_18 . . . . . . . . . . .  	L NEAR	E476	BIOS
TSRE . . . . . . . . . . . . . .  		0006	
TURBO  . . . . . . . . . . . . .  		0003	
TURBO_NONE . . . . . . . . . . .  	NUMBER	0000	
TURBO_REV  . . . . . . . . . . .  	NUMBER	0002	
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Symbols-32


TURBO_STD  . . . . . . . . . . .  	NUMBER	0001	
TURBO_TYPE . . . . . . . . . . .  	NUMBER	0001	

UM82_SPEED . . . . . . . . . . .  	NUMBER	00C0	
UM82_STATUS  . . . . . . . . . .  	NUMBER	00E0	
UMW  . . . . . . . . . . . . . .  		0004	
UNITS_IEC  . . . . . . . . . . .  	NUMBER	0000	
UNSAFE_FLOPPY  . . . . . . . . .  	NUMBER	0000	
UNSAFE_FLP_DIV . . . . . . . . .  	TEXT  3/10		
UNSAFE_REFRESH . . . . . . . . .  	NUMBER	0000	
UPM  . . . . . . . . . . . . . .  		0000	

V20  . . . . . . . . . . . . . .  		0002	
V40_WCR1 . . . . . . . . . . . .  	NUMBER	FFF5	
V40_WCR2 . . . . . . . . . . . .  	NUMBER	FFF6	
VBG  . . . . . . . . . . . . . .  		0004	
VECTOR_TABLE . . . . . . . . . .  	N PROC	FEE3	BIOS	Length = 0040
VER  . . . . . . . . . . . . . .  	L BYTE	FFE0	BIOS
VER_DATE . . . . . . . . . . . .  	TEXT  '09/28/24'		
VER_NAME . . . . . . . . . . . .  	TEXT  'GLaBIOS'		
VER_NUM  . . . . . . . . . . . .  	TEXT  '0.2.6'		
VF3_OPC  . . . . . . . . . . . .  		0003	
VF3_SRC  . . . . . . . . . . . .  		0000	
VF4_DST  . . . . . . . . . . . .  		0003	
VF4_OPC  . . . . . . . . . . . .  		0006	
VF4_SRC  . . . . . . . . . . . .  		0000	
VFB  . . . . . . . . . . . . . .  		0000	
VID  . . . . . . . . . . . . . .  		0004	
VID_BIOS_SZ  . . . . . . . . . .  	L BYTE	0002	_VID_BIOS
VID_BUF_SZ . . . . . . . . . . .  	L WORD	004C	_BDA
VID_CGA40  . . . . . . . . . . .  	NUMBER	0001	
VID_CGA80  . . . . . . . . . . .  	NUMBER	0002	
VID_COLOR  . . . . . . . . . . .  	L BYTE	0066	_BDA
VID_COLS . . . . . . . . . . . .  	L WORD	004A	_BDA
VID_CURS_POS . . . . . . . . . .  	L WORD	0050	_BDA	Length = 0008
VID_CURS_TYPE  . . . . . . . . .  	L WORD	0060	_BDA
VID_DEF_COLS . . . . . . . . . .  	NUMBER	0050	
VID_DEF_ROWS . . . . . . . . . .  	NUMBER	0018	
VID_MDA  . . . . . . . . . . . .  	NUMBER	0003	
VID_MEM_SEG  . . . . . . . . . .  	L WORD	00EA	_BDA
VID_MEM_SEG_DW . . . . . . . . .  	L DWORD	00E8	_BDA
VID_MN . . . . . . . . . . . . .  	L WORD	0000	_VID_BIOS
VID_MODE . . . . . . . . . . . .  	L BYTE	0049	_BDA
VID_MODE_OK  . . . . . . . . . .  	L NEAR	E240	BIOS
VID_MODE_REG . . . . . . . . . .  	L BYTE	0065	_BDA
VID_MODE_TBL . . . . . . . . . .  	L BYTE	E82B	BIOS
VID_PAGE . . . . . . . . . . . .  	L BYTE	0062	_BDA
VID_PORT . . . . . . . . . . . .  	L WORD	0063	_BDA
VID_ROM  . . . . . . . . . . . .  	NUMBER	0000	
VID_SEG  . . . . . . . . . . . .  	L WORD	004E	_BDA
VID_SP . . . . . . . . . . . . .  	NUMBER	0020	
VID_VEC  . . . . . . . . . . . .  	L WORD	0003	_VID_BIOS
VL . . . . . . . . . . . . . . .  	NUMBER	00B3	
VRW  . . . . . . . . . . . . . .  		0003	
VSHS . . . . . . . . . . . . . .  		0000	
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Symbols-33


VSPE . . . . . . . . . . . . . .  		0002	
VSPT . . . . . . . . . . . . . .  		0001	
VSVS . . . . . . . . . . . . . .  		0003	
VSX  . . . . . . . . . . . . . .  		0004	

WARM . . . . . . . . . . . . . .  		000F	
WARM_BOOT  . . . . . . . . . . .  	NUMBER	1234	
WARM_BOOT_MEM  . . . . . . . . .  	NUMBER	4321	
WARM_BOOT_SUS  . . . . . . . . .  	NUMBER	5678	
WARM_BOOT_TEST . . . . . . . . .  	NUMBER	9ABC	
WARM_ENABLE  . . . . . . . . . .  	NUMBER	0001	
WARM_FLAG  . . . . . . . . . . .  	L WORD	0072	_BDA
WARM_FLAG_ABS  . . . . . . . . .  	L WORD	0472	_BDA_ABS
WB_LOW_CHECK_OK  . . . . . . . .  	L NEAR	E80B	BIOS
WB_READ_LOOP . . . . . . . . . .  	L NEAR	E806	BIOS
WB_WRITE_1 . . . . . . . . . . .  	L NEAR	E7F1	BIOS
WB_WRITE_LOOP  . . . . . . . . .  	L NEAR	E7F7	BIOS
WHITE  . . . . . . . . . . . . .  	NUMBER	000F	
WORD_HEX . . . . . . . . . . . .  	N PROC	F78B	BIOS	Length = 0026

X1 . . . . . . . . . . . . . . .  		000D	

YELLOW . . . . . . . . . . . . .  	NUMBER	000E	

ZERO_ALL_RAM . . . . . . . . . .  	L NEAR	E59E	BIOS
ZERO_ALL_RAM_1 . . . . . . . . .  	L NEAR	E5BA	BIOS
ZERO_ALL_START . . . . . . . . .  	L NEAR	E5BC	BIOS

??0001 . . . . . . . . . . . . .  	L NEAR	E101	BIOS
??0002 . . . . . . . . . . . . .  	L NEAR	E103	BIOS
??0003 . . . . . . . . . . . . .  	L NEAR	E13B	BIOS
??0004 . . . . . . . . . . . . .  	L NEAR	E13D	BIOS
??0005 . . . . . . . . . . . . .  	L NEAR	E14F	BIOS
??0006 . . . . . . . . . . . . .  	L NEAR	E151	BIOS
??0007 . . . . . . . . . . . . .  	L NEAR	E161	BIOS
??0008 . . . . . . . . . . . . .  	L NEAR	E163	BIOS
??0009 . . . . . . . . . . . . .  	L NEAR	E16B	BIOS
??000A . . . . . . . . . . . . .  	L NEAR	E16D	BIOS
??000B . . . . . . . . . . . . .  	L NEAR	E1A9	BIOS
??000C . . . . . . . . . . . . .  	NUMBER	0030	
??000D . . . . . . . . . . . . .  	NUMBER	0004	
??000E . . . . . . . . . . . . .  	WORD	0010	_BDA
??000F . . . . . . . . . . . . .  	NUMBER	02E3	
??0011 . . . . . . . . . . . . .  	L NEAR	E37A	BIOS
??0012 . . . . . . . . . . . . .  	L NEAR	E387	BIOS
??0013 . . . . . . . . . . . . .  	L NEAR	E391	BIOS
??0014 . . . . . . . . . . . . .  	L NEAR	E428	BIOS
??0015 . . . . . . . . . . . . .  	NUMBER	0000	
??0016 . . . . . . . . . . . . .  	L NEAR	E471	BIOS
??0019 . . . . . . . . . . . . .  	L NEAR	E7FA	BIOS
??001B . . . . . . . . . . . . .  	L NEAR	E88C	BIOS
??001C . . . . . . . . . . . . .  	L NEAR	E88E	BIOS
??001D . . . . . . . . . . . . .  	L NEAR	E890	BIOS
??001E . . . . . . . . . . . . .  	L NEAR	E897	BIOS
??001F . . . . . . . . . . . . .  	L NEAR	E899	BIOS
Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Symbols-34


??0020 . . . . . . . . . . . . .  	L NEAR	E89B	BIOS
??0021 . . . . . . . . . . . . .  	L NEAR	E8D0	BIOS
??0022 . . . . . . . . . . . . .  	L NEAR	E8D7	BIOS
??0023 . . . . . . . . . . . . .  	NUMBER	0001	
??0028 . . . . . . . . . . . . .  	L NEAR	F02A	BIOS
??002B . . . . . . . . . . . . .  	NUMBER	0030	
??002C . . . . . . . . . . . . .  	NUMBER	0004	
??002D . . . . . . . . . . . . .  	WORD	0010	_BDA
??002E . . . . . . . . . . . . .  	NUMBER	00C0	
??002F . . . . . . . . . . . . .  	NUMBER	0002	
??0030 . . . . . . . . . . . . .  	WORD	0011	_BDA
??0031 . . . . . . . . . . . . .  	NUMBER	000E	
??0032 . . . . . . . . . . . . .  	NUMBER	0001	
??0033 . . . . . . . . . . . . .  	WORD	0011	_BDA
??0035 . . . . . . . . . . . . .  	NUMBER	0001	
@CPU . . . . . . . . . . . . . .  	TEXT  0101h		
@FILENAME  . . . . . . . . . . .  	TEXT  GLABIOS		
@VERSION . . . . . . . . . . . .  	TEXT  510		
_AH  . . . . . . . . . . . . . .  	NUMBER	0004	
_AL  . . . . . . . . . . . . . .  	NUMBER	0000	
_AX  . . . . . . . . . . . . . .  	NUMBER	0008	
_BDA_SEG . . . . . . . . . . . .  	NUMBER	0400	
_BH  . . . . . . . . . . . . . .  	NUMBER	0007	
_BIOS_TOP  . . . . . . . . . . .  	L WORD	E000	_BIOS
_BL  . . . . . . . . . . . . . .  	NUMBER	0003	
_BOOT  . . . . . . . . . . . . .  	L WORD	E05B	_BIOS
_BP  . . . . . . . . . . . . . .  	NUMBER	000D	
_BX  . . . . . . . . . . . . . .  	NUMBER	000B	
_CH  . . . . . . . . . . . . . .  	NUMBER	0005	
_CL  . . . . . . . . . . . . . .  	NUMBER	0001	
_CX  . . . . . . . . . . . . . .  	NUMBER	0009	
_DH  . . . . . . . . . . . . . .  	NUMBER	0006	
_DI  . . . . . . . . . . . . . .  	NUMBER	000F	
_DL  . . . . . . . . . . . . . .  	NUMBER	0002	
_DX  . . . . . . . . . . . . . .  	NUMBER	000A	
_FDC_LAST_ST . . . . . . . . . .  	TEXT  [DI][FDC_LAST_ST-FD_LAST_OP]		
_FD_CAL_ST . . . . . . . . . . .  	TEXT  BYTE PTR [DI][FD_CAL_ST-FD_LAST_OP]		
_FD_LAST_OP  . . . . . . . . . .  	TEXT  BYTE PTR [DI]		
_FD_MEDIA_ST . . . . . . . . . .  	TEXT  BYTE PTR [DI][FD_MEDIA_ST-FD_LAST_OP]		
_FD_MOTOR_ST . . . . . . . . . .  	TEXT  BYTE PTR [DI][FD_MOTOR_ST-FD_LAST_OP]		
_FD_TIMER  . . . . . . . . . . .  	TEXT  BYTE PTR [DI][TIMER-FD_LAST_OP]		
_FD_TRACK  . . . . . . . . . . .  	TEXT  BYTE PTR [DI][FD_TRACK-FD_LAST_OP]		
_KB_FLAGS1 . . . . . . . . . . .  	TEXT  BYTE PTR[BX][-1]		
_KB_FLAGS2 . . . . . . . . . . .  	TEXT  BYTE PTR[BX]		
_POWER_ON  . . . . . . . . . . .  	L WORD	FFF0	_BIOS
_SI  . . . . . . . . . . . . . .  	NUMBER	000E	
_SP  . . . . . . . . . . . . . .  	NUMBER	000C	
__POWER_ON . . . . . . . . . . .  	L FAR 	0000	RESET

Microsoft (R) Macro Assembler Version 5.10                  10/15/24 15:11:5
GLaBIOS                                                     Symbols-35



  12532 Source  Lines
  14138 Total   Lines
   1522 Symbols

  46474 + 311893 Bytes symbol space free

      1 Warning Errors
      0 Severe  Errors
