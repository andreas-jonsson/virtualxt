<!DOCTYPE html PUBLIC "-//W3O//DTD W3 HTML 3.0//EN">
<html class="gr__dsearls_org"><head>
<meta http-equiv="content-type" content="text/html; charset=windows-1252">

<title>8086 instructions</title>

<meta name="description" content="emu8086 reference and description">

<meta name="keywords" content="emu8086, reference, description, hints">

</head>

<body data-gr-c-s-loaded="true" vlink="#007099" text="#000000" link="#0000FF" bgcolor="#FFFFFF" alink="#FF0000">


<font size="3" face="Verdana">

<font size="+2">
<b>Complete 8086 instruction set</b>
</font>

<font size="-1">
<br>
&nbsp;  &nbsp;  by <a href="mailto:emu8086@yahoo.com">Alexander Popov</a>
<br><br>
</font>

<!-- 114 instructions -->

<hr>
<br>
Quick reference:<br><br>
<font face="Fixedsys">

<table width="100%" border="0">
<tbody><tr>

<td>
<a href="#AAA">AAA</a>  <br>
<a href="#AAD">AAD</a>  <br>
<a href="#AAM">AAM</a>  <br>
<a href="#AAS">AAS</a>  <br>
<a href="#ADC">ADC</a>  <br>
<a href="#ADD">ADD</a>  <br>
<a href="#AND">AND</a>  <br>

<a href="#CALL">CALL</a>  <br>
<a href="#CBW">CBW</a>  <br>
<a href="#CLC">CLC</a>  <br>
<a href="#CLD">CLD</a>  <br>
<a href="#CLI">CLI</a>  <br>
<a href="#CMC">CMC</a>  <br>
<a href="#CMP">CMP</a>  <br>
</td><td>
<a href="#CMPSB">CMPSB</a>  <br>
<a href="#CMPSW">CMPSW</a>  <br>
<a href="#CWD">CWD</a>  <br>
<a href="#DAA">DAA</a>  <br>
<a href="#DAS">DAS</a>  <br>
<a href="#DEC">DEC</a>  <br>
<a href="#DIV">DIV</a>  <br>

<a href="#IDIV">IDIV</a>  <br>
<a href="#IMUL">IMUL</a>  <br>

<a href="#IN">IN</a>  <br>

<a href="#INC">INC</a>  <br>
<a href="#INT">INT</a>  <br>
<a href="#INTO">INTO</a>  <br>
<a href="#IRET">IRET</a>  <br>
<a href="#JA">JA</a>  <br>
</td><td>
<a href="#JAE">JAE</a>  <br>
<a href="#JB">JB</a>  <br>
<a href="#JBE">JBE</a>  <br>
<a href="#JC">JC</a>  <br>
<a href="#JCXZ">JCXZ</a>  <br>
<a href="#JE">JE</a>  <br>
<a href="#JG">JG</a>  <br>

<a href="#JGE">JGE</a>  <br>
<a href="#JL">JL</a>  <br>
<a href="#JLE">JLE</a>  <br>
<a href="#JMP">JMP</a>  <br>
<a href="#JNA">JNA</a>  <br>
<a href="#JNAE">JNAE</a>  <br>
<a href="#JNB">JNB</a>  <br>
</td><td>
<a href="#JNBE">JNBE</a>  <br>
<a href="#JNC">JNC</a>  <br>
<a href="#JNE">JNE</a>  <br>
<a href="#JNG">JNG</a>  <br>
<a href="#JNGE">JNGE</a>  <br>
<a href="#JNL">JNL</a>  <br>
<a href="#JNLE">JNLE</a>  <br>

<a href="#JNO">JNO</a>  <br>
<a href="#JNP">JNP</a>  <br>
<a href="#JNS">JNS</a>  <br>
<a href="#JNZ">JNZ</a>  <br>
<a href="#JO">JO</a>  <br>
<a href="#JP">JP</a>  <br>
<a href="#JPE">JPE</a>  <br>
</td><td>
<a href="#JPO">JPO</a>  <br>
<a href="#JS">JS</a>  <br>
<a href="#JZ">JZ</a>  <br>
<a href="#LAHF">LAHF</a>  <br>
<a href="#LDS">LDS</a>  <br>
<a href="#LEA">LEA</a>  <br>
<a href="#LES">LES</a>  <br>

<a href="#LODSB">LODSB</a>  <br>
<a href="#LODSW">LODSW</a>  <br>
<a href="#LOOP">LOOP</a>  <br>
<a href="#LOOPE">LOOPE</a>  <br>
<a href="#LOOPNE">LOOPNE</a>  <br>
<a href="#LOOPNZ">LOOPNZ</a>  <br>
<a href="#LOOPZ">LOOPZ</a>  <br>
</td><td>
<a href="#MOV">MOV</a>  <br>
<a href="#MOVSB">MOVSB</a>  <br>
<a href="#MOVSW">MOVSW</a>  <br>
<a href="#MUL">MUL</a>  <br>
<a href="#NEG">NEG</a>  <br>
<a href="#NOP">NOP</a>  <br>
<a href="#OR">OR</a>  <br>

<a href="#OUT">OUT</a>  <br>

<a href="#POP">POP</a>  <br>
<a href="#POPA">POPA</a>  <br>
<a href="#POPF">POPF</a>  <br>
<a href="#PUSH">PUSH</a>  <br>
<a href="#PUSHA">PUSHA</a>  <br>
<a href="#PUSHF">PUSHF</a>  <br>
<a href="#RCL">RCL</a>  <br>
</td><td>
<a href="#RCR">RCR</a>  <br>
<a href="#REP">REP</a>  <br>
<a href="#REPE">REPE</a>  <br>
<a href="#REPNE">REPNE</a>  <br>
<a href="#REPNZ">REPNZ</a>  <br>
<a href="#REPZ">REPZ</a>  <br>
<a href="#RET">RET</a>  <br>

<a href="#RETF">RETF</a>  <br>
<a href="#ROL">ROL</a>  <br>
<a href="#ROR">ROR</a>  <br>
<a href="#SAHF">SAHF</a>  <br>
<a href="#SAL">SAL</a>  <br>
<a href="#SAR">SAR</a>  <br>
<a href="#SBB">SBB</a>  <br>
</td><td>
<a href="#SCASB">SCASB</a>  <br>
<a href="#SCASW">SCASW</a>  <br>
<a href="#SHL">SHL</a>  <br>
<a href="#SHR">SHR</a>  <br>
<a href="#STC">STC</a>  <br>
<a href="#STD">STD</a>  <br>
<a href="#STI">STI</a>  <br>

<a href="#STOSB">STOSB</a>  <br>
<a href="#STOSW">STOSW</a>  <br>
<a href="#SUB">SUB</a>  <br>
<a href="#TEST">TEST</a>  <br>
<a href="#XCHG">XCHG</a>  <br>
<a href="#XLATB">XLATB</a>  <br>
<a href="#XOR">XOR</a>  <br>
</td>
</tr>
</tbody></table>

</font>
<br><br>

<hr>


Operand types:<br><br>

<b>REG</b>: AX, BX, CX, DX, AH, AL, BL, BH, CH, CL, DH, DL, DI, SI, BP, SP.<br><br>

<b>SREG</b>: DS, ES, SS, and only as second operand: CS.<br><br>

<b>memory</b>: [BX], [BX+SI+7], variable, etc...(see <a href="https://dsearls.org/courses/C391OrgSys/IntelAL/asm_tutorial_02.html"><b>Memory Access</b></a>).<br><br>

<b>immediate</b>: 5, -24, 3Fh, 10001101b, etc...<br><br>

<hr>

<br>
Notes:<br><br>
<ul>
<li>When two operands are required for an instruction they are separated by comma. For example:<br><br>
	<font face="Fixedsys">
	REG, memory
	</font>
	<br><br></li>
<li>When there are two operands, both operands must have the same size (except shift and rotate
    instructions). For example:<br><br>
    <font face="Fixedsys">
	AL, DL<br>
	DX, AX<br>
	<font color="#005555">
	m1 DB ?<br>
	</font>
	AL, m1<br>
	<font color="#005555">
	m2 DW ?<br>
	</font>
	AX, m2
	</font>
	<br><br>
    </li>
	<li>Some instructions allow several operand combinations.
	 For example:<br><br>
	<font face="Fixedsys">
		memory, immediate<br>
		REG, immediate<br><br>
		memory, REG<br>
		REG, SREG
	</font><br><br>
	</li>

 <li>Some examples contain macros, so it is advisable to use <nobr><b>Shift + F8</b></nobr>
 hot key to <i>Step Over</i>, for example:
 <pre> <font face="Fixedsys">
   include 'emu8086.inc'
   ORG 100h
   MOV AL, 1
   MOV BL, 2
   PRINTN 'Hello World!'   ; macro.
   MOV CL, 3
   PRINTN 'Welcome!'       ; macro.
   RET</font></pre>
 </li>

</ul>
<br>

<hr>

<br>
Instructions in alphabetical order:

<br><br>

<table width="100%" cellpadding="10" border="1">

<tbody><tr>
<td>Instruction</td> <td>Operands</td> <td>Description
			<a name="AAA">&nbsp;</a>
</td>
</tr>




<tr>
<td>
<font face="Fixedsys">
AAA
</font>
</td>
<td>No operands</td>
<td>

ASCII Adjust after Addition.<br>
Corrects result in AH and AL after addition
when working with BCD values. <br><br> It works according to the following Algorithm:
<br><br>
<font face="Fixedsys">
if low nibble of AL &gt; 9 or AF = 1 then:<br>
<ul>
<li>AL = AL + 6</li>
<li>AH = AH + 1</li>
<li>AF = 1</li>
<li>CF = 1</li>
</ul>
else
<ul>
<li>AF = 0</li>
<li>CF = 0</li>
</ul>
in both cases:<br>
clear the high nibble of AL.
</font>
<br><br>Example:<pre><font face="Fixedsys">MOV AX, 15   ; AH = 00, AL = 0Fh
AAA          ; AH = 01, AL = 05
RET</font></pre>
			<a name="AAD">&nbsp;</a>
</td>
</tr>




<tr>
<td>
<font face="Fixedsys">
AAD
</font>
</td>
<td>No operands</td>
<td>

ASCII Adjust before Division.<br>
Prepares two BCD values for division. <br><br>Algorithm:
<br><br>
<font face="Fixedsys">
<ul>
<li>AL = (AH * 10) + AL</li>
<li>AH = 0</li>
</ul>
</font>
<br>Example:<pre><font face="Fixedsys">MOV AX, 0105h   ; AH = 01, AL = 05
AAD             ; AH = 00, AL = 0Fh (15)
RET</font></pre>
			<a name="AAM">&nbsp;</a>
</td>
</tr>




<tr>
<td>
<font face="Fixedsys">
AAM
</font>
</td>
<td>No operands</td>
<td>

ASCII Adjust after Multiplication.<br>
Corrects the result of multiplication of two BCD values. <br><br>Algorithm:
<br><br>
<font face="Fixedsys">
<ul>
<li>AH = AL / 10</li>
<li>AL = remainder</li>
</ul>
</font>
<br>Example:<pre><font face="Fixedsys">MOV AL, 15   ; AL = 0Fh
AAM          ; AH = 01, AL = 05
RET</font></pre>
			<a name="AAS">&nbsp;</a>
</td>
</tr>




<tr>
<td>
<font face="Fixedsys">
AAS
</font>
</td>
<td>No operands</td>
<td>

ASCII Adjust after Subtraction.<br>
Corrects result in AH and AL after subtraction
when working with BCD values. <br><br>Algorithm:<br><br>
<font face="Fixedsys">
if low nibble of AL &gt; 9 or AF = 1 then:<br>
<ul>
<li>AL = AL - 6</li>
<li>AH = AH - 1</li>
<li>AF = 1</li>
<li>CF = 1</li>
</ul>
else
<ul>
<li>AF = 0</li>
<li>CF = 0</li>
</ul>
in both cases:<br>
clear the high nibble of AL.
</font>
<br><br>Example:<pre><font face="Fixedsys">MOV AX, 02FFh  ; AH = 02, AL = 0FFh
AAS            ; AH = 01, AL = 09
RET</font></pre>
			<a name="ADC">&nbsp;</a>
</td>
</tr>




<tr>
<td>
<font face="Fixedsys">
ADC
</font>
</td>
<td>
<font face="Fixedsys">
	<nobr>
	REG, memory<br>
	memory, REG<br>
	REG, REG<br>
	memory, immediate<br>
	REG, immediate
	</nobr>
</font>
</td>
<td>

Add with Carry.<br>
<br><br>Algorithm:<br><br>
<font face="Fixedsys">
operand1 = operand1 + operand2 + CF
</font>
<br><br>Example:<pre><font face="Fixedsys">STC        ; set CF = 1
MOV AL, 5  ; AL = 5
ADC AL, 1  ; AL = 7
RET</font></pre>
			<a name="ADD">&nbsp;</a>
</td>
</tr>




<tr>
<td>
<font face="Fixedsys">
ADD
</font>
</td>
<td>
<font face="Fixedsys">
	<nobr>
	REG, memory<br>
	memory, REG<br>
	REG, REG<br>
	memory, immediate<br>
	REG, immediate
	</nobr>
</font>
</td>
<td>

Add.<br>
<br><br>Algorithm:<br><br>
<font face="Fixedsys">
operand1 = operand1 + operand2
</font>
<br><br>Example:<pre><font face="Fixedsys">MOV AL, 5   ; AL = 5
ADD AL, -3  ; AL = 2
RET</font></pre>
			<a name="AND">&nbsp;</a>
</td>
</tr>




<tr>
<td>
<font face="Fixedsys">
AND
</font>
</td>
<td>
<font face="Fixedsys">
	<nobr>
	REG, memory<br>
	memory, REG<br>
	REG, REG<br>
	memory, immediate<br>
	REG, immediate
	</nobr>
</font>
</td>
<td>

Logical AND between all bits of two operands. Result is stored in operand1.<br><br>
These rules apply:<br><br>
<font face="Fixedsys">
1 AND 1 = 1<br>
1 AND 0 = 0<br>
0 AND 1 = 0<br>
0 AND 0 = 0<br>
</font>
<br><br>Example:<pre><font face="Fixedsys">MOV AL, 'a'        ; AL = 01100001b
AND AL, 11011111b  ; AL = 01000001b  ('A')
RET</font></pre>
			<a name="CALL">&nbsp;</a>
</td>
</tr>




<tr>
<td>
<font face="Fixedsys">
CALL
</font>
</td>
<td>
<font face="Fixedsys">
	<nobr>
	procedure name<br>
	label<br>
	4-byte address<br>
	</nobr>
</font>
</td>
<td>

Transfers control to procedure, return address is (IP) is pushed to
stack. <i>4-byte address</i> may be entered in this form:
<font face="Fixedsys">1234h:5678h</font>, first value is a segment second
value is an offset (this is a far call, so CS is also pushed to stack).<br>
<br><br>Example:<pre><font face="Fixedsys">ORG 100h  ; for COM file.

CALL p1

ADD AX, 1

RET         ; return to OS.

p1 PROC     ; procedure declaration.
    MOV AX, 1234h
    RET     ; return to caller.
p1 ENDP</font></pre>
			<a name="CBW">&nbsp;</a>
</td>
</tr>




<tr>
<td>
<font face="Fixedsys">
CBW
</font>
</td>
<td>No operands</td>
<td>

Convert byte into word. <br><br>Algorithm:
<br><br>
<font face="Fixedsys">
if high bit of AL = 1 then:
<ul>
<li>AH = 255 (0FFh)</li>
</ul>
<br>
else
<ul>
<li>AH = 0</li>
</ul>
</font>
<br>Example:<pre><font face="Fixedsys">MOV AX, 0   ; AH = 0, AL = 0
MOV AL, -5  ; AX = 000FBh (251)
CBW         ; AX = 0FFFBh (-5)
RET</font></pre>
			<a name="CLC">&nbsp;</a>
</td>
</tr>




<tr>
<td>
<font face="Fixedsys">
CLC
</font>
</td>
<td>No operands</td>
<td>

Clear Carry flag. <br><br>Algorithm:
<br><br>
<font face="Fixedsys">
CF = 0
</font>
			<a name="CLD">&nbsp;</a>
</td>
</tr>




<tr>
<td>
<font face="Fixedsys">
CLD
</font>
</td>
<td>No operands</td>
<td>

Clear Direction flag. SI and DI will be incremented by chain
instructions: CMPSB, CMPSW, LODSB, LODSW, MOVSB, MOVSW, STOSB, STOSW. <br><br>Algorithm:
<br><br>
<font face="Fixedsys">
DF = 0
</font>
			<a name="CLI">&nbsp;</a>
</td>
</tr>




<tr>
<td>
<font face="Fixedsys">
CLI
</font>
</td>
<td>No operands</td>
<td>

Clear Interrupt enable flag. This disables hardware interrupts. <br><br>Algorithm:
<br><br>
<font face="Fixedsys">
IF = 0
</font>
			<a name="CMC">&nbsp;</a>
</td>
</tr>




<tr>
<td>
<font face="Fixedsys">
CMC
</font>
</td>
<td>No operands</td>
<td>

Complement Carry flag. Inverts value of CF. <br><br>Algorithm:
<br><br>
<font face="Fixedsys">
if CF = 1 then CF = 0<br>
if CF = 0 then CF = 1<br>
</font>
			<a name="CMP">&nbsp;</a>
</td>
</tr>




<tr>
<td>
<font face="Fixedsys">
CMP
</font>
</td>
<td>
<font face="Fixedsys">
	<nobr>
	REG, memory<br>
	memory, REG<br>
	REG, REG<br>
	memory, immediate<br>
	REG, immediate
	</nobr>
</font>
</td>
<td>

Compare.
<br><br>Algorithm:<br><br>
<font face="Fixedsys">
operand1 - operand2
<br><br>
result is not stored anywhere, flags are set (OF, SF, ZF, AF, PF, CF) according
to result.
</font>
<br><br>Example:<pre><font face="Fixedsys">MOV AL, 5
MOV BL, 5
CMP AL, BL  ; AL = 5, ZF = 1 (so equal!)
RET</font></pre>
			<a name="CMPSB">&nbsp;</a>
</td>
</tr>




<tr>
<td>
<font face="Fixedsys">
CMPSB
</font>
</td>
<td>No operands</td>
<td>

Compare bytes: <nobr>ES:[DI] from DS:[SI].</nobr> <br><br>Algorithm:
<br><br>
<font face="Fixedsys">
<ul>
<li>DS:[SI] - ES:[DI]<br></li>
<li>set flags according to result:<br> OF, SF, ZF, AF, PF, CF<br></li>
<li>if DF = 0 then
	<ul>
	<li>SI = SI + 1</li>
	<li>DI = DI + 1</li>
	</ul>
	else
	<ul>
	<li>SI = SI - 1</li>
	<li>DI = DI - 1</li>
	</ul>
</li>
</ul>
</font>
Example:<br>
see <b><a href="https://dsearls.org/courses/C391OrgSys/Samples/cmpsb.asm">cmpsb.asm</a></b> in Samples.
			<a name="CMPSW">&nbsp;</a>
</td>
</tr>




<tr>
<td>
<font face="Fixedsys">
CMPSW
</font>
</td>
<td>No operands</td>
<td>

Compare words: <nobr>ES:[DI] from DS:[SI].</nobr> <br><br>Algorithm:
<br><br>
<font face="Fixedsys">
<ul>
<li>DS:[SI] - ES:[DI]<br></li>
<li>set flags according to result:<br> OF, SF, ZF, AF, PF, CF<br></li>
<li>if DF = 0 then
	<ul>
	<li>SI = SI + 2</li>
	<li>DI = DI + 2</li>
	</ul>
	else
	<ul>
	<li>SI = SI - 2</li>
	<li>DI = DI - 2</li>
	</ul>
</li>
</ul>
</font>
Example:<br>
see <b><a href="https://dsearls.org/courses/C391OrgSys/Samples/cmpsw.asm">cmpsw.asm</a></b> in Samples.
			<a name="CWD">&nbsp;</a>
</td>
</tr>




<tr>
<td>
<font face="Fixedsys">
CWD
</font>
</td>
<td>No operands</td>
<td>

Convert Word to Double word. <br><br>Algorithm:
<br><br>
<font face="Fixedsys">
if high bit of AX = 1 then:
<ul>
<li>DX = 65535 (0FFFFh)</li>
</ul>
<br>
else
<ul>
<li>DX = 0</li>
</ul>
</font>
<br>Example:<pre><font face="Fixedsys">MOV DX, 0   ; DX = 0
MOV AX, 0   ; AX = 0
MOV AX, -5  ; DX AX = 00000h:0FFFBh
CWD         ; DX AX = 0FFFFh:0FFFBh
RET</font></pre>
			<a name="DAA">&nbsp;</a>
</td>
</tr>




<tr>
<td>
<font face="Fixedsys">
DAA
</font>
</td>
<td>No operands</td>
<td>

Decimal adjust After Addition.<br>
Corrects the result of addition of two packed BCD values. <br><br>Algorithm:
<br><br>
<font face="Fixedsys">
if low nibble of AL &gt; 9 or AF = 1 then:<br>
<ul>
<li>AL = AL + 6</li>
<li>AF = 1</li>
</ul>
if AL &gt; 9Fh or CF = 1 then:
<ul>
<li>AL = AL + 60h</li>
<li>CF = 1</li>
</ul>
</font>
<br>Example:<pre><font face="Fixedsys">MOV AL, 0Fh  ; AL = 0Fh (15)
DAA          ; AL = 15h
RET</font></pre>
			<a name="DAS">&nbsp;</a>
</td>
</tr>




<tr>
<td>
<font face="Fixedsys">
DAS
</font>
</td>
<td>No operands</td>
<td>

Decimal adjust After Subtraction.<br>
Corrects the result of subtraction of two packed BCD values. <br><br>Algorithm:
<br><br>
<font face="Fixedsys">
if low nibble of AL &gt; 9 or AF = 1 then:<br>
<ul>
<li>AL = AL - 6</li>
<li>AF = 1</li>
</ul>
if AL &gt; 9Fh or CF = 1 then:
<ul>
<li>AL = AL - 60h</li>
<li>CF = 1</li>
</ul>
</font>
<br>Example:<pre><font face="Fixedsys">MOV AL, 0FFh  ; AL = 0FFh (-1)
DAS           ; AL = 99h, CF = 1
RET</font></pre>
			<a name="DEC">&nbsp;</a>
</td>
</tr>




<tr>
<td>
<font face="Fixedsys">
DEC
</font>
</td>
<td>
<font face="Fixedsys">
	<nobr>
	REG<br>
	memory<br>
	</nobr>
</font>
</td>
<td>

Decrement.
<br><br>Algorithm:<br><br>
<font face="Fixedsys">
operand = operand - 1
<br><br>
</font>
<br>Example:<pre><font face="Fixedsys">MOV AL, 255  ; AL = 0FFh (255 or -1)
DEC AL       ; AL = 0FEh (254 or -2)
RET</font></pre>
			<a name="DIV">&nbsp;</a>
</td>
</tr>




<tr>
<td>
<font face="Fixedsys">
DIV
</font>
</td>
<td>
<font face="Fixedsys">
	<nobr>
	REG<br>
	memory<br>
	</nobr>
</font>
</td>
<td>

Unsigned divide.
<br><br>Algorithm:<br><br>
 <blockquote>
	 when operand is a <b>byte</b>:<br>
	 <font face="Fixedsys">AL = AX / operand<br>
	 AH = remainder (modulus)
	 </font>
 </blockquote>

 <blockquote>
	when operand is a <b>word</b>:<br>
	<font face="Fixedsys">AX = (DX AX) / operand<br>
	DX = remainder (modulus)
	</font>
 </blockquote>
 Example:<pre><font face="Fixedsys">MOV AX, 203   ; AX = 00CBh
MOV BL, 4
DIV BL        ; AL = 50 (32h), AH = 3
RET</font></pre>
 			<a name="IDIV">&nbsp;</a>
</td>
</tr>




<tr>
<td>
<font face="Fixedsys">
IDIV
</font>
</td>
<td>
<font face="Fixedsys">
	<nobr>
	REG<br>
	memory<br>
	</nobr>
</font>
</td>
<td>

Signed divide.
<br><br>Algorithm:<br><br>
 <blockquote>
	 when operand is a <b>byte</b>:<br>
	 <font face="Fixedsys">AL = AX / operand<br>
	 AH = remainder (modulus)
	 </font>
 </blockquote>

 <blockquote>
	when operand is a <b>word</b>:<br>
	<font face="Fixedsys">AX = (DX AX) / operand<br>
	DX = remainder (modulus)
	</font>
 </blockquote>
 Example:<pre><font face="Fixedsys">MOV AX, -203 ; AX = 0FF35h
MOV BL, 4
IDIV BL      ; AL = -50 (0CEh), AH = -3 (0FDh)
RET</font></pre>
 			<a name="IMUL">&nbsp;</a>
</td>
</tr>




<tr>
<td>
<font face="Fixedsys">
IMUL
</font>
</td>
<td>
<font face="Fixedsys">
	<nobr>
	REG<br>
	memory<br>
	</nobr>
</font>
</td>
<td>

Signed multiply.
<br><br>Algorithm:<br><br>
 <blockquote>
	 when operand is a <b>byte</b>:<br>
	 <font face="Fixedsys">AX = AL * operand</font>.
 </blockquote>

 <blockquote>
	when operand is a <b>word</b>:<br>
	<font face="Fixedsys">(DX AX) = AX * operand</font>.
 </blockquote>
  Example:<pre><font face="Fixedsys">MOV AL, -2
MOV BL, -4
IMUL BL      ; AX = 8
RET</font></pre>
 			<a name="IN">&nbsp;</a>
</td>
</tr>


<tr>
<td>
<font face="Fixedsys">
IN
</font>
</td>
<td>
<font face="Fixedsys">
	<nobr>
	AL, im.byte<br>
	AL, DX<br>
	AX, im.byte<br>
	AX, DX
	</nobr>
</font>
</td>
<td>

Input from port into <b>AL</b> or <b>AX</b>.<br>
Second operand is a port number. If required to access
port number over 255 - <b>DX</b> register should be used.
<br>Example:<pre><font face="Fixedsys">IN AX, 4  ; get status of traffic lights.
IN AL, 7  ; get status of stepper-motor.
</font></pre>
 			<a name="INC">&nbsp;</a>
</td>
</tr>


<tr>
<td>
<font face="Fixedsys">
INC
</font>
</td>
<td>
<font face="Fixedsys">
	<nobr>
	REG<br>
	memory<br>
	</nobr>
</font>
</td>
<td>

Increment.
<br><br>Algorithm:<br><br>
<font face="Fixedsys">
operand = operand + 1
<br>
</font>
<br>Example:<pre><font face="Fixedsys">MOV AL, 4
INC AL       ; AL = 5
RET</font></pre>
			<a name="INT">&nbsp;</a>
</td>
</tr>




<tr>
<td>
<font face="Fixedsys">
INT
</font>
</td>
<td>
<font face="Fixedsys">
	<nobr>immediate byte</nobr>
</font>
</td>
<td>

Interrupt numbered by immediate byte (0..255).
<br><br>Algorithm:<br><br>
<font face="Fixedsys">
<ul>
	Push to stack:
	<ul>
	<li>flags register</li>
	<li>CS</li>
	<li>IP</li>
	</ul>

	<li>IF = 0</li>

	<li>Transfer control to interrupt procedure</li>
</ul>
</font>
<br>Example:<pre><font face="Fixedsys">MOV AH, 0Eh  ; teletype.
MOV AL, 'A'
INT 10h      ; BIOS interrupt.
RET</font></pre>
			<a name="INTO">&nbsp;</a>
</td>
</tr>



<tr>
<td>
<font face="Fixedsys">
INTO
</font>
</td>
<td>No operands</td>
<td>

Interrupt 4 if Overflow flag is 1.
<br><br>Algorithm:<br><br>
<font face="Fixedsys">
if OF = 1 then INT 4
<br>
</font>
<br>Example:<pre><font face="Fixedsys">; -5 - 127 = -132 (not in -128..127)
; the result of SUB is wrong (124),
; so OF = 1 is set:
MOV AL, -5
SUB AL, 127   ; AL = 7Ch (124)
INTO          ; process error.
RET</font></pre>
			<a name="IRET">&nbsp;</a>
</td>
</tr>




<tr>
<td>
<font face="Fixedsys">
IRET
</font>
</td>
<td>No operands</td>
<td>

Interrupt Return.
<br><br>Algorithm:<br><br>
<font face="Fixedsys">
<ul>
	Pop from stack:
	<ul>
	<li>IP</li>
	<li>CS</li>
	<li>flags register</li>
	</ul>
</ul>
</font>
			<a name="JA">&nbsp;</a>
</td>
</tr>




<tr>
<td>
<font face="Fixedsys">
JA
</font>
</td>
<td>
<font face="Fixedsys">
	<nobr>label</nobr>
</font>
</td>
<td>

Short Jump if first operand is Above second operand (as set by CMP instruction).
Unsigned.
<br><br>Algorithm:<br><br>
<font face="Fixedsys">
<ul>
	if (CF = 0) and (ZF = 0) then jump
</ul>
</font>
Example:<pre><font face="Fixedsys">   include 'emu8086.inc'
   ORG 100h
   MOV AL, 250
   CMP AL, 5
   JA label1
   PRINT 'AL is not above 5'
   JMP exit
label1:
   PRINT 'AL is above 5'
exit:
   RET</font></pre>
			<a name="JAE">&nbsp;</a>
</td>
</tr>




<tr>
<td>
<font face="Fixedsys">
JAE
</font>
</td>
<td>
<font face="Fixedsys">
	<nobr>label</nobr>
</font>
</td>
<td>

Short Jump if first operand is Above or Equal to second operand (as set by CMP instruction).
Unsigned.
<br><br>Algorithm:<br><br>
<font face="Fixedsys">
<ul>
	if CF = 0 then jump
</ul>
</font>
Example:<pre><font face="Fixedsys">   include 'emu8086.inc'
   ORG 100h
   MOV AL, 5
   CMP AL, 5
   JAE label1
   PRINT 'AL is not above or equal to 5'
   JMP exit
label1:
   PRINT 'AL is above or equal to 5'
exit:
   RET</font></pre>
			<a name="JB">&nbsp;</a>
</td>
</tr>




<tr>
<td>
<font face="Fixedsys">
JB
</font>
</td>
<td>
<font face="Fixedsys">
	<nobr>label</nobr>
</font>
</td>
<td>

Short Jump if first operand is Below second operand (as set by CMP instruction).
Unsigned.
<br><br>Algorithm:<br><br>
<font face="Fixedsys">
<ul>
	if CF = 1 then jump
</ul>
</font>
Example:<pre><font face="Fixedsys">   include 'emu8086.inc'
   ORG 100h
   MOV AL, 1
   CMP AL, 5
   JB  label1
   PRINT 'AL is not below 5'
   JMP exit
label1:
   PRINT 'AL is below 5'
exit:
   RET</font></pre>
			<a name="JBE">&nbsp;</a>
</td>
</tr>




<tr>
<td>
<font face="Fixedsys">
JBE
</font>
</td>
<td>
<font face="Fixedsys">
	<nobr>label</nobr>
</font>
</td>
<td>

Short Jump if first operand is Below or Equal to second operand (as set by CMP instruction).
Unsigned.
<br><br>Algorithm:<br><br>
<font face="Fixedsys">
<ul>
	if CF = 1 or ZF = 1 then jump
</ul>
</font>
Example:<pre><font face="Fixedsys">   include 'emu8086.inc'
   ORG 100h
   MOV AL, 5
   CMP AL, 5
   JBE  label1
   PRINT 'AL is not below or equal to 5'
   JMP exit
label1:
   PRINT 'AL is below or equal to 5'
exit:
   RET</font></pre>
			<a name="JC">&nbsp;</a>
</td>
</tr>




<tr>
<td>
<font face="Fixedsys">
JC
</font>
</td>
<td>
<font face="Fixedsys">
	<nobr>label</nobr>
</font>
</td>
<td>

Short Jump if Carry flag is set to 1.
<br><br>Algorithm:<br><br>
<font face="Fixedsys">
<ul>
	if CF = 1 then jump
</ul>
</font>
Example:<pre><font face="Fixedsys">   include 'emu8086.inc'
   ORG 100h
   MOV AL, 255
   ADD AL, 1
   JC  label1
   PRINT 'no carry.'
   JMP exit
label1:
   PRINT 'has carry.'
exit:
   RET</font></pre>
			<a name="JCXZ">&nbsp;</a>
</td>
</tr>




<tr>
<td>
<font face="Fixedsys">
JCXZ
</font>
</td>
<td>
<font face="Fixedsys">
	<nobr>label</nobr>
</font>
</td>
<td>

Short Jump if CX register is 0.
<br><br>Algorithm:<br><br>
<font face="Fixedsys">
<ul>
	if CX = 0 then jump
</ul>
</font>
Example:<pre><font face="Fixedsys">   include 'emu8086.inc'
   ORG 100h
   MOV CX, 0
   JCXZ label1
   PRINT 'CX is not zero.'
   JMP exit
label1:
   PRINT 'CX is zero.'
exit:
   RET</font></pre>
			<a name="JE">&nbsp;</a>
</td>
</tr>




<tr>
<td>
<font face="Fixedsys">
JE
</font>
</td>
<td>
<font face="Fixedsys">
	<nobr>label</nobr>
</font>
</td>
<td>

Short Jump if first operand is Equal to second operand (as set by CMP instruction).
Signed/Unsigned.
<br><br>Algorithm:<br><br>
<font face="Fixedsys">
<ul>
	if ZF = 1 then jump
</ul>
</font>
Example:<pre><font face="Fixedsys">   include 'emu8086.inc'
   ORG 100h
   MOV AL, 5
   CMP AL, 5
   JE  label1
   PRINT 'AL is not equal to 5.'
   JMP exit
label1:
   PRINT 'AL is equal to 5.'
exit:
   RET</font></pre>
			<a name="JG">&nbsp;</a>
</td>
</tr>




<tr>
<td>
<font face="Fixedsys">
JG
</font>
</td>
<td>
<font face="Fixedsys">
	<nobr>label</nobr>
</font>
</td>
<td>

Short Jump if first operand is Greater then second operand (as set by CMP instruction).
Signed.
<br><br>Algorithm:<br><br>
<font face="Fixedsys">
<ul>
	if (ZF = 0) and (SF = OF) then jump
</ul>
</font>
Example:<pre><font face="Fixedsys">   include 'emu8086.inc'
   ORG 100h
   MOV AL, 5
   CMP AL, -5
   JG  label1
   PRINT 'AL is not greater -5.'
   JMP exit
label1:
   PRINT 'AL is greater -5.'
exit:
   RET</font></pre>
			<a name="JGE">&nbsp;</a>
</td>
</tr>




<tr>
<td>
<font face="Fixedsys">
JGE
</font>
</td>
<td>
<font face="Fixedsys">
	<nobr>label</nobr>
</font>
</td>
<td>

Short Jump if first operand is Greater or Equal to second operand (as set by CMP instruction).
Signed.
<br><br>Algorithm:<br><br>
<font face="Fixedsys">
<ul>
	if SF = OF then jump
</ul>
</font>
Example:<pre><font face="Fixedsys">   include 'emu8086.inc'
   ORG 100h
   MOV AL, 2
   CMP AL, -5
   JGE  label1
   PRINT 'AL &lt; -5'
   JMP exit
label1:
   PRINT 'AL &gt;= -5'
exit:
   RET</font></pre>
			<a name="JL">&nbsp;</a>
</td>
</tr>




<tr>
<td>
<font face="Fixedsys">
JL
</font>
</td>
<td>
<font face="Fixedsys">
	<nobr>label</nobr>
</font>
</td>
<td>

Short Jump if first operand is Less then second operand (as set by CMP instruction).
Signed.
<br><br>Algorithm:<br><br>
<font face="Fixedsys">
<ul>
	if SF &lt;&gt; OF then jump
</ul>
</font>
Example:<pre><font face="Fixedsys">   include 'emu8086.inc'
   ORG 100h
   MOV AL, -2
   CMP AL, 5
   JL  label1
   PRINT 'AL &gt;= 5.'
   JMP exit
label1:
   PRINT 'AL &lt; 5.'
exit:
   RET</font></pre>
			<a name="JLE">&nbsp;</a>
</td>
</tr>




<tr>
<td>
<font face="Fixedsys">
JLE
</font>
</td>
<td>
<font face="Fixedsys">
	<nobr>label</nobr>
</font>
</td>
<td>

Short Jump if first operand is Less or Equal to second operand (as set by CMP instruction).
Signed.
<br><br>Algorithm:<br><br>
<font face="Fixedsys">
<ul>
	if SF &lt;&gt; OF or ZF = 1 then jump
</ul>
</font>
Example:<pre><font face="Fixedsys">   include 'emu8086.inc'
   ORG 100h
   MOV AL, -2
   CMP AL, 5
   JLE label1
   PRINT 'AL &gt; 5.'
   JMP exit
label1:
   PRINT 'AL &lt;= 5.'
exit:
   RET</font></pre>
			<a name="JMP">&nbsp;</a>
</td>
</tr>




<tr>
<td>
<font face="Fixedsys">
JMP
</font>
</td>
<td>
<font face="Fixedsys">
	<nobr>
	label<br>
	4-byte address<br>
	</nobr>
</font>
</td>
<td>

Unconditional Jump.
Transfers control to another part of the program.
<i>4-byte address</i> may be entered in this form:
<font face="Fixedsys">1234h:5678h</font>, first value is a segment second
value is an offset.<br>

<br><br>Algorithm:<br><br>
<font face="Fixedsys">
<ul>
	always jump
</ul>
</font>
Example:<pre><font face="Fixedsys">   include 'emu8086.inc'
   ORG 100h
   MOV AL, 5
   JMP label1    ; jump over 2 lines!
   PRINT 'Not Jumped!'
   MOV AL, 0
label1:
   PRINT 'Got Here!'
   RET</font></pre>
			<a name="JNA">&nbsp;</a>
</td>
</tr>




<tr>
<td>
<font face="Fixedsys">
JNA
</font>
</td>
<td>
<font face="Fixedsys">
	<nobr>label</nobr>
</font>
</td>
<td>

Short Jump if first operand is Not Above second operand (as set by CMP instruction).
Unsigned.
<br><br>Algorithm:<br><br>
<font face="Fixedsys">
<ul>
	if CF = 1 or ZF = 1 then jump
</ul>
</font>
Example:<pre><font face="Fixedsys">   include 'emu8086.inc'
   ORG 100h
   MOV AL, 2
   CMP AL, 5
   JNA label1
   PRINT 'AL is above 5.'
   JMP exit
label1:
   PRINT 'AL is not above 5.'
exit:
   RET</font></pre>
			<a name="JNAE">&nbsp;</a>
</td>
</tr>




<tr>
<td>
<font face="Fixedsys">
JNAE
</font>
</td>
<td>
<font face="Fixedsys">
	<nobr>label</nobr>
</font>
</td>
<td>

Short Jump if first operand is Not Above and Not Equal to second operand (as set by CMP instruction).
Unsigned.
<br><br>Algorithm:<br><br>
<font face="Fixedsys">
<ul>
	if CF = 1 then jump
</ul>
</font>
Example:<pre><font face="Fixedsys">   include 'emu8086.inc'
   ORG 100h
   MOV AL, 2
   CMP AL, 5
   JNAE label1
   PRINT 'AL &gt;= 5.'
   JMP exit
label1:
   PRINT 'AL &lt; 5.'
exit:
   RET</font></pre>
			<a name="JNB">&nbsp;</a>
</td>
</tr>




<tr>
<td>
<font face="Fixedsys">
JNB
</font>
</td>
<td>
<font face="Fixedsys">
	<nobr>label</nobr>
</font>
</td>
<td>

Short Jump if first operand is Not Below second operand (as set by CMP instruction).
Unsigned.
<br><br>Algorithm:<br><br>
<font face="Fixedsys">
<ul>
	if CF = 0 then jump
</ul>
</font>
Example:<pre><font face="Fixedsys">   include 'emu8086.inc'
   ORG 100h
   MOV AL, 7
   CMP AL, 5
   JNB label1
   PRINT 'AL &lt; 5.'
   JMP exit
label1:
   PRINT 'AL &gt;= 5.'
exit:
   RET</font></pre>
			<a name="JNBE">&nbsp;</a>
</td>
</tr>




<tr>
<td>
<font face="Fixedsys">
JNBE
</font>
</td>
<td>
<font face="Fixedsys">
	<nobr>label</nobr>
</font>
</td>
<td>

Short Jump if first operand is Not Below and Not Equal to second operand (as set by CMP instruction).
Unsigned.
<br><br>Algorithm:<br><br>
<font face="Fixedsys">
<ul>
	if (CF = 0) and (ZF = 0) then jump
</ul>
</font>
Example:<pre><font face="Fixedsys">   include 'emu8086.inc'
   ORG 100h
   MOV AL, 7
   CMP AL, 5
   JNBE label1
   PRINT 'AL &lt;= 5.'
   JMP exit
label1:
   PRINT 'AL &gt; 5.'
exit:
   RET</font></pre>
			<a name="JNC">&nbsp;</a>
</td>
</tr>




<tr>
<td>
<font face="Fixedsys">
JNC
</font>
</td>
<td>
<font face="Fixedsys">
	<nobr>label</nobr>
</font>
</td>
<td>

Short Jump if Carry flag is set to 0.
<br><br>Algorithm:<br><br>
<font face="Fixedsys">
<ul>
	if CF = 0 then jump
</ul>
</font>
Example:<pre><font face="Fixedsys">   include 'emu8086.inc'
   ORG 100h
   MOV AL, 2
   ADD AL, 3
   JNC  label1
   PRINT 'has carry.'
   JMP exit
label1:
   PRINT 'no carry.'
exit:
   RET</font></pre>
			<a name="JNE">&nbsp;</a>
</td>
</tr>




<tr>
<td>
<font face="Fixedsys">
JNE
</font>
</td>
<td>
<font face="Fixedsys">
	<nobr>label</nobr>
</font>
</td>
<td>

Short Jump if first operand is Not Equal to second operand (as set by CMP instruction).
Signed/Unsigned.
<br><br>Algorithm:<br><br>
<font face="Fixedsys">
<ul>
	if ZF = 0 then jump
</ul>
</font>
Example:<pre><font face="Fixedsys">   include 'emu8086.inc'
   ORG 100h
   MOV AL, 2
   CMP AL, 3
   JNE  label1
   PRINT 'AL = 3.'
   JMP exit
label1:
   PRINT 'Al &lt;&gt; 3.'
exit:
   RET</font></pre>
			<a name="JNG">&nbsp;</a>
</td>
</tr>




<tr>
<td>
<font face="Fixedsys">
JNG
</font>
</td>
<td>
<font face="Fixedsys">
	<nobr>label</nobr>
</font>
</td>
<td>

Short Jump if first operand is Not Greater then second operand (as set by CMP instruction).
Signed.
<br><br>Algorithm:<br><br>
<font face="Fixedsys">
<ul>
	if (ZF = 1) and (SF &lt;&gt; OF) then jump
</ul>
</font>
Example:<pre><font face="Fixedsys">   include 'emu8086.inc'
   ORG 100h
   MOV AL, 2
   CMP AL, 3
   JNG  label1
   PRINT 'AL &gt; 3.'
   JMP exit
label1:
   PRINT 'Al &lt;= 3.'
exit:
   RET</font></pre>
			<a name="JNGE">&nbsp;</a>
</td>
</tr>




<tr>
<td>
<font face="Fixedsys">
JNGE
</font>
</td>
<td>
<font face="Fixedsys">
	<nobr>label</nobr>
</font>
</td>
<td>

Short Jump if first operand is Not Greater and Not Equal to second operand (as set by CMP instruction).
Signed.
<br><br>Algorithm:<br><br>
<font face="Fixedsys">
<ul>
	if SF &lt;&gt; OF then jump
</ul>
</font>
Example:<pre><font face="Fixedsys">   include 'emu8086.inc'
   ORG 100h
   MOV AL, 2
   CMP AL, 3
   JNGE  label1
   PRINT 'AL &gt;= 3.'
   JMP exit
label1:
   PRINT 'Al &lt; 3.'
exit:
   RET</font></pre>
			<a name="JNL">&nbsp;</a>
</td>
</tr>




<tr>
<td>
<font face="Fixedsys">
JNL
</font>
</td>
<td>
<font face="Fixedsys">
	<nobr>label</nobr>
</font>
</td>
<td>

Short Jump if first operand is Not Less then second operand (as set by CMP instruction).
Signed.
<br><br>Algorithm:<br><br>
<font face="Fixedsys">
<ul>
	if SF = OF then jump
</ul>
</font>
Example:<pre><font face="Fixedsys">   include 'emu8086.inc'
   ORG 100h
   MOV AL, 2
   CMP AL, -3
   JNL label1
   PRINT 'AL &lt; -3.'
   JMP exit
label1:
   PRINT 'Al &gt;= -3.'
exit:
   RET</font></pre>
			<a name="JNLE">&nbsp;</a>
</td>
</tr>




<tr>
<td>
<font face="Fixedsys">
JNLE
</font>
</td>
<td>
<font face="Fixedsys">
	<nobr>label</nobr>
</font>
</td>
<td>

Short Jump if first operand is Not Less and Not Equal to second operand (as set by CMP instruction).
Signed.
<br><br>Algorithm:<br><br>
<font face="Fixedsys">
<ul>
	if (SF = OF) and (ZF = 0) then jump
</ul>
</font>
Example:<pre><font face="Fixedsys">   include 'emu8086.inc'
   ORG 100h
   MOV AL, 2
   CMP AL, -3
   JNLE label1
   PRINT 'AL &lt;= -3.'
   JMP exit
label1:
   PRINT 'Al &gt; -3.'
exit:
   RET</font></pre>
			<a name="JNO">&nbsp;</a>
</td>
</tr>




<tr>
<td>
<font face="Fixedsys">
JNO
</font>
</td>
<td>
<font face="Fixedsys">
	<nobr>label</nobr>
</font>
</td>
<td>

Short Jump if Not Overflow.
<br><br>Algorithm:<br><br>
<font face="Fixedsys">
<ul>
	if OF = 0 then jump
</ul>
</font>
Example:<pre><font face="Fixedsys">; -5 - 2 = -7 (inside -128..127)
; the result of SUB is correct,
; so OF = 0:

include 'emu8086.inc'
ORG 100h
  MOV AL, -5
  SUB AL, 2   ; AL = 0F9h (-7)
JNO  label1
  PRINT 'overflow!'
JMP exit
label1:
  PRINT 'no overflow.'
exit:
  RET</font></pre>
			<a name="JNP">&nbsp;</a>
</td>
</tr>




<tr>
<td>
<font face="Fixedsys">
JNP
</font>
</td>
<td>
<font face="Fixedsys">
	<nobr>label</nobr>
</font>
</td>
<td>

Short Jump if No Parity (odd). Only 8 low bits of result are checked.
Set by CMP, SUB, ADD, TEST, AND, OR, XOR instructions.
<br><br>Algorithm:<br><br>
<font face="Fixedsys">
<ul>
	if PF = 0 then jump
</ul>
</font>
Example:<pre><font face="Fixedsys">   include 'emu8086.inc'
   ORG 100h
   MOV AL, 00000111b   ; AL = 7
   OR  AL, 0           ; just set flags.
   JNP label1
   PRINT 'parity even.'
   JMP exit
label1:
   PRINT 'parity odd.'
exit:
   RET</font></pre>
			<a name="JNS">&nbsp;</a>
</td>
</tr>




<tr>
<td>
<font face="Fixedsys">
JNS
</font>
</td>
<td>
<font face="Fixedsys">
	<nobr>label</nobr>
</font>
</td>
<td>

Short Jump if Not Signed (if positive).
Set by CMP, SUB, ADD, TEST, AND, OR, XOR instructions.
<br><br>Algorithm:<br><br>
<font face="Fixedsys">
<ul>
	if SF = 0 then jump
</ul>
</font>
Example:<pre><font face="Fixedsys">   include 'emu8086.inc'
   ORG 100h
   MOV AL, 00000111b   ; AL = 7
   OR  AL, 0           ; just set flags.
   JNS label1
   PRINT 'signed.'
   JMP exit
label1:
   PRINT 'not signed.'
exit:
   RET</font></pre>
			<a name="JNZ">&nbsp;</a>
</td>
</tr>




<tr>
<td>
<font face="Fixedsys">
JNZ
</font>
</td>
<td>
<font face="Fixedsys">
	<nobr>label</nobr>
</font>
</td>
<td>

Short Jump if Not Zero (not equal).
Set by CMP, SUB, ADD, TEST, AND, OR, XOR instructions.
<br><br>Algorithm:<br><br>
<font face="Fixedsys">
<ul>
	if ZF = 0 then jump
</ul>
</font>
Example:<pre><font face="Fixedsys">   include 'emu8086.inc'
   ORG 100h
   MOV AL, 00000111b   ; AL = 7
   OR  AL, 0           ; just set flags.
   JNZ label1
   PRINT 'zero.'
   JMP exit
label1:
   PRINT 'not zero.'
exit:
   RET</font></pre>
			<a name="JO">&nbsp;</a>
</td>
</tr>




<tr>
<td>
<font face="Fixedsys">
JO
</font>
</td>
<td>
<font face="Fixedsys">
	<nobr>label</nobr>
</font>
</td>
<td>

Short Jump if Overflow.
<br><br>Algorithm:<br><br>
<font face="Fixedsys">
<ul>
	if OF = 1 then jump
</ul>
</font>
Example:<pre><font face="Fixedsys">; -5 - 127 = -132 (not in -128..127)
; the result of SUB is wrong (124),
; so OF = 1 is set:

include 'emu8086.inc'
org 100h
  MOV AL, -5
  SUB AL, 127   ; AL = 7Ch (124)
JO  label1
  PRINT 'no overflow.'
JMP exit
label1:
  PRINT 'overflow!'
exit:
  RET</font></pre>
			<a name="JP">&nbsp;</a>
</td>
</tr>




<tr>
<td>
<font face="Fixedsys">
JP
</font>
</td>
<td>
<font face="Fixedsys">
	<nobr>label</nobr>
</font>
</td>
<td>

Short Jump if Parity (even). Only 8 low bits of result are checked.
Set by CMP, SUB, ADD, TEST, AND, OR, XOR instructions.
<br><br>Algorithm:<br><br>
<font face="Fixedsys">
<ul>
	if PF = 1 then jump
</ul>
</font>
Example:<pre><font face="Fixedsys">   include 'emu8086.inc'
   ORG 100h
   MOV AL, 00000101b   ; AL = 5
   OR  AL, 0           ; just set flags.
   JP label1
   PRINT 'parity odd.'
   JMP exit
label1:
   PRINT 'parity even.'
exit:
   RET</font></pre>
			<a name="JPE">&nbsp;</a>
</td>
</tr>




<tr>
<td>
<font face="Fixedsys">
JPE
</font>
</td>
<td>
<font face="Fixedsys">
	<nobr>label</nobr>
</font>
</td>
<td>

Short Jump if Parity Even. Only 8 low bits of result are checked.
Set by CMP, SUB, ADD, TEST, AND, OR, XOR instructions.
<br><br>Algorithm:<br><br>
<font face="Fixedsys">
<ul>
	if PF = 1 then jump
</ul>
</font>
Example:<pre><font face="Fixedsys">   include 'emu8086.inc'
   ORG 100h
   MOV AL, 00000101b   ; AL = 5
   OR  AL, 0           ; just set flags.
   JPE label1
   PRINT 'parity odd.'
   JMP exit
label1:
   PRINT 'parity even.'
exit:
   RET</font></pre>
			<a name="JPO">&nbsp;</a>
</td>
</tr>




<tr>
<td>
<font face="Fixedsys">
JPO
</font>
</td>
<td>
<font face="Fixedsys">
	<nobr>label</nobr>
</font>
</td>
<td>

Short Jump if Parity Odd. Only 8 low bits of result are checked.
Set by CMP, SUB, ADD, TEST, AND, OR, XOR instructions.
<br><br>Algorithm:<br><br>
<font face="Fixedsys">
<ul>
	if PF = 0 then jump
</ul>
</font>
Example:<pre><font face="Fixedsys">   include 'emu8086.inc'
   ORG 100h
   MOV AL, 00000111b   ; AL = 7
   OR  AL, 0           ; just set flags.
   JPO label1
   PRINT 'parity even.'
   JMP exit
label1:
   PRINT 'parity odd.'
exit:
   RET</font></pre>
			<a name="JS">&nbsp;</a>
</td>
</tr>




<tr>
<td>
<font face="Fixedsys">
JS
</font>
</td>
<td>
<font face="Fixedsys">
	<nobr>label</nobr>
</font>
</td>
<td>

Short Jump if Signed (if negative).
Set by CMP, SUB, ADD, TEST, AND, OR, XOR instructions.
<br><br>Algorithm:<br><br>
<font face="Fixedsys">
<ul>
	if SF = 1 then jump
</ul>
</font>
Example:<pre><font face="Fixedsys">   include 'emu8086.inc'
   ORG 100h
   MOV AL, 10000000b   ; AL = -128
   OR  AL, 0           ; just set flags.
   JS label1
   PRINT 'not signed.'
   JMP exit
label1:
   PRINT 'signed.'
exit:
   RET</font></pre>
			<a name="JZ">&nbsp;</a>
</td>
</tr>




<tr>
<td>
<font face="Fixedsys">
JZ
</font>
</td>
<td>
<font face="Fixedsys">
	<nobr>label</nobr>
</font>
</td>
<td>

Short Jump if Zero (equal).
Set by CMP, SUB, ADD, TEST, AND, OR, XOR instructions.
<br><br>Algorithm:<br><br>
<font face="Fixedsys">
<ul>
	if ZF = 1 then jump
</ul>
</font>
Example:<pre><font face="Fixedsys">   include 'emu8086.inc'
   ORG 100h
   MOV AL, 5
   CMP AL, 5
   JZ  label1
   PRINT 'AL is not equal to 5.'
   JMP exit
label1:
   PRINT 'AL is equal to 5.'
exit:
   RET</font></pre>
			<a name="LAHF">&nbsp;</a>
</td>
</tr>




<tr>
<td>
<font face="Fixedsys">
LAHF
</font>
</td>
<td>No operands</td>
<td>

Load AH from 8 low bits of Flags register.
<br><br>Algorithm:<br><br>
<font face="Fixedsys">
<ul>
	AH = flags register<br>
</ul>
<pre><font face="Fixedsys">
AH bit:   7    6   5    4   3    2   1    0
        [SF] [ZF] [0] [AF] [0] [PF] [1] [CF]</font>
</pre>
bits 1, 3, 5 are reserved.
</font>
			<a name="LDS">&nbsp;</a>
</td>
</tr>




<tr>
<td>
<font face="Fixedsys">
LDS
</font>
</td>
<td>
<font face="Fixedsys">
	<nobr>
	REG, memory
	</nobr>
</font>
</td>
<td>

Load memory double word into word register and DS.
<br><br>Algorithm:<br><br>
<font face="Fixedsys">
<ul>
    <li>REG = first word</li>
	<li>DS = second word</li>
</ul>
</font>
<br>
Example:
<pre><font face="Fixedsys">
ORG 100h

LDS AX, m

RET

m  DW  1234h
   DW  5678h

END
</font>
</pre>
AX is set to 1234h, DS is set to 5678h.
			<a name="LEA">&nbsp;</a>
</td>
</tr>




<tr>
<td>
<font face="Fixedsys">
LEA
</font>
</td>
<td>
<font face="Fixedsys">
	<nobr>
	REG, memory
	</nobr>
</font>
</td>
<td>

Load Effective Address.
<br><br>Algorithm:<br><br>
<font face="Fixedsys">
<ul>
    <li>REG = address of memory (offset)</li>
</ul>
</font>
<br>
Generally this instruction is replaced by MOV when assembling when possible.
<br><br>
Example:
<pre><font face="Fixedsys">
ORG 100h

LEA AX, m

RET

m  DW  1234h

END
</font>
</pre>
AX is set to: 0104h.<br>
LEA instruction takes 3 bytes, RET takes 1 byte, we start
at 100h, so the address of 'm' is 104h.
			<a name="LES">&nbsp;</a>
</td>
</tr>




<tr>
<td>
<font face="Fixedsys">
LES
</font>
</td>
<td>
<font face="Fixedsys">
	<nobr>
	REG, memory
	</nobr>
</font>
</td>
<td>

Load memory double word into word register and ES.
<br><br>Algorithm:<br><br>
<font face="Fixedsys">
<ul>
    <li>REG = first word</li>
	<li>ES = second word</li>
</ul>
</font>
<br>
Example:
<pre><font face="Fixedsys">
ORG 100h

LES AX, m

RET

m  DW  1234h
   DW  5678h

END
</font>
</pre>
AX is set to 1234h, ES is set to 5678h.
			<a name="LODSB">&nbsp;</a>
</td>
</tr>




<tr>
<td>
<font face="Fixedsys">
LODSB
</font>
</td>
<td>No operands</td>
<td>

Load byte at DS:[SI] into AL. Update SI.<br><br>Algorithm:
<br><br>
<font face="Fixedsys">
<ul>
<li>AL = DS:[SI]<br></li>
<li>if DF = 0 then
	<ul>
	<li>SI = SI + 1</li>
	</ul>
	else
	<ul>
	<li>SI = SI - 1</li>
	</ul>
</li>
</ul>
</font>
			<a name="LODSW">&nbsp;</a>
</td>
</tr>




<tr>
<td>
<font face="Fixedsys">
LODSW
</font>
</td>
<td>No operands</td>
<td>

Load word at DS:[SI] into AX. Update SI.<br><br>Algorithm:
<br><br>
<font face="Fixedsys">
<ul>
<li>AX = DS:[SI]<br></li>
<li>if DF = 0 then
	<ul>
	<li>SI = SI + 2</li>
	</ul>
	else
	<ul>
	<li>SI = SI - 2</li>
	</ul>
</li>
</ul>
</font>
			<a name="LOOP">&nbsp;</a>
</td>
</tr>




<tr>
<td>
<font face="Fixedsys">
LOOP
</font>
</td>
<td>
<font face="Fixedsys">
	<nobr>label</nobr>
</font>
</td>
<td>

Decrease CX, jump to label if CX not zero. <br><br>Algorithm:
<br><br>
<font face="Fixedsys">
<ul>
<li>CX = CX - 1<br></li>
<li>if CX &lt;&gt; 0 then
	<ul>
	<li>jump</li>
	</ul>
	else
	<ul>
	<li>no jump, continue</li>
	</ul>
</li>
</ul>
</font>
Example:<pre><font face="Fixedsys">   include 'emu8086.inc'
   ORG 100h
   MOV CX, 5
label1:
   PRINTN 'loop!'
   LOOP label1
   RET</font></pre>
			<a name="LOOPE">&nbsp;</a>
</td>
</tr>




<tr>
<td>
<font face="Fixedsys">
LOOPE
</font>
</td>
<td>
<font face="Fixedsys">
	<nobr>label</nobr>
</font>
</td>
<td>

Decrease CX, jump to label if CX not zero and Equal (ZF = 1). <br><br>Algorithm:
<br><br>
<font face="Fixedsys">
<ul>
<li>CX = CX - 1<br></li>
<li>if (CX &lt;&gt; 0) and (ZF = 1) then
	<ul>
	<li>jump</li>
	</ul>
	else
	<ul>
	<li>no jump, continue</li>
	</ul>
</li>
</ul>
</font>
Example:<pre><font face="Fixedsys">; Loop until result fits into AL alone,
; or 5 times. The result will be over 255
; on third loop (100+100+100),
; so loop will exit.

   include 'emu8086.inc'
   ORG 100h
   MOV AX, 0
   MOV CX, 5
label1:
   PUTC '*'
   ADD AX, 100
   CMP AH, 0
   LOOPE label1
   RET</font></pre>
			<a name="LOOPNE">&nbsp;</a>
</td>
</tr>




<tr>
<td>
<font face="Fixedsys">
LOOPNE
</font>
</td>
<td>
<font face="Fixedsys">
	<nobr>label</nobr>
</font>
</td>
<td>

Decrease CX, jump to label if CX not zero and Not Equal (ZF = 0). <br><br>Algorithm:
<br><br>
<font face="Fixedsys">
<ul>
<li>CX = CX - 1<br></li>
<li>if (CX &lt;&gt; 0) and (ZF = 0) then
	<ul>
	<li>jump</li>
	</ul>
	else
	<ul>
	<li>no jump, continue</li>
	</ul>
</li>
</ul>
</font>
Example:<pre><font face="Fixedsys">; Loop until '7' is found,
; or 5 times.

   include 'emu8086.inc'
   ORG 100h
   MOV SI, 0
   MOV CX, 5
label1:
   PUTC '*'
   MOV AL, v1[SI]
   INC SI         ; next byte (SI=SI+1).
   CMP AL, 7
   LOOPNE label1
   RET
   v1 db 9, 8, 7, 6, 5</font></pre>
			<a name="LOOPNZ">&nbsp;</a>
</td>
</tr>




<tr>
<td>
<font face="Fixedsys">
LOOPNZ
</font>
</td>
<td>
<font face="Fixedsys">
	<nobr>label</nobr>
</font>
</td>
<td>

Decrease CX, jump to label if CX not zero and ZF = 0. <br><br>Algorithm:
<br><br>
<font face="Fixedsys">
<ul>
<li>CX = CX - 1<br></li>
<li>if (CX &lt;&gt; 0) and (ZF = 0) then
	<ul>
	<li>jump</li>
	</ul>
	else
	<ul>
	<li>no jump, continue</li>
	</ul>
</li>
</ul>
</font>
Example:<pre><font face="Fixedsys">; Loop until '7' is found,
; or 5 times.

   include 'emu8086.inc'
   ORG 100h
   MOV SI, 0
   MOV CX, 5
label1:
   PUTC '*'
   MOV AL, v1[SI]
   INC SI         ; next byte (SI=SI+1).
   CMP AL, 7
   LOOPNZ label1
   RET
   v1 db 9, 8, 7, 6, 5</font></pre>
			<a name="LOOPZ">&nbsp;</a>
</td>
</tr>




<tr>
<td>
<font face="Fixedsys">
LOOPZ
</font>
</td>
<td>
<font face="Fixedsys">
	<nobr>label</nobr>
</font>

</td>
<td>

Decrease CX, jump to label if CX not zero and ZF = 1. <br><br>Algorithm:
<br><br>
<font face="Fixedsys">
<ul>
<li>CX = CX - 1<br></li>
<li>if (CX &lt;&gt; 0) and (ZF = 1) then
	<ul>
	<li>jump</li>
	</ul>
	else
	<ul>
	<li>no jump, continue</li>
	</ul>
</li>
</ul>
</font>
Example:<pre><font face="Fixedsys">; Loop until result fits into AL alone,
; or 5 times. The result will be over 255
; on third loop (100+100+100),
; so loop will exit.

   include 'emu8086.inc'
   ORG 100h
   MOV AX, 0
   MOV CX, 5
label1:
   PUTC '*'
   ADD AX, 100
   CMP AH, 0
   LOOPZ label1
   RET</font></pre>
			<a name="MOV">&nbsp;</a>
</td>
</tr>




<tr>
<td>
<font face="Fixedsys">
MOV
</font>
</td>
<td>
<font face="Fixedsys">
	<nobr>
	REG, memory<br>
	memory, REG<br>
	REG, REG<br>
	memory, immediate<br>
	REG, immediate<br><br>

	SREG, memory<br>
	memory, SREG<br>
	REG, SREG<br>
	SREG, REG
	</nobr>
</font>
</td>
<td>

Copy operand2 to operand1.<br><br>
The MOV instruction <u>cannot</u>:
<ul>
<li>set the value of the CS and IP registers.</li>
<li>copy value of one segment register to another segment register (should copy to general register first).</li>
<li>copy immediate value to segment register (should copy to general register first).</li>
</ul>
<br>Algorithm:<br><br>
<font face="Fixedsys">
<blockquote>
operand1 = operand2
</blockquote>
</font>
Example:<pre><font face="Fixedsys">ORG 100h
MOV AX, 0B800h    ; set AX = B800h (VGA memory).
MOV DS, AX        ; copy value of AX to DS.
MOV CL, 'A'       ; CL = 41h (ASCII code).
MOV CH, 01011111b ; CL = color attribute.
MOV BX, 15Eh      ; BX = position on screen.
MOV [BX], CX      ; w.[0B800h:015Eh] = CX.
RET               ; returns to operating system.
</font></pre>
			<a name="MOVSB">&nbsp;</a>
</td>
</tr>




<tr>
<td>
<font face="Fixedsys">
MOVSB
</font>
</td>
<td>No operands</td>
<td>

Copy byte at DS:[SI] to ES:[DI].
Update SI and DI.<br><br>Algorithm:
<br><br>
<font face="Fixedsys">
<ul>
<li>ES:[DI] = DS:[SI]<br></li>
<li>if DF = 0 then
	<ul>
	<li>SI = SI + 1</li>
	<li>DI = DI + 1</li>
	</ul>
	else
	<ul>
	<li>SI = SI - 1</li>
	<li>DI = DI - 1</li>
	</ul>
</li>
</ul>
</font>
			<a name="MOVSW">&nbsp;</a>
</td>
</tr>




<tr>
<td>
<font face="Fixedsys">
MOVSW
</font>
</td>
<td>No operands</td>
<td>

Copy byte at DS:[SI] to ES:[DI].
Update SI and DI.<br><br>Algorithm:
<br><br>
<font face="Fixedsys">
<ul>
<li>ES:[DI] = DS:[SI]<br></li>
<li>if DF = 0 then
	<ul>
	<li>SI = SI + 2</li>
	<li>DI = DI + 2</li>
	</ul>
	else
	<ul>
	<li>SI = SI - 2</li>
	<li>DI = DI - 2</li>
	</ul>
</li>
</ul>
</font>
			<a name="MUL">&nbsp;</a>
</td>
</tr>




<tr>
<td>
<font face="Fixedsys">
MUL
</font>
</td>
<td>
<font face="Fixedsys">
	<nobr>
	REG<br>
	memory<br>
	</nobr>
</font>
</td>
<td>

Unsigned multiply.
<br><br>Algorithm:<br><br>
 <blockquote>
	 when operand is a <b>byte</b>:<br>
	 <font face="Fixedsys">AX = AL * operand</font>.
 </blockquote>

 <blockquote>
	when operand is a <b>word</b>:<br>
	<font face="Fixedsys">(DX AX) = AX * operand</font>.
 </blockquote>
   Example:<pre><font face="Fixedsys">MOV AL, 200   ; AL = 0C8h
MOV BL, 4
MUL BL        ; AX = 0320h (800)
RET</font></pre>
 			<a name="NEG">&nbsp;</a>
</td>
</tr>




<tr>
<td>
<font face="Fixedsys">
NEG
</font>
</td>
<td>
<font face="Fixedsys">
	<nobr>
	REG<br>
	memory<br>
	</nobr>
</font>
</td>
<td>

Negate. Makes operand negative (two's complement).
<br><br>Algorithm:<br><br>
 <font face="Fixedsys">
 <ul>
 <li>Invert all bits of the operand</li>
 <li>Add 1 to inverted operand</li>
 </ul>
 </font>
    Example:<pre><font face="Fixedsys">MOV AL, 5   ; AL = 05h
NEG AL      ; AL = 0FBh (-5)
NEG AL      ; AL = 05h (5)
RET</font></pre>
 			<a name="NOP">&nbsp;</a>
</td>
</tr>




<tr>
<td>
<font face="Fixedsys">
NOP
</font>
</td>
<td>No operands</td>
<td>

No Operation.<br><br>Algorithm:
<br><br>
<font face="Fixedsys">
<ul>
<li>Do nothing<br></li>
</ul>
</font>
    Example:<pre><font face="Fixedsys">NOP
NOP
NOP
RET</font></pre>
			<a name="OR">&nbsp;</a>
</td>
</tr>




<tr>
<td>
<font face="Fixedsys">
OR
</font>
</td>
<td>
<font face="Fixedsys">
	<nobr>
	REG, memory<br>
	memory, REG<br>
	REG, REG<br>
	memory, immediate<br>
	REG, immediate
	</nobr>
</font>
</td>
<td>

Logical OR between all bits of two operands.
Result is stored in first operand.<br><br>
These rules apply:<br><br>
<font face="Fixedsys">
1 OR 1 = 1<br>
1 OR 0 = 1<br>
0 OR 1 = 1<br>
0 OR 0 = 0<br>
</font>
<br><br>Example:<pre><font face="Fixedsys">MOV AL, 'A'       ; AL = 01000001b
OR AL, 00100000b  ; AL = 01100001b  ('a')
RET</font></pre>
			<a name="OUT">&nbsp;</a>
</td>
</tr>

<tr>
<td>
<font face="Fixedsys">
OUT
</font>
</td>
<td>
<font face="Fixedsys">
	<nobr>
	im.byte, AL<br>
	im.byte, AX<br>
	DX, AL<br>
	DX, AX
	</nobr>
</font>
</td>
<td>

Output from <b>AL</b> or <b>AX</b> to port.<br>
First operand is a port number. If required to access
port number over 255 - <b>DX</b> register should be used.

<br><br>Example:<pre><font face="Fixedsys">MOV AX, 0FFFh ; Turn on all
OUT 4, AX     ; traffic lights.

MOV AL, 100b  ; Turn on the third
OUT 7, AL     ; magnet of the stepper-motor.</font></pre>
 			<a name="POP">&nbsp;</a>
</td>
</tr>


<tr>
<td>
<font face="Fixedsys">
POP
</font>
</td>
<td>
<font face="Fixedsys">
	<nobr>
	REG<br>
	SREG<br>
	memory
	</nobr>
</font>
</td>
<td>

Get 16 bit value from the stack.
<br><br>Algorithm:<br><br>
 <font face="Fixedsys">
 <ul>
 <li>operand = SS:[SP] (top of the stack)</li>
 <li>SP = SP + 2</li>
 </ul>
 </font>
 <br>Example:<pre><font face="Fixedsys">MOV AX, 1234h
PUSH AX
POP  DX     ; DX = 1234h
RET</font></pre>
 			<a name="POPA">&nbsp;</a>
</td>
</tr>




<tr>
<td>
<font face="Fixedsys">
POPA
</font>
</td>
<td>No operands</td>
<td>

Pop all general purpose registers DI, SI, BP, SP, BX, DX, CX, AX from the stack.<br>
SP value is ignored, it is Popped but not set to SP register).<br><br>
Note: this instruction works only on <b>80186</b> CPU and later!
<br><br>Algorithm:<br><br>
 <font face="Fixedsys">
 <ul>
 <li>POP DI</li>
 <li>POP SI</li>
 <li>POP BP</li>
 <li>POP xx (SP value ignored)</li>
 <li>POP BX</li>
 <li>POP DX</li>
 <li>POP CX</li>
 <li>POP AX</li>
 </ul>
 </font>
			<a name="POPF">&nbsp;</a>
</td>
</tr>




<tr>
<td>
<font face="Fixedsys">
POPF
</font>
</td>
<td>No operands</td>
<td>

Get flags register from the stack.
<br><br>Algorithm:<br><br>
 <font face="Fixedsys">
 <ul>
 <li>flags = SS:[SP] (top of the stack)</li>
 <li>SP = SP + 2</li>
 </ul>
 </font>
 			<a name="PUSH">&nbsp;</a>
</td>
</tr>




<tr>
<td>
<font face="Fixedsys">
PUSH
</font>
</td>
<td>
<font face="Fixedsys">
	<nobr>
	REG<br>
	SREG<br>
	memory<br>
	immediate
	</nobr>
</font>
</td>
<td>

Store 16 bit value in the stack.<br><br>

Note: <b>PUSH immediate</b> works only on 80186 CPU and later!
<br><br>Algorithm:<br><br>
 <font face="Fixedsys">
 <ul>
 <li>SP = SP - 2</li>
 <li>SS:[SP] (top of the stack) = operand</li>
 </ul>
 </font>
<br>Example:<pre><font face="Fixedsys">MOV AX, 1234h
PUSH AX
POP  DX     ; DX = 1234h
RET</font></pre>
 			<a name="PUSHA">&nbsp;</a>
</td>
</tr>




<tr>
<td>
<font face="Fixedsys">
PUSHA
</font>
</td>
<td>No operands</td>
<td>

Push all general purpose registers AX, CX, DX, BX, SP, BP, SI, DI in the stack.<br>
Original value of SP register (before PUSHA) is used.<br><br>
Note: this instruction works only on <b>80186</b> CPU and later!
<br><br>Algorithm:<br><br>
 <font face="Fixedsys">
 <ul>
	<li>PUSH AX</li>
	<li>PUSH CX</li>
	<li>PUSH DX</li>
	<li>PUSH BX</li>
	<li>PUSH SP</li>
	<li>PUSH BP</li>
	<li>PUSH SI</li>
	<li>PUSH DI</li>
 </ul>
 </font>
			<a name="PUSHF">&nbsp;</a>
</td>
</tr>




<tr>
<td>
<font face="Fixedsys">
PUSHF
</font>
</td>
<td>No operands</td>
<td>

Store flags register in the stack.
<br><br>Algorithm:<br><br>
 <font face="Fixedsys">
 <ul>
 <li>SP = SP - 2</li>
 <li>SS:[SP] (top of the stack) = flags</li>
 </ul>
 </font>
 			<a name="RCL">&nbsp;</a>
</td>
</tr>




<tr>
<td>
<font face="Fixedsys">
RCL
</font>
</td>
<td>
<font face="Fixedsys">
	<nobr>memory, immediate</nobr><br>
	<nobr>REG, immediate</nobr><br><br>
	<nobr>memory, CL</nobr><br>
	<nobr>REG, CL</nobr>
</font>
</td>
<td>

Rotate operand1 left through Carry Flag. The number of rotates is set by operand2.
<br>
When <b>immediate</b> is greater then 1, assembler generates several
<b>RCL xx, 1</b> instructions because 8086 has machine code only for this
instruction (the same principle works for all other shift/rotate instructions).

<br><br>Algorithm:<br><br>
<font face="Fixedsys">
<ul>
	shift all bits left, the bit that goes off is set to
	CF and previous value of CF is inserted to the right-most position.
</ul>
</font>
<br>Example:<pre><font face="Fixedsys">STC               ; set carry (CF=1).
MOV AL, 1Ch       ; AL = 00011100b
RCL AL, 1         ; AL = 00111001b,  CF=0.
RET</font></pre>
			<a name="RCR">&nbsp;</a>
</td>
</tr>




<tr>
<td>
<font face="Fixedsys">
RCR
</font>
</td>
<td>
<font face="Fixedsys">
	<nobr>memory, immediate</nobr><br>
	<nobr>REG, immediate</nobr><br><br>
	<nobr>memory, CL</nobr><br>
	<nobr>REG, CL</nobr>
</font>
</td>
<td>

Rotate operand1 right through Carry Flag. The number of rotates is set by operand2.

<br><br>Algorithm:<br><br>
<font face="Fixedsys">
<ul>
	shift all bits right, the bit that goes off is set to
	CF and previous value of CF is inserted to the left-most position.
</ul>
</font>
<br>Example:<pre><font face="Fixedsys">STC               ; set carry (CF=1).
MOV AL, 1Ch       ; AL = 00011100b
RCR AL, 1         ; AL = 10001110b,  CF=0.
RET</font></pre>
			<a name="REP">&nbsp;</a>
</td>
</tr>




<tr>
<td>
<font face="Fixedsys">
REP
</font>
</td>
<td>
<font face="Fixedsys">
	<nobr>chain instruction</nobr><br>
</font>
</td>
<td>

Repeat following MOVSB, MOVSW, LODSB, LODSW, STOSB, STOSW instructions
CX times.
<br><br>Algorithm:<br><br>
<font face="Fixedsys">
check_cx:<br><br>
if CX &lt;&gt; 0 then
<ul>
	<li>do following <u>chain instruction</u></li>
	<li>CX = CX - 1</li>
	<li>go back to check_cx</li>
</ul>
else
<ul>
	<li>exit from REP cycle</li>
</ul>
</font>
			<a name="REPE">&nbsp;</a>
</td>
</tr>





<tr>
<td>
<font face="Fixedsys">
REPE
</font>
</td>
<td>
<font face="Fixedsys">
	<nobr>chain instruction</nobr><br>
</font>
</td>
<td>

Repeat following CMPSB, CMPSW, SCASB, SCASW instructions
while ZF = 1 (result is Equal), maximum CX times.
<br><br>Algorithm:<br><br>
<font face="Fixedsys">
check_cx:<br><br>
if CX &lt;&gt; 0 then
<ul>
	<li>do following <u>chain instruction</u></li>
	<li>CX = CX - 1</li>
	<li>if ZF = 1 then:
		<ul>
		<li>go back to check_cx</li>
		</ul>
	else
		<ul>
		<li>exit from REPE cycle</li>
		</ul>
	</li>
</ul>
else
<ul>
	<li>exit from REPE cycle</li>
</ul>
</font>
Example:<br>
see <b><a href="https://dsearls.org/courses/C391OrgSys/Samples/cmpsb.asm">cmpsb.asm</a></b> in Samples.
			<a name="REPNE">&nbsp;</a>
</td>
</tr>





<tr>
<td>
<font face="Fixedsys">
REPNE
</font>
</td>
<td>
<font face="Fixedsys">
	<nobr>chain instruction</nobr><br>
</font>
</td>
<td>

Repeat following CMPSB, CMPSW, SCASB, SCASW instructions
while ZF = 0 (result is Not Equal), maximum CX times.
<br><br>Algorithm:<br><br>
<font face="Fixedsys">
check_cx:<br><br>
if CX &lt;&gt; 0 then
<ul>
	<li>do following <u>chain instruction</u></li>
	<li>CX = CX - 1</li>
	<li>if ZF = 0 then:
		<ul>
		<li>go back to check_cx</li>
		</ul>
	else
		<ul>
		<li>exit from REPNE cycle</li>
		</ul>
	</li>
</ul>
else
<ul>
	<li>exit from REPNE cycle</li>
</ul>
</font>
			<a name="REPNZ">&nbsp;</a>
</td>
</tr>





<tr>
<td>
<font face="Fixedsys">
REPNZ
</font>
</td>
<td>
<font face="Fixedsys">
	<nobr>chain instruction</nobr><br>
</font>
</td>
<td>

Repeat following CMPSB, CMPSW, SCASB, SCASW instructions
while ZF = 0 (result is Not Zero), maximum CX times.
<br><br>Algorithm:<br><br>
<font face="Fixedsys">
check_cx:<br><br>
if CX &lt;&gt; 0 then
<ul>
	<li>do following <u>chain instruction</u></li>
	<li>CX = CX - 1</li>
	<li>if ZF = 0 then:
		<ul>
		<li>go back to check_cx</li>
		</ul>
	else
		<ul>
		<li>exit from REPNZ cycle</li>
		</ul>
	</li>
</ul>
else
<ul>
	<li>exit from REPNZ cycle</li>
</ul>
</font>
			<a name="REPZ">&nbsp;</a>
</td>
</tr>





<tr>
<td>
<font face="Fixedsys">
REPZ
</font>
</td>
<td>
<font face="Fixedsys">
	<nobr>chain instruction</nobr><br>
</font>
</td>
<td>

Repeat following CMPSB, CMPSW, SCASB, SCASW instructions
while ZF = 1 (result is Zero), maximum CX times.
<br><br>Algorithm:<br><br>
<font face="Fixedsys">
check_cx:<br><br>
if CX &lt;&gt; 0 then
<ul>
	<li>do following <u>chain instruction</u></li>
	<li>CX = CX - 1</li>
	<li>if ZF = 1 then:
		<ul>
		<li>go back to check_cx</li>
		</ul>
	else
		<ul>
		<li>exit from REPZ cycle</li>
		</ul>
	</li>
</ul>
else
<ul>
	<li>exit from REPZ cycle</li>
</ul>
</font>
			<a name="RET">&nbsp;</a>
</td>
</tr>




<tr>
<td>
<font face="Fixedsys">
RET
</font>
</td>
<td>No operands<br>
or even immediate</td>
<td>

Return from near procedure.
<br><br>Algorithm:<br><br>
<font face="Fixedsys">
<ul>
	<li>
		Pop from stack:
		<ul>
		<li>IP</li>
		</ul>
	</li>
	<li>
	if <u>immediate</u> operand is present:
	<nobr>SP = SP + operand</nobr>
	</li>
</ul>
</font>
Example:<pre><font face="Fixedsys">ORG 100h  ; for COM file.

CALL p1

ADD AX, 1

RET         ; return to OS.

p1 PROC     ; procedure declaration.
    MOV AX, 1234h
    RET     ; return to caller.
p1 ENDP</font></pre>
			<a name="RETF">&nbsp;</a>
</td>
</tr>




<tr>
<td>
<font face="Fixedsys">
RETF
</font>
</td>
<td>No operands<br>
or even immediate</td>
<td>

Return from Far procedure.
<br><br>Algorithm:<br><br>
<font face="Fixedsys">
<ul>
	<li>
		Pop from stack:
		<ul>
		<li>IP</li>
		<li>CS</li>
		</ul>
	</li>
	<li>
	if <u>immediate</u> operand is present:
	<nobr>SP = SP + operand</nobr>
	</li>
</ul>
</font>
			<a name="ROL">&nbsp;</a>
</td>
</tr>




<tr>
<td>
<font face="Fixedsys">
ROL
</font>
</td>
<td>
<font face="Fixedsys">
	<nobr>memory, immediate</nobr><br>
	<nobr>REG, immediate</nobr><br><br>
	<nobr>memory, CL</nobr><br>
	<nobr>REG, CL</nobr>
</font>
</td>
<td>

Rotate operand1 left. The number of rotates is set by operand2.

<br><br>Algorithm:<br><br>
<font face="Fixedsys">
<ul>
	shift all bits left, the bit that goes off is set to
	CF and the same bit is inserted to the right-most position.
</ul>
</font>
Example:<pre><font face="Fixedsys">MOV AL, 1Ch       ; AL = 00011100b
ROL AL, 1         ; AL = 00111000b,  CF=0.
RET</font></pre>
			<a name="ROR">&nbsp;</a>
</td>
</tr>




<tr>
<td>
<font face="Fixedsys">
ROR
</font>
</td>
<td>
<font face="Fixedsys">
	<nobr>memory, immediate</nobr><br>
	<nobr>REG, immediate</nobr><br><br>
	<nobr>memory, CL</nobr><br>
	<nobr>REG, CL</nobr>
</font>
</td>
<td>

Rotate operand1 right. The number of rotates is set by operand2.

<br><br>Algorithm:<br><br>
<font face="Fixedsys">
<ul>
	shift all bits right, the bit that goes off is set to
	CF and the same bit is inserted to the left-most position.
</ul>
</font>
Example:<pre><font face="Fixedsys">MOV AL, 1Ch       ; AL = 00011100b
ROR AL, 1         ; AL = 00001110b,  CF=0.
RET</font></pre>
			<a name="SAHF">&nbsp;</a>
</td>
</tr>




<tr>
<td>
<font face="Fixedsys">
SAHF
</font>
</td>
<td>No operands</td>
<td>

Store AH register into low 8 bits of Flags register.
<br><br>Algorithm:<br><br>
<font face="Fixedsys">
<ul>
	flags register = AH<br>
</ul>
<pre><font face="Fixedsys">
AH bit:   7    6   5    4   3    2   1    0
        [SF] [ZF] [0] [AF] [0] [PF] [1] [CF]</font>
</pre>
bits 1, 3, 5 are reserved.
</font>
			<a name="SAL">&nbsp;</a>
</td>
</tr>





<tr>
<td>
<font face="Fixedsys">
SAL
</font>
</td>
<td>
<font face="Fixedsys">
	<nobr>memory, immediate</nobr><br>
	<nobr>REG, immediate</nobr><br><br>
	<nobr>memory, CL</nobr><br>
	<nobr>REG, CL</nobr>
</font>
</td>
<td>

Shift Arithmetic operand1 Left. The number of shifts is set by operand2.

<br><br>Algorithm:<br><br>
<font face="Fixedsys">
<ul>
	<li>Shift all bits left, the bit that goes off is set to CF.</li>
	<li>Zero bit is inserted to the right-most position.</li>
</ul>
</font>
Example:<pre><font face="Fixedsys">MOV AL, 0E0h      ; AL = 11100000b
SAL AL, 1         ; AL = 11000000b,  CF=1.
RET</font></pre>
			<a name="SAR">&nbsp;</a>
</td>
</tr>





<tr>
<td>
<font face="Fixedsys">
SAR
</font>
</td>
<td>
<font face="Fixedsys">
	<nobr>memory, immediate</nobr><br>
	<nobr>REG, immediate</nobr><br><br>
	<nobr>memory, CL</nobr><br>
	<nobr>REG, CL</nobr>
</font>
</td>
<td>

Shift Arithmetic operand1 Right. The number of shifts is set by operand2.

<br><br>Algorithm:<br><br>
<font face="Fixedsys">
<ul>
	<li>Shift all bits right, the bit that goes off is set to CF.</li>
	<li>The sign bit that is inserted to the left-most position has
	    the same value as before shift.</li>
</ul>
</font>
Example:<pre><font face="Fixedsys">MOV AL, 0E0h      ; AL = 11100000b
SAR AL, 1         ; AL = 11110000b,  CF=0.

MOV BL, 4Ch       ; BL = 01001100b
SAR BL, 1         ; BL = 00100110b,  CF=0.

RET</font></pre>
			<a name="SBB">&nbsp;</a>
</td>
</tr>




<tr>
<td>
<font face="Fixedsys">
SBB
</font>
</td>
<td>
<font face="Fixedsys">
	<nobr>
	REG, memory<br>
	memory, REG<br>
	REG, REG<br>
	memory, immediate<br>
	REG, immediate
	</nobr>
</font>
</td>
<td>

Subtract with Borrow.
<br><br>Algorithm:<br><br>
<font face="Fixedsys">
operand1 = operand1 - operand2 - CF
</font>
			<a name="SCASB">&nbsp;</a>
</td>
</tr>





<tr>
<td>
<font face="Fixedsys">
SCASB
</font>
</td>
<td>No operands</td>
<td>

Compare bytes: <nobr>AL from ES:[DI].</nobr> <br><br>Algorithm:
<br><br>
<font face="Fixedsys">
<ul>
<li>ES:[DI] - AL<br></li>
<li>set flags according to result:<br> OF, SF, ZF, AF, PF, CF<br></li>
<li>if DF = 0 then
	<ul>
	<li>DI = DI + 1</li>
	</ul>
	else
	<ul>
	<li>DI = DI - 1</li>
	</ul>
</li>
</ul>
</font>
			<a name="SCASW">&nbsp;</a>
</td>
</tr>




<tr>
<td>
<font face="Fixedsys">
SCASW
</font>
</td>
<td>No operands</td>
<td>

Compare words: <nobr>AX from ES:[DI].</nobr> <br><br>Algorithm:
<br><br>
<font face="Fixedsys">
<ul>
<li>ES:[DI] - AX<br></li>
<li>set flags according to result:<br> OF, SF, ZF, AF, PF, CF<br></li>
<li>if DF = 0 then
	<ul>
	<li>DI = DI + 2</li>
	</ul>
	else
	<ul>
	<li>DI = DI - 2</li>
	</ul>
</li>
</ul>
</font>
			<a name="SHL">&nbsp;</a>
</td>
</tr>





<tr>
<td>
<font face="Fixedsys">
SHL
</font>
</td>
<td>
<font face="Fixedsys">
	<nobr>memory, immediate</nobr><br>
	<nobr>REG, immediate</nobr><br><br>
	<nobr>memory, CL</nobr><br>
	<nobr>REG, CL</nobr>
</font>
</td>
<td>

Shift operand1 Left. The number of shifts is set by operand2.

<br><br>Algorithm:<br><br>
<font face="Fixedsys">
<ul>
	<li>Shift all bits left, the bit that goes off is set to CF.</li>
	<li>Zero bit is inserted to the right-most position.</li>
</ul>
</font>
			<a name="SHR">&nbsp;</a>
</td>
</tr>





<tr>
<td>
<font face="Fixedsys">
SHR
</font>
</td>
<td>
<font face="Fixedsys">
	<nobr>memory, immediate</nobr><br>
	<nobr>REG, immediate</nobr><br><br>
	<nobr>memory, CL</nobr><br>
	<nobr>REG, CL</nobr>
</font>
</td>
<td>

Shift operand1 Right. The number of shifts is set by operand2.

<br><br>Algorithm:<br><br>
<font face="Fixedsys">
<ul>
	<li>Shift all bits right, the bit that goes off is set to CF.</li>
	<li>Zero bit is inserted to the left-most position.</li>
</ul>
</font>
			<a name="STC">&nbsp;</a>
</td>
</tr>




<tr>
<td>
<font face="Fixedsys">
STC
</font>
</td>
<td>No operands</td>
<td>

Set Carry flag. <br><br>Algorithm:
<br><br>
<font face="Fixedsys">
CF = 1
</font>
			<a name="STD">&nbsp;</a>
</td>
</tr>




<tr>
<td>
<font face="Fixedsys">
STD
</font>
</td>
<td>No operands</td>
<td>

Set Direction flag. SI and DI will be decremented by chain
instructions: CMPSB, CMPSW, LODSB, LODSW, MOVSB, MOVSW, STOSB, STOSW. <br><br>Algorithm:
<br><br>
<font face="Fixedsys">
DF = 1
</font>
			<a name="STI">&nbsp;</a>
</td>
</tr>






<tr>
<td>
<font face="Fixedsys">
STI
</font>
</td>
<td>No operands</td>
<td>

Set Interrupt enable flag. This enables hardware interrupts. <br><br>Algorithm:
<br><br>
<font face="Fixedsys">
IF = 1
</font>
			<a name="STOSB">&nbsp;</a>
</td>
</tr>




<tr>
<td>
<font face="Fixedsys">
STOSB
</font>
</td>
<td>No operands</td>
<td>

Store byte in AL into ES:[DI]. Update SI.<br><br>Algorithm:
<br><br>
<font face="Fixedsys">
<ul>
<li>ES:[DI] = AL<br></li>
<li>if DF = 0 then
	<ul>
	<li>DI = DI + 1</li>
	</ul>
	else
	<ul>
	<li>DI = DI - 1</li>
	</ul>
</li>
</ul>
</font>
			<a name="STOSW">&nbsp;</a>
</td>
</tr>





<tr>
<td>
<font face="Fixedsys">
STOSW
</font>
</td>
<td>No operands</td>
<td>

Store word in AX into ES:[DI]. Update SI.<br><br>Algorithm:
<br><br>
<font face="Fixedsys">
<ul>
<li>ES:[DI] = AX<br></li>
<li>if DF = 0 then
	<ul>
	<li>DI = DI + 2</li>
	</ul>
	else
	<ul>
	<li>DI = DI - 2</li>
	</ul>
</li>
</ul>
</font>
			<a name="SUB">&nbsp;</a>
</td>
</tr>






<tr>
<td>
<font face="Fixedsys">
SUB
</font>
</td>
<td>
<font face="Fixedsys">
	<nobr>
	REG, memory<br>
	memory, REG<br>
	REG, REG<br>
	memory, immediate<br>
	REG, immediate
	</nobr>
</font>
</td>
<td>

Subtract.
<br><br>Algorithm:<br><br>
<font face="Fixedsys">
operand1 = operand1 - operand2
</font>
			<a name="TEST">&nbsp;</a>
</td>
</tr>






<tr>
<td>
<font face="Fixedsys">
TEST
</font>
</td>
<td>
<font face="Fixedsys">
	<nobr>
	REG, memory<br>
	memory, REG<br>
	REG, REG<br>
	memory, immediate<br>
	REG, immediate
	</nobr>
</font>
</td>
<td>

Logical AND between all bits of two operands for flags only.
These flags are effected: <b>ZF, SF, PF.</b>
Result is not stored anywhere.<br><br>
These rules apply:<br><br>
<font face="Fixedsys">
1 AND 1 = 1<br>
1 AND 0 = 0<br>
0 AND 1 = 0<br>
0 AND 0 = 0<br>
</font>
			<a name="XCHG">&nbsp;</a>
</td>
</tr>






<tr>
<td>
<font face="Fixedsys">
XCHG
</font>
</td>
<td>
<font face="Fixedsys">
	<nobr>
	REG, memory<br>
	memory, REG<br>
	REG, REG
	</nobr>
</font>
</td>
<td>

Exchange values of two operands.
<br><br>Algorithm:<br><br>
<font face="Fixedsys">
operand1 &lt; - &gt; operand2
</font>
			<a name="XLATB">&nbsp;</a>
</td>
</tr>






<tr>
<td>
<font face="Fixedsys">
XLATB
</font>
</td>
<td>No operands</td>
<td>

Translate byte from table.<br>
Set value of AL register to memory byte at <nobr>DS:[BX + unsigned AL]</nobr>
<br><br>Algorithm:<br><br>
<font face="Fixedsys">
DS:[BX + unsigned AL] = AL
</font>
			<a name="XOR">&nbsp;</a>
</td>
</tr>







<tr>
<td>
<font face="Fixedsys">
XOR
</font>
</td>
<td>
<font face="Fixedsys">
	<nobr>
	REG, memory<br>
	memory, REG<br>
	REG, REG<br>
	memory, immediate<br>
	REG, immediate
	</nobr>
</font>
</td>
<td>

Logical XOR (Exclusive OR) between all bits of two operands.
Result is stored in first operand.<br><br>
These rules apply:<br><br>
<font face="Fixedsys">
1 XOR 1 = 0<br>
1 XOR 0 = 1<br>
0 XOR 1 = 1<br>
0 XOR 0 = 0<br>
</font>
</td>
</tr>





</tbody></table>

<br><br>

<hr>

<br><br><br>
<center>
<font size="2">
Copyright  2002 Alexander Popov Emulation Soft.<br>
All rights reserved.<br>
<a href="http://www.geocities.com/emu8086/"><b>http://www.geocities.com/emu8086/</b></a>
</font>
</center>

</font>


<br>







</body></html>